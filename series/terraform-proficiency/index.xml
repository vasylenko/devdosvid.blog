<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Terraform Proficiency on devDosvid blog</title>
    <link>https://devdosvid.blog/series/terraform-proficiency/</link>
    <description>Recent content in Terraform Proficiency on devDosvid blog</description>
    <image>
      <title>devDosvid blog</title>
      <url>https://devdosvid.blog/assets/img/websitelogo.jpg</url>
      <link>https://devdosvid.blog/assets/img/websitelogo.jpg</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 23 Feb 2025 22:35:50 +0100</lastBuildDate>
    <atom:link href="https://devdosvid.blog/series/terraform-proficiency/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A Deep Dive Into Terraform Static Code Analysis Tools: Features and Comparisons</title>
      <link>https://devdosvid.blog/2024/04/16/a-deep-dive-into-terraform-static-code-analysis-tools-features-and-comparisons/</link>
      <pubDate>Tue, 16 Apr 2024 21:14:15 +0200</pubDate>
      <guid>https://devdosvid.blog/2024/04/16/a-deep-dive-into-terraform-static-code-analysis-tools-features-and-comparisons/</guid>
      <description>Explore key features and comparisons of top Terraform static code analysis tools to enhance security and compliance in your infrastructure management.</description>
      <content:encoded><![CDATA[<p>Many teams employ Terraform by HashiCorp to efficiently manage their infrastructure, leveraging its ability to automate the lifecycle of complex environments. Yet, integrating security scanning into Terraform pipelines often remains overlooked, exposing these environments to potential security risks and compliance issues.</p>
<p>This article explores several prominent static code analyzers that support Terraform code and focus on its security scanning. This comparison will guide teams in choosing the right tool to enhance their security measures within Terraform workflows, ensuring safer and more compliant infrastructure management.</p>
<p>Here are the tools we&rsquo;ll be reviewing: <strong>KICS</strong>, <strong>tfsec</strong>, <strong>Trivy</strong>, <strong>Terrascan</strong>, <strong>Checkov</strong>, and <strong>Semgrep OSS</strong>.</p>
<p>While many of these tools also support other platforms and technologies, <strong>this review will concentrate exclusively on their functionality with Terraform.</strong></p>
<h2 id="why-use-static-code-analysis-for-terraform">Why use Static Code Analysis for Terraform</h2>
<p>Static code analysis tools are necessary to enhance the security of Terraform-managed infrastructures. Unlike linters, these tools focus not on syntax errors or coding style but delve deeply into the code to identify security vulnerabilities and potential compliance issues without running the actual code. This proactive approach to security helps safeguard the infrastructure from potential threats before deployment.</p>
<h3 id="key-benefits">Key Benefits</h3>
<ul>
<li>Early Detection: Identifies security vulnerabilities and misconfigurations early in development, preventing them from reaching production.</li>
<li>Compliance Assurance: Ensures Terraform code complies with industry standards and internal security policies.</li>
<li>Automated Security Integration: Seamlessly integrates with CI/CD pipelines, automating security checks to maintain a continuous focus on security.</li>
<li>Actionable Insights: Delivers detailed vulnerability reports, facilitating swift and effective resolution.</li>
<li>Scalability: Effectively handles increasing project complexity and size, maintaining rigorous security standards without additional manual effort.</li>
</ul>
<h3 id="expected-features">Expected Features</h3>
<ul>
<li><strong>Policy Coverage</strong>: The tool should offer comprehensive scanning capabilities to detect security vulnerabilities specific to Infrastructure as Code.</li>
<li><strong>Customizable Security Policies</strong>: It must allow users to define and adjust security policies and severity levels to align with specific project needs or compliance requirements.</li>
<li><strong>Seamless Integration</strong>: The analyzer should integrate effortlessly with existing CI/CD tools and version control systems, facilitating a smooth workflow.</li>
<li><strong>Detailed Reporting</strong>: Clear and actionable reports are crucial. The tool should prioritize issues based on severity and provide practical steps for remediation.</li>
<li><strong>Scanning Customization</strong>: Users should be able to tailor the scanning process to focus on particular aspects of the codebase, enabling targeted and efficient security assessments.</li>
</ul>
<p>With a clear understanding of the necessary features in a static code analyzer, which tools on the market best fulfill these criteria?</p>
<p>Let&rsquo;s take a closer look at some leading options!</p>
<h2 id="meet-the-static-code-analyzers-for-terraform">Meet the Static Code Analyzers for Terraform</h2>
<p>Following on what makes a static code analyzer robust, let&rsquo;s dive into some open-source tools that exemplify these essential features.</p>
<p>I picked six tools for my review. I know there are more on the market, but I focused on <strong>open-source, free-to-use</strong> tools and those that provide at least &gt;100 out-of-the-box scanning policies for Terraform.</p>
<p><strong>KICS</strong> (stands for &ldquo;Keeping Infrastructure as Code Secure&rdquo;): <br>
Owner/Maintainer: Checkmarx<br>
Age: First released on GitHub on November 30th, 2020<br>
License: <a href="https://github.com/Checkmarx/kics/blob/master/LICENSE">Apache License 2.0</a></p>
<p><strong>tfsec</strong><br>
Owner/Maintainer: Aqua Security (acquired in 2021)<br>
Age: First released on GitHub on March 5th, 2019<br>
License: <a href="https://github.com/aquasecurity/tfsec/blob/master/LICENSE">MIT License</a>
<div class="attention">
    tfsec project is no longer actively maintained in favor of the Trivy tool. But because many people still use it and it&rsquo;s quite famous, I added tfsec to this comparison.<br>
However, I recommend against using it for new projects.
</div></p>
<p><strong>Trivy</strong><br>
Owner/Maintainer: Aqua Security<br>
Age: First released on GitHub on May 7th, 2019<br>
License: <a href="https://github.com/aquasecurity/trivy/blob/main/LICENSE">Apache License 2.0</a><br>
<em>backward-compatible with tfsec</em></p>
<p><strong>Terrascan</strong><br>
Owner/Maintainer: Tenable (acquired in 2022)<br>
Age: First release on GitHub on November 28th, 2017<br>
License: <a href="https://github.com/tenable/terrascan/blob/master/LICENSE">Apache License 2.0</a></p>
<p><strong>Checkov</strong><br>
Owner/Maintainer: Prisma Cloud by Palo Alto Networks (acquired in 2021)<br>
Age: First released on GitHub on March 31st, 2021<br>
License: <a href="https://github.com/bridgecrewio/checkov/blob/main/LICENSE">Apache License 2.0</a></p>
<p><strong>Semgrep OSS</strong><br>
Owner/Maintainer: Semgrep<br>
Age: First release on GitHub on February 6th, 2020<br>
License: <a href="https://github.com/semgrep/semgrep/blob/develop/LICENSE">GNU Lesser General Public License v2.1</a></p>
<p>These tools are essential in enhancing Terraform&rsquo;s security posture and reflect a strong collaboration between open-source communities and enterprise backing. This blend ensures that the tools are not only accessible but also robustly maintained and up-to-date.</p>
<p>Let’s explore how these tools stack up regarding features and usability.</p>
<h2 id="comparing-out-of-the-box-policies-and-terraform-providers">Comparing Out-of-the-Box Policies and Terraform Providers</h2>
<p>Understanding the number and variety of default policies each tool offers is crucial for those just beginning to explore security automation for Terraform.</p>
<p>The extent of out-of-the-box policies can significantly ease the integration process of static analysis by providing immediate and comprehensive insights into potential security and compliance issues. Similarly, the number of supported Terraform Providers also plays a critical role.</p>
<p>In this chapter, we delve into these foundational features across observed tools, helping you pinpoint which one could best satisfy your requirements for robust, ready-to-use security scanning.</p>
<table>
  <thead>
      <tr>
          <th>Tool</th>
          <th>Policies</th>
          <th>Supported Terraform Providers</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>KICS</strong></td>
          <td>663</td>
          <td>aws, azure, gcp, kubernetes, alicloud, databricks, github, nifcloud</td>
      </tr>
      <tr>
          <td><strong>tfsec</strong></td>
          <td>154</td>
          <td>aws, azure, gcp, digitalocean, kubernetes, cloudstack, github, openstack, oracle</td>
      </tr>
      <tr>
          <td><strong>Trivy</strong></td>
          <td>322</td>
          <td>aws, azure, gcp, digitalocean, cloudstack, github, oracle, openstack</td>
      </tr>
      <tr>
          <td><strong>Terrascan</strong></td>
          <td>790</td>
          <td>aws, azure, gcp, digitalocean, kubernetes, docker, github</td>
      </tr>
      <tr>
          <td><strong>Checkov</strong></td>
          <td>2110</td>
          <td>aws, azure, gcp, digitalocean, kubernetes, github, gitlab, ibm, linode, openstack, alicloud</td>
      </tr>
      <tr>
          <td><strong>Semgrep OSS</strong></td>
          <td>362</td>
          <td>aws, azure, gcp</td>
      </tr>
  </tbody>
</table>
<p>As you can see, all tools support the &ldquo;Big Three&rdquo; cloud service Terraform providers—AWS, Azure, and GCP—for managing resources on these popular platforms.</p>
<p>With over 2000 out-of-the-box policies, Checkov significantly stands out from the competition. This tool also leads in the total number of supported Terraform providers.</p>
<p>While the default policies provide a strong foundation for security scanning, the ability to tailor these policies is just as crucial. Next, we&rsquo;ll explore how each tool accommodates custom policy capabilities, allowing you to fine-tune the policies to fit your project&rsquo;s specific requirements.</p>
<h2 id="custom-policy-capabilities">Custom Policy Capabilities</h2>
<p>Default policies serve as the foundation, but the nuances of each project demand the extension of this base.</p>
<p>Here, we delve into how each tool enables you to add custom policies, thus enhancing and refining the provided defaults.</p>
<p>While all six tools support adding custom policies to their default set, they differ in terminology: &lsquo;policy&rsquo; is the common term, whereas KICS refers to them as &lsquo;queries,&rsquo; and Semgrep calls them &lsquo;rules.&rsquo;</p>
<p>Regarding policy syntax:</p>
<p><strong>OPA Rego</strong> syntax is used by <a href="https://docs.kics.io/latest/creating-queries/">KICS</a>, <a href="https://aquasecurity.github.io/trivy/v0.50/docs/scanner/misconfiguration/custom/">Trivy</a>, <a href="https://aquasecurity.github.io/tfsec/latest/guides/rego/rego/">tfsec</a>, and <a href="https://runterrascan.io/docs/policies/policies/">Terrascan</a>.  It&rsquo;s a powerful language widely adopted in the industry, though there&rsquo;s a learning curve that could pay dividends for future projects.</p>
<p><strong>YAML</strong> syntax is used by <a href="https://www.checkov.io/3.Custom%20Policies/Custom%20Policies%20Overview.html">Checkov</a> and <a href="https://semgrep.dev/docs/writing-rules/rule-syntax/">Semgrep</a>. This offers a familiar and straightforward start, with Checkov also allowing policies to be written in Python, albeit with some constraints. With YAML, the ease of use is balanced against the limitations set by the tool&rsquo;s capabilities.</p>
<p>Understanding these differences will guide you to a tool that matches your security requirements, your team&rsquo;s expertise, and the scope of your infrastructure projects.</p>
<p>To illustrate, here is an example of a KICS Rego policy checking for default RDS instance ports:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>package Cx
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>import data.generic.common as common_lib
</span></span><span style="display:flex;"><span>import data.generic.terraform as tf_lib
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CxPolicy[result] {
</span></span><span style="display:flex;"><span>	db := input.document[i].resource.aws_db_instance[name]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	enginePort := common_lib.engines[e]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	db.engine == e
</span></span><span style="display:flex;"><span>	db.port == enginePort
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	result := {
</span></span><span style="display:flex;"><span>		&#34;documentId&#34;: input.document[i].id,
</span></span><span style="display:flex;"><span>		&#34;resourceType&#34;: &#34;aws_db_instance&#34;,
</span></span><span style="display:flex;"><span>		&#34;resourceName&#34;: tf_lib.get_resource_name(db, name),
</span></span><span style="display:flex;"><span>		&#34;searchKey&#34;: sprintf(&#34;aws_db_instance[%s].port&#34;, [name]),
</span></span><span style="display:flex;"><span>		&#34;issueType&#34;: &#34;IncorrectValue&#34;,
</span></span><span style="display:flex;"><span>		&#34;keyExpectedValue&#34;: sprintf(&#34;aws_db_instance[%s].port should not be set to %d&#34;, [name, enginePort]),
</span></span><span style="display:flex;"><span>		&#34;keyActualValue&#34;: sprintf(&#34;aws_db_instance[%s].port is set to %d&#34;, [name, enginePort]),
</span></span><span style="display:flex;"><span>		&#34;searchLine&#34;: common_lib.build_search_line([&#34;resource&#34;, &#34;aws_db_instance&#34;, name, &#34;port&#34;], []),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And an example of a Checkov YAML policy forbidding specific EC2 instance types:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ff7b72">---</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span><span style="color:#7ee787">metadata</span>:<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"> </span><span style="color:#7ee787">name</span>:<span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;Org&#39;s compute instances should not be p5.48xlarge or p4d.24xlarge&#34;</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"> </span><span style="color:#7ee787">id</span>:<span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;ACME_AWS_FORBIDDEN_EC2_TYPES&#34;</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"> </span><span style="color:#7ee787">category</span>:<span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;NETWORKING&#34;</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span><span style="color:#7ee787">definition</span>:<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"> </span><span style="color:#7ee787">or</span>:<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"> </span>- <span style="color:#7ee787">cond_type</span>:<span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;attribute&#34;</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">   </span><span style="color:#7ee787">resource_types</span>:<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>- <span style="color:#a5d6ff">&#34;aws_instance&#34;</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">   </span><span style="color:#7ee787">attribute</span>:<span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;instance_type&#34;</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">   </span><span style="color:#7ee787">operator</span>:<span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;not_equals&#34;</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">   </span><span style="color:#7ee787">value</span>:<span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;p5.48xlarge&#34;</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"> </span>- <span style="color:#7ee787">cond_type</span>:<span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;attribute&#34;</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">   </span><span style="color:#7ee787">resource_types</span>:<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">   </span>- <span style="color:#a5d6ff">&#34;aws_instance&#34;</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">   </span><span style="color:#7ee787">attribute</span>:<span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;instance_type&#34;</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">   </span><span style="color:#7ee787">operator</span>:<span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;not_equals&#34;</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">   </span><span style="color:#7ee787">value</span>:<span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;p4d.24xlarge&#34;</span><span style="color:#6e7681">
</span></span></span></code></pre></div><p>With the ability to tailor policies to our specific needs, we&rsquo;ll next explore each tool&rsquo;s capacity to integrate broadly, determining how well they play with the rest of our tech stack.</p>
<h2 id="integration-capabilities">Integration Capabilities</h2>
<p>Integration capabilities are the cornerstone of efficient DevOps practices.</p>
<p>This section will evaluate how each static code analyzer enhances your tech stack through seamless integration with other systems and technologies.</p>
<p>We will assess each tool against four key integration points that are vital for development workflows:</p>
<ul>
<li><strong>Docker Image</strong>: Ensures easy deployment across any container-supported environment.</li>
<li><strong>IDE Plugins</strong>: Facilitates real-time feedback and improves code quality directly within the developer&rsquo;s workspace.</li>
<li><strong>CI/CD Systems</strong>: Supports direct integration through plugins or extensions, eliminating the need for manual downloads or CLI setups.</li>
<li><strong>Pre-commit Hook</strong>: Provides an early security checkpoint by scanning code before it is committed, catching errors at the initial stages.</li>
</ul>
<table>
  <thead>
      <tr>
          <th>Tool</th>
          <th>Docker Image</th>
          <th>IDE Plugins</th>
          <th>CI/CD Systems</th>
          <th>Hook</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>KICS</strong></td>
          <td>✅</td>
          <td>VSCode</td>
          <td>Github Actions, GitLab, Terraform Cloud, Codefresh</td>
          <td>✅</td>
      </tr>
      <tr>
          <td><strong>tfsec</strong></td>
          <td>✅</td>
          <td>VSCode, JetBrains, Vim</td>
          <td>Github Actions</td>
          <td>❌</td>
      </tr>
      <tr>
          <td><strong>Trivy</strong></td>
          <td>✅</td>
          <td>VSCode, JetBrains, Vim</td>
          <td>Azure DevOps, GitHub Actions, Buildkite, Dagger, Semaphore, CircleCI, Concourse CI</td>
          <td>❌</td>
      </tr>
      <tr>
          <td><strong>Terrascan</strong></td>
          <td>✅</td>
          <td>VSCode</td>
          <td>GitHub Actions, Atlantis</td>
          <td>✅</td>
      </tr>
      <tr>
          <td><strong>Checkov</strong></td>
          <td>✅</td>
          <td>VSCode, JetBrains</td>
          <td>GitHub Actions, GitLab</td>
          <td>✅</td>
      </tr>
      <tr>
          <td><strong>Semgrep OSS</strong></td>
          <td>✅</td>
          <td>VSCode, JetBrains, Emacs, Vim</td>
          <td>GitLab</td>
          <td>✅</td>
      </tr>
  </tbody>
</table>
<p>In addition to the table above, here are a few noteworthy features of some tools:</p>
<ul>
<li>Checkov supports OpenAI integration to suggest remediations. But be careful because AI tends to hallucinate.</li>
<li>KICS supports applying auto-remediation for some of its out-of-the-box policies. This also applies to custom policies, where you can define remediations and apply them automatically.</li>
<li>Terrascan is the only one that provides the VSCode extension to create and test custom policies written in Rego.</li>
<li>GitLab uses KICS as its default built-in IaC scanner — available out of the box with &ldquo;<a href="https://docs.gitlab.com/ee/user/application_security/iac_scanning/">Infrastructure as Code scanning</a>&rdquo;. However, there&rsquo;s also <a href="https://gitlab.com/guided-explorations/ci-cd-plugin-extensions/checkov-iac-sast">GitLab CI Component</a> available for Checkov.</li>
</ul>
<p>Having covered the integration capabilities, let’s now focus on the output formats each tool provides.</p>
<h2 id="output-formats-provided">Output Formats Provided</h2>
<p>Output formats extend the utility of static code analysis, facilitating integration with the CI/CD feedback loop and enabling its use as an artifact in subsequent CI jobs.</p>
<p>This chapter examines the variety of formats each tool supports for this purpose.</p>
<p>Each tool offers a range of output formats tailored to different needs.</p>
<p><strong>For GitLab users</strong>: For teams leveraging GitLab&rsquo;s security scanning, KICS, Checkov, and Semgrep OSS are equipped with compatible output formats, facilitating smooth GitLab integration.</p>
<p><strong>For GitHub users</strong>: SARIF&rsquo;s adoption as an industry standard, particularly by GitHub for code scanning, makes it a must-have. All tools assessed offer SARIF support, ensuring interoperability and broad utility.</p>
<p><strong>JUnit Reports</strong>: The availability of JUnit output is crucial for capturing test results in a format recognizable by various CI systems. Trivy, Terrascan, Checkov, and Semgrep OSS support this, enabling clear visualization of test outcomes and enhancing the feedback loop within CI pipelines.</p>
<p>Beyond these, each tool supports additional formats, enriching their application and versatility. Here&rsquo;s the full breakdown of the output formats, complementing the standard CLI output:</p>
<table>
  <thead>
      <tr>
          <th>Tool</th>
          <th>Supported Output Formats</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>KICS</strong></td>
          <td>ASFF, CSV, Code Climate, CycloneDX, GItLab SAST, HTML, JSON, JUnit, PDF, SARIF, SonarQube</td>
      </tr>
      <tr>
          <td><strong>tfsec</strong></td>
          <td>Checkstyle, CSV, HTML, JSON, JUnit, Markdown, SARIF</td>
      </tr>
      <tr>
          <td><strong>Trivy</strong></td>
          <td>ASFF, Cosign, CycloneDX, JSON, SARIF, SPDX</td>
      </tr>
      <tr>
          <td><strong>Terrascan</strong></td>
          <td>JSON, JUnit, SARIF, XML, YAML</td>
      </tr>
      <tr>
          <td><strong>Checkov</strong></td>
          <td>CSV, CycloneDX, GItLab SAST, JSON, JUnit, SARIF, SPDX</td>
      </tr>
      <tr>
          <td><strong>Semgrep OSS</strong></td>
          <td>Emacs, GitLab SAST, JSON, JUnit, SARIF, Vim</td>
      </tr>
  </tbody>
</table>
<p>Moving from output formats to operational adaptability, let&rsquo;s investigate the customization options for scanner settings. This important feature allows each tool to align with varied project demands.</p>
<h2 id="customizing-scanner-settings">Customizing Scanner Settings</h2>
<p>This chapter moves beyond the default scanner settings and delves into scanner settings&rsquo; customizability, ensuring that tools can be calibrated for any development environment or security requirement.</p>
<p>I will evaluate each tool against criteria that define a tool&rsquo;s adaptability and user-friendliness:</p>
<ul>
<li><strong>Targeted Scans</strong>: Select specific directories for scanning or exclusion to focus on pertinent areas and skip irrelevant ones.</li>
<li><strong>In-Code Ignore Policies</strong>: Enable ignore directives within code to skip checks when exceptions apply selectively.</li>
<li><strong>Severity Thresholds</strong>: Set reporting to include only findings above a chosen severity level, concentrating on the most impactful issues.</li>
<li><strong>Configuration File</strong>: Employ configuration files for consistency and collaboration, enabling a &lsquo;configuration as code&rsquo; approach.</li>
<li><strong>TF Variables Interpolation</strong>: Interpret and evaluate Terraform variables for an accurate security assessment of IaC.</li>
<li><strong>Module Scanning</strong>: For complete coverage, scans should include both local and remote (public/private) Terraform modules.</li>
</ul>
<p>Based on these criteria, the following table offers a comparative view of how each tool performs, giving you a clear snapshot of their customization capabilities:</p>
<table>
  <thead>
      <tr>
          <th>Tool</th>
          <th>Targeted Scans</th>
          <th>Ignore Policies</th>
          <th>Min Severity</th>
          <th>Config File</th>
          <th>Variables Interpolation</th>
          <th>Module Scanning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>KICS</strong></td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>⁉️️</td>
      </tr>
      <tr>
          <td><strong>tfsec</strong></td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
      </tr>
      <tr>
          <td><strong>Trivy</strong></td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
      </tr>
      <tr>
          <td><strong>Terrascan</strong></td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
      </tr>
      <tr>
          <td><strong>Checkov</strong></td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
      </tr>
      <tr>
          <td><strong>Semgrep OSS</strong></td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
          <td>❌</td>
          <td>✅</td>
          <td>❌</td>
      </tr>
  </tbody>
</table>
<p>Most reviewed tools meet nearly all the criteria set for scanner setting customization, demonstrating their flexibility and advanced capabilities. However, there are notable features worth considering:</p>
<ul>
<li>KICS: Provides limited module scanning capabilities, restricted to some public modules from the Terraform registry, and does not cover local or private custom modules.</li>
<li>Terrascan &amp; Trivy: Both feature server modes that centralize vulnerability databases. This centralization facilitates a unified approach to applying policies and configurations, enhancing consistency and efficiency for teams and reducing the management overhead of diverse policies across multiple projects.</li>
<li>Semgrep: It doesn&rsquo;t support scanner configuration files; instead, it uses the &ldquo;config&rdquo; word to call the rule sets and accepts such configs. Notably, it also does not support the scanning of Terraform modules at all.</li>
</ul>
<h2 id="terraform-security-scanning-the-big-picture-and-top-pick">Terraform Security Scanning: The Big Picture and Top Pick</h2>
<p>Here&rsquo;s a comprehensive comparison summary to guide your selection of the most suitable Terraform static code analyzer:</p>
<table>
  <thead>
      <tr>
          <th>Tool</th>
          <th>Default Policies</th>
          <th>Custom Policies</th>
          <th>Integration</th>
          <th>Output Formats</th>
          <th>Customization</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>KICS</strong></td>
          <td>663</td>
          <td>OPA Rego</td>
          <td>✅Docker, ✅IDE, ✅CI/CD, ✅Git Hook</td>
          <td>ASFF, CSV, Code Climate, CycloneDX, GItLab SAST, HTML, JSON, JUnit, PDF, SARIF, SonarQube</td>
          <td>✅Targeted Scans, ✅Ignore Policies, ✅Min Severity, ✅Config File, ✅Variables Interpolation, ❌Module Scanning</td>
      </tr>
      <tr>
          <td><strong>tfsec</strong></td>
          <td>154</td>
          <td>OPA Rego</td>
          <td>✅Docker, ✅IDE, ✅CI/CD, ❌Git Hook</td>
          <td>Checkstyle, CSV, HTML, JSON, JUnit, Markdown, SARIF</td>
          <td>✅Targeted Scans, ✅Ignore Policies, ✅Min Severity, ✅Config File, ✅Variables Interpolation, ✅Module Scanning</td>
      </tr>
      <tr>
          <td><strong>Trivy</strong></td>
          <td>322</td>
          <td>OPA Rego</td>
          <td>✅Docker, ✅IDE, ✅CI/CD, ❌Git Hook</td>
          <td>ASFF, Cosign, CycloneDX, JSON, SARIF, SPDX</td>
          <td>✅Targeted Scans, ✅Ignore Policies, ✅Min Severity, ✅Config File, ✅Variables Interpolation, ✅Module Scanning</td>
      </tr>
      <tr>
          <td><strong>Terrascan</strong></td>
          <td>790</td>
          <td>OPA Rego</td>
          <td>✅Docker, ✅IDE, ✅CI/CD, ✅Git Hook</td>
          <td>JSON, JUnit, SARIF, XML, YAML</td>
          <td>✅Targeted Scans, ✅Ignore Policies, ✅Min Severity, ✅Config File, ✅Variables Interpolation, ✅Module Scanning</td>
      </tr>
      <tr>
          <td><strong>Checkov</strong></td>
          <td>2110</td>
          <td>YAML, Python</td>
          <td>✅Docker, ✅IDE, ✅CI/CD, ✅Git Hook</td>
          <td>CSV, CycloneDX, GItLab SAST, JSON, JUnit, SARIF, SPDX</td>
          <td>✅Targeted Scans, ✅Ignore Policies, ✅Min Severity, ✅Config File, ✅Variables Interpolation, ✅Module Scanning</td>
      </tr>
      <tr>
          <td><strong>Semgrep OSS</strong></td>
          <td>362</td>
          <td>YAML</td>
          <td>✅Docker, ✅IDE, ✅CI/CD, ✅Git Hook</td>
          <td>Emacs, GitLab SAST, JSON, JUnit, SARIF, Vim</td>
          <td>✅Targeted Scans, ✅Ignore Policies, ✅Min Severity, ❌Config File, ✅Variables Interpolation, ❌Module Scanning</td>
      </tr>
  </tbody>
</table>
<p>Integrating a Terraform security scanning into your development pipeline is a proven strategy to boost your security posture. These tools detect potential vulnerabilities early and enforce best practices and compliance standards, representing a proactive approach to infrastructure security.</p>
<p>For teams not yet utilizing these tools, <strong>Checkov</strong> is my top recommendation:</p>
<ul>
<li>Biggest number of default policies and supported Terraform providers for a quick start.</li>
<li>Custom policy support in YAML and Python for flexible policy creation.</li>
<li>Wide integration options with Docker, IDEs, CI/CD systems, and Git Hooks for a smooth workflow.</li>
</ul>
<p>Please share your favorite tool in the comments below! Also, let me know if I missed a cool product that should have been included in the review.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Hello Terraform Data; Goodbye Null Resource</title>
      <link>https://devdosvid.blog/2023/04/16/hello-terraform-data-goodbye-null-resource/</link>
      <pubDate>Sun, 16 Apr 2023 01:25:18 +0200</pubDate>
      <guid>https://devdosvid.blog/2023/04/16/hello-terraform-data-goodbye-null-resource/</guid>
      <description>Native built-in replacement for null_resource with Terraform 1.4</description>
      <content:encoded><![CDATA[<p>Terraform version 1.4 was recently released and brought a range of new features, including improved run output in Terraform Cloud, the ability to use OPA policy results in the CLI, and a built-in alternative to the null resource — terraform_data.</p>
<p>In this blog post, I want to demonstrate and explain the <strong>terraform_data</strong> resource that serves two purposes:</p>
<ul>
<li>firstly, it allows arbitrary values to be stored and used afterward to implement lifecycle triggers of other resources</li>
<li>secondly, it can be used to trigger provisioners when there isn&rsquo;t a more appropriate managed resource available.</li>
</ul>
<div class="substack-embedded-container">
    <h3>Subscribe to blog updates!</h3>
    <iframe title="Substack" class="substack-embedded-iframe" src="https://devdosvid.substack.com/embed" height="250"
            loading="lazy"></iframe>
</div>
<p>For those of you, who are familiar with the null provider, the <code>terraform_data</code> resource might look very similar. And you&rsquo;re right!<br>
Rather than being a separate provider, the terraform_data managed resource now offers the same capabilities as an integrated feature. Pretty cool! <br>
While the null provider is still available and there are no statements about its deprecation thus far (<a href="https://registry.terraform.io/providers/hashicorp/null/3.2.1/docs">as of April 2023, v3.2.1</a>), the  <code>terraform_data</code> is the native replacement of the <code>null_resource</code>, and the latter might soon become deprecated.</p>
<p>The  <code>terraform_data</code> resource has two optional arguments, <strong>input</strong> and <strong>triggers_replace</strong>, and its configuration looks as follows:</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2023/04/16/hello-terraform-data-goodbye-null-resource/code-snippet-1_hu_806b63ec76a5080d.webp"
                 alt="terraform data resource arguments"width="800"height="182.16" />
        
    
    <figcaption>
        <p>terraform data resource arguments
            </p>
    </figcaption>
</figure>

<ul>
<li>The <code>input</code> (optional) stores the value that is passed to the resource</li>
<li>The <code>triggers_replace</code> (optional) is a value that triggers resource replacement when changes.</li>
</ul>
<p>There are two attributes, in addition to the arguments, which are stored in the state: <strong>id</strong> and <strong>output</strong> after the resource is created. Let&rsquo;s take a look:</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2023/04/16/hello-terraform-data-goodbye-null-resource/code-snippet-2_hu_1efde4882f03327c.webp"
                 alt="terraform data resource attributes"width="800"height="271.36" />
        
    
    <figcaption>
        <p>terraform data resource attributes
            </p>
    </figcaption>
</figure>

<ul>
<li>The  <code>output</code> attribute is computed based on the value of the <code>input</code></li>
<li>The <code>id</code> is just a unique value of the resource instance in the state (as for any other resource).</li>
</ul>
<h2 id="use-case-for-terraform_data-with-replace_triggered_by">Use case for terraform_data with replace_triggered_by</h2>
<p>Let&rsquo;s take a look at the first use case for the terraform_data resource. It is the ability to trigger resource replacement based on the value of the input argument.</p>
<p>A bit of context here: the <strong>replace_triggered_by</strong> argument of the resource lifecycle meta-argument allows you to trigger resource replacement based on another referenced resource or its attribute.</p>
<div class="attention">
    If you are not yet familiar with the <code>replace_triggered_by</code>, you can check <a href="/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/#trigger-resource-replacement-with-replace_triggered_by">another blog post that explains it</a>.
</div>
<p>The replace_triggered_by is a powerful feature, but here is the thing about it: only a resource or its attribute must be specified, and <strong>you cannot use a variable or a local value for replace_triggered_by</strong>.</p>
<p>But with terraform_data, you can indirectly initiate another resource replacement by using either a variable or an expression within a local value for the <code>input</code> argument.</p>
<p>Let me give you an example here. Consider the following code:</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2023/04/16/hello-terraform-data-goodbye-null-resource/code-snippet-3_hu_dd3f94068f7e92dd.webp"
                 alt="trigger replacement based on input variable"width="800"height="386.00" />
        
    
    <figcaption>
        <p>trigger replacement based on input variable
            </p>
    </figcaption>
</figure>

<p>By modifying the  <code>revision</code> variable, the next Terraform plan will suggest a replacement action against aws_instance.webserver:</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2023/04/16/hello-terraform-data-goodbye-null-resource/code-snippet-4_hu_42432796ae5d8ebe.webp"
                 alt="terraform_data with replace_triggered_by"width="800"height="341.59" />
        
    
    <figcaption>
        <p>terraform_data with replace_triggered_by
            </p>
    </figcaption>
</figure>

<h2 id="use-case-for-terraform_data-with-provisioner">Use case for terraform_data with provisioner</h2>
<p>Before we start: HashiCorp suggests (and I also support that) avoiding provisioner usage unless you have no other options left. One of the reasons — additional, implicit, and unobvious dependency that appears in the codebase — the binary, which is called inside the provisioner block, must be present on the machine. <br>
But let&rsquo;s be real, the provisioner feature is still kicking, and there&rsquo;s always that one unique project that needs it.</p>
<p>Here is the code snippet that demonstrates the usage of the provisioner within the terraform_data resource:</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2023/04/16/hello-terraform-data-goodbye-null-resource/code-snippet-5_hu_6590af059b34b4c5.webp"
                 alt="terraform_data with provisioner"width="800"height="409.00" />
        
    
    <figcaption>
        <p>terraform_data with provisioner
            </p>
    </figcaption>
</figure>

<p>In this example, the following happens:</p>
<ul>
<li>When resources are created the first time, the provisioner inside <code>terraform_data</code> runs</li>
<li>Sequential plan/apply will trigger another execution of the provisioner only when the private IP of the instance (aws_instance.webserver.private_ip) changes because that will trigger <code>terraform_data</code> recreation. At the same time, no changes to the internal IP mean no provisioner execution.</li>
</ul>
<hr>
<p>With its ability to store and use values for lifecycle triggers and provisioners, <strong>terraform_data</strong> is a powerful tool that can enhance your Terraform configuration.</p>
<p>Although the null provider still has its place in the Terraform ecosystem, terraform_data is its evolution, and its integration as a feature is certainly something to be excited about.</p>
<p>Why not give it a try in your next project and see how it can simplify your infrastructure as code workflows? Keep on coding! 🙌</p>
]]></content:encoded>
    </item>
    <item>
      <title>New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2</title>
      <link>https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/</link>
      <pubDate>Wed, 04 May 2022 22:27:47 +0200</pubDate>
      <guid>https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/</guid>
      <description>Terraform code refactoring and resource lifecycle conditions, and triggers — now natively available</description>
      <content:encoded><![CDATA[<p>In this blog, I would like to tell you about new cool features that Terraform 1.1 and 1.2 bring. It feels like Terraform has doubled its speed of delivering the new features after they released the 1.0. 🤩</p>
<p>It&rsquo;s been only a few months since Terraform 1.1 was released with the <code>moved</code> block that empowers the code refactoring.</p>
<p>Now Terraform 1.2 is almost <a href="*https://github.com/hashicorp/terraform/releases/tag/v1.2.0-rc1*">ready</a> (as I am writing this blog in early May 2022) to bring three new efficient controls to the resource lifecycle.<br>
These are three new expressions: <code>precondition</code>, <code>postcondition</code>, and <code>replace_triggered_by</code>.</p>
<div class="substack-embedded-container">
    <h3>Subscribe to blog updates!</h3>
    <iframe title="Substack" class="substack-embedded-iframe" src="https://devdosvid.substack.com/embed" height="250"
            loading="lazy"></iframe>
</div>
<h2 id="terraform-code-refactoring-with-the-moved-block">Terraform Code Refactoring With the Moved Block</h2>
<p>Starting from the 1.1 version, Terraform users can use the <code>moved</code> block to describe the changes in resource or module addresses (or resources inside a module) in the form of code. <br>
Once that is described, Terraform performs the movement of the resource within the state during the first apply.</p>
<p>In other words, what this feature gives you, is the ability to document your <code>terraform state mv</code> actions, so you and other project or module users don&rsquo;t need to perform them manually.</p>
<p>As your code evolves, a resource or module can have several <code>moved</code> blocks associated with it, and Terraform will thoroughly reproduce the whole history of its movement within a state (i.e., renaming).</p>
<p>Let&rsquo;s review some examples that illustrate how it works.</p>
<h3 id="move-or-rename-a-resource">Move or rename a resource</h3>
<p>In a module, I have a bucket policy that has a generic, meaningless name. It is used in a module that creates a CloudFront distribution with an S3 bucket.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/figure-1_hu_4aa1960a5552dd5c.webp"
                 alt="An example resource"width="800"height="150" />
        
    
    <figcaption>
        <p>An example resource
            </p>
    </figcaption>
</figure>

<p>It&rsquo;s pretty OK to name a resource like that if you have only a single instance of that kind in your code.</p>
<p>Later, when I need to add another policy to the module, I don&rsquo;t want to name it &ldquo;that&rdquo;. Instead, I want my policies to have meaningful names now.<br>
For example, I could rename the old policy with the <code>terraform state mv</code> command, but other users of my module would not know about that.</p>
<p>That is where the <code>moved</code> block turns out to be helpful!</p>
<div class="attention">
    The <code>moved</code> block allows you to document how you rename or move an object in Terraform so that other code users can have the same changes afterward.
</div>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/figure-2_hu_eb13c021cec2d80e.webp"
                 alt="Resource address update with the Moved block"width="800"height="270" />
        
    
    <figcaption>
        <p>Resource address update with the Moved block
            </p>
    </figcaption>
</figure>

<p>Terraform follows the instructions inside the <code>module</code> block to plan and apply changes. Although the resource address update is not counted as a change in the Plan output, Terraform will perform that update during apply.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/figure-3_hu_53497fff0a5193d7.webp"
                 alt="Terraform plan output"width="800"height="318" />
        
    
    <figcaption>
        <p>Terraform plan output
            </p>
    </figcaption>
</figure>

<h3 id="move-or-rename-a-module">Move or rename a module</h3>
<p>The same approach can be applied to a module — you can move or rename it as a code too.</p>
<p>Here, I use two modules to create static hosting for a website with a custom TLS certificate.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/figure-4_hu_713b305a5f3ee68f.webp"
                 alt="Two modules with generic names"width="800"height="437" />
        
    
    <figcaption>
        <p>Two modules with generic names
            </p>
    </figcaption>
</figure>

<p>Again, if I need to add another couple of the CDN+Certificate modules, I would like to have meaningful names in my code so clearly distinguish one from another.</p>
<p>Therefore, I would add two <code>moved</code> blocks — one per module call.</p>
<p>And by the way, since I renamed the module (from <code>cert</code> to <code>example_com_cert</code>), I need to update all references to that module&rsquo;s outputs in the code too.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/figure-5_hu_f3c218ea084353c8.webp"
                 alt="Two modules renamed"width="800"height="629" />
        
    
    <figcaption>
        <p>Two modules renamed
            </p>
    </figcaption>
</figure>

<p>However, there is one nuance: when you rename a module and declare that in the <code>moved</code> block, you need to run the <code>terraform init</code> before applying the change because Terraform must initialize the module with the new name first.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/figure-6_hu_179dc9d8bd340e9b.webp"
                 alt="Terraform error: module not installed"width="800"height="246" />
        
    
    <figcaption>
        <p>Terraform error: module not installed
            </p>
    </figcaption>
</figure>

<p>There are some more advanced actions you can make with the <code>moved</code> block:</p>
<ul>
<li>Implement count and for_each meta-arguments to resources and modules</li>
<li>Break one module into multiple
Check the following detailed guide from HashiCorp that explains how to do that — <a href="https://www.terraform.io/language/modules/develop/refactoring">Refactoring</a></li>
</ul>
<p>Introducing the <code>moved</code> blocks into your codebase defacto starts the refactoring process for your module users. But the finale of that refactoring happens when you ultimately remove these blocks.</p>
<p>Therefore, here is some advice on how to manage that:</p>
<div class="attention">
    <ul>
<li>
<p>Keep the <code>moved</code> blocks in your code for long. For example, when removing a <code>moved</code> block from the code, Terraform does not treat the new object name as a renaming anymore. Instead, Terraform will plan to delete the resource or module with the old name instead of renaming it.</p>
</li>
<li>
<p>Keep the complete chains of object renaming (sequence of moves). The whole history of object movement ensures that users with different module versions will get a consistent and predictable behavior of the refactoring.</p>
</li>
</ul>

</div>
<h2 id="lifecycle-expressions-conditions-and-replacement-trigger">Lifecycle expressions: conditions and replacement trigger</h2>
<p>Terraform 1.2 fundamentally improves the <code>lifecycle</code> meta-argument by adding three new configuration options with rich capabilities.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/figure-7_hu_b3e66acb6aee8109.webp"
                 alt="New configuration options for the lifecycle meta-argument"width="800"height="365" />
        
    
    <figcaption>
        <p>New configuration options for the lifecycle meta-argument
            </p>
    </figcaption>
</figure>

<h3 id="precondition-and-postcondition">Precondition and Postcondition</h3>
<p>When you need to make sure that specific condition is met before or after you create a resource, you can use <code>postcondition</code> and <code>precondition</code> blocks.</p>
<p>The <em>condition</em> here — is some data or information about a resource you need to confirm to apply the code.</p>
<p>Here are a few examples of such conditions:</p>
<ul>
<li>Validate some attributes of the Data Source that you cannot check using filters or other available arguments;</li>
<li>Confirm the Resource argument that can compound several variables (e.g., list);</li>
</ul>
<div class="attention">
    <p><strong>Precondition</strong> works as an expectation or a guess about some external (but within a module) value that a resource depends on.</p>
<p><strong>Postcondition</strong> works as the assurance that a resource fulfills a specific condition so other resources may rely on that. If postcondition fails for a resource, this prevents changes to all other resources that depend on it.</p>

</div>
<p>Let&rsquo;s review this new feature with an example of <code>postcondition</code> usage.</p>
<p>Consider the following case: our module receives AMI ID as the input variable, and that AMI should be used in the Launch Template then; we also have the requirement for the EC2 instance created from that Launch Template — its root EBS size must be equal or bigger than 600 GB.</p>
<p>We cannot validate the EBS size using the variable that accepts the AMI ID. But we can write a <strong>postcondition</strong> for the Data Source that gets the information about the AMI and reference that Data Source in the Launch Template resource afterward.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/figure-8_hu_cbfcb6852bb42cf5.webp"
                 alt="Data Source Postcondition"width="800"height="446" />
        
    
    <figcaption>
        <p>Data Source Postcondition
            </p>
    </figcaption>
</figure>

<p>The <code>condition</code> argument within the block accepts any of Terraform&rsquo;s built-in functions or language operators.</p>
<p>The special <code>self</code> object is available only for the <code>postcondition</code> block because it assumes that validation can be performed after the object is created and its attributes are known.</p>
<p>Later, if a module user specifies the AMI with an EBS size lesser than 600 GB, Terraform will fail to create the Launch Template because it depends on the Data Source that did not pass the postcondition check.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/figure-9_hu_230cb5568eef55fa.webp"
                 alt="Resource postcondition error"width="800"height="240" />
        
    
    <figcaption>
        <p>Resource postcondition error
            </p>
    </figcaption>
</figure>

<p>Terraform tries to evaluate the condition expressions as soonest: sometimes Terraform can check the value during the planning phase, but sometimes that can be done only after the resource is created if the value is unknown.</p>
<h3 id="validate-module-output-with-precondition">Validate module output with precondition</h3>
<p>The <code>precondition</code> block is also available for the module outputs.</p>
<p>Just like the variable validation block assures that module input meets certain expectations, the <code>precondition</code> is intended to ensure that a module produces the valid output.</p>
<p>Here is an example: a module that creates an ACM certificate must prevent the usage of a specific domain name in the certificate&rsquo;s Common Name or its SANs.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/figure-10_hu_5fdb543d84bfe964.webp"
                 alt="Module output precondition"width="800"height="342" />
        
    
    <figcaption>
        <p>Module output precondition
            </p>
    </figcaption>
</figure>

<p>In this case, instead of validating several input variables, we can write the validation only once for the output.</p>
<div class="attention">
    Validation of the module output helps with standardization and control of the data passed between Terraform modules.
</div>
<h3 id="trigger-resource-replacement-with-replace_triggered_by">Trigger resource replacement with replace_triggered_by</h3>
<p>Sometimes it&rsquo;s needed to specify the dependency in the way that recreates a resource when another resource or its attribute changes.</p>
<p>This is useful when two (or more) resources do not have any explicit dependency.</p>
<p>Consider the following case: you have two EC2 instances, A and B, and need to recreate the B instance if the private IP of instance A is changed.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/figure-11_hu_a4a183f76653d174.webp"
                 alt="replace_triggered_by example"width="800"height="342" />
        
    
    <figcaption>
        <p>replace_triggered_by example
            </p>
    </figcaption>
</figure>

<p>This is extremely useful when you&rsquo;re dealing with logical abstractions over the set of resources.</p>
<div class="attention">
    <p>Resource replacement is triggered when:</p>
<ul>
<li>any of the resources referenced in <code>replace_triggered_by</code> are updated</li>
<li>any value is set to the resource attribute that is referenced in <code>replace_triggered_by</code></li>
</ul>
</div>
<h2 id="getting-started-with-terraform-11-and-12">Getting started with Terraform 1.1 and 1.2</h2>
<p>If you&rsquo;re still using older Terraform versions, these new features might be a good motivation for you to upgrade!</p>
<p>Before upgrading, be sure to read the upgrade notes for the specific version at the <a href="https://github.com/hashicorp/terraform/releases">releases page</a>.</p>
<p>Also, an excellent tool can help with fast switching between different Terraform versions while you&rsquo;re experimenting — <a href="https://tfswitch.warrensbox.com/">tfswitch</a>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Some Techniques to Enhance Your Terraform Proficiency</title>
      <link>https://devdosvid.blog/2022/01/16/some-techniques-to-enhance-your-terraform-proficiency/</link>
      <pubDate>Sun, 16 Jan 2022 01:59:51 +0200</pubDate>
      <guid>https://devdosvid.blog/2022/01/16/some-techniques-to-enhance-your-terraform-proficiency/</guid>
      <description>Learn what cool things Terraform can do with its built-in functionality</description>
      <content:encoded><![CDATA[<p>Terraform built-in functionality is very feature-rich: functions, expressions,  and meta-arguments provide many ways to shape the code and fit it to a particular use case. I want to share a few valuable practices to boost your Terraform expertise in this blog.</p>
<div class="attention">
    Some code examples in this article will work with Terraform version 0.15 and onwards. But if you&rsquo;re still using 0.14 or lower, here&rsquo;s another motivation for you to upgrade.
</div>
<h2 id="conditional-resource-creation-or-how-to-implement-the-if-else-statement-in-terraform">Conditional resource creation or how to implement the &ldquo;if else&rdquo; statement in Terraform</h2>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/01/16/some-techniques-to-enhance-your-terraform-proficiency/condiitonal-resource-creation_hu_40881a6a31d15011.webp"width="400"height="400.00" />
        
    
</figure>

<p>With Terraform, you can have a conditional module or a resource creation by implementing the ternary operator — so-called Conditional Expressions.</p>
<p>Let&rsquo;s start from the most popular one: whether to create a resource depending on some fact, e.g., the value of a variable.</p>
<p>Terraform meta-argument <code>count</code> helps to describe that kind of resource creation logic.</p>
<p>Here is how it may look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#ff7b72">data</span> <span style="color:#a5d6ff">&#34;aws_ssm_parameter&#34;</span> <span style="color:#a5d6ff">&#34;ami_id&#34;</span> {
</span></span><span style="display:flex;"><span>  count    = var.ami_channel =<span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;&#34;</span> <span style="color:#ff7b72;font-weight:bold">?</span> <span style="color:#a5d6ff">0</span> <span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  name     = local.ami_channels[var.ami_channel]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The notation <code>var.ami_channel == &quot;&quot; ? 0 : 1</code> is called <em>conditional expression</em> and means the following: if my variable is empty (<code>var.ami_channel == &quot;&quot;</code> — hence, true) then set the count to 0, otherwise set to 1.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>condition ? true_val : false_val
</span></span></code></pre></div><p>In this illustration, I want to get the AMI ID from the SSM Parameter only if the AMI channel (e.g., beta or alpha) is specified. Otherwise, providing that the <code>ami_channel</code> variable is an empty string by default (&quot;&quot;), the data source should not be created.</p>
<p>When following this method, keep in mind that the resource address will contain the index identifier. So when I need to use the value of the SSM parameter from our example, I need to reference it the following way:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span>ami_id = data.aws_ssm_parameter.ami_id[<span style="color:#a5d6ff">0</span>].value
</span></span></code></pre></div><p>The <code>count</code> meta-argument can also be used when you need to conditionally create a Terraform module.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#ff7b72">module</span> <span style="color:#a5d6ff">&#34;bucket&#34;</span> {
</span></span><span style="display:flex;"><span>  count             = var.create_bucket =<span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#79c0ff">true</span> <span style="color:#ff7b72;font-weight:bold">?</span> <span style="color:#a5d6ff">1</span> <span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex;"><span>  source            = <span style="color:#a5d6ff">&#34;./modules/s3_bucket&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  name              = <span style="color:#a5d6ff">&#34;my-unique-bucket&#34;</span>
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>var.create_bucket == true ? 1 : 0</code>  expression can be written even shorter: <code>var.create_bucket ? 1 : 0</code>  because the <code>create_bucket</code> variable has boolean type, apparently.</p>
<p>But what if you need to produce more than one instance of a resource or module? And still be able to avoid their creation.</p>
<p>Another meta-argument — <code>for_each</code> — will do the trick.</p>
<p>For example, this is how the <code>for_each</code> argument works for the conditional module creation:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#ff7b72">module</span> <span style="color:#a5d6ff">&#34;bucket&#34;</span> {
</span></span><span style="display:flex;"><span>  for_each          = var.bucket_names =<span style="color:#ff7b72;font-weight:bold">=</span> [] <span style="color:#ff7b72;font-weight:bold">?</span> [] <span style="color:#ff7b72;font-weight:bold">:</span> var.bucket_names
</span></span><span style="display:flex;"><span>  source            = <span style="color:#a5d6ff">&#34;./modules/s3_bucket&#34;</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  name              = <span style="color:#a5d6ff">&#34;</span><span style="color:#a5d6ff">${</span>each.key<span style="color:#a5d6ff">}</span><span style="color:#a5d6ff">&#34;</span>
</span></span><span style="display:flex;"><span>  enable_encryption = <span style="color:#79c0ff">true</span>
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this illustration, I also used a conditional expression that makes Terraform iterate through the set of values of <code>var.bucket_names</code> if it&rsquo;s not empty and create several modules. Otherwise, do not iterate at all and do not create anything.</p>
<p>The same can be done for the resources. For example, when you need to create an arbitrary number of security group rules, e.g., to allowlist some IPs for your bastion host:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#ff7b72">resource</span> <span style="color:#a5d6ff">&#34;aws_security_group_rule&#34;</span> <span style="color:#a5d6ff">&#34;allowlist&#34;</span> {
</span></span><span style="display:flex;"><span>  for_each           = var.cidr_blocks =<span style="color:#ff7b72;font-weight:bold">=</span> [] <span style="color:#ff7b72;font-weight:bold">?</span> [] <span style="color:#ff7b72;font-weight:bold">:</span> var.cidr_blocks
</span></span><span style="display:flex;"><span>  type               = <span style="color:#a5d6ff">&#34;ingress&#34;</span>
</span></span><span style="display:flex;"><span>  from_port          = <span style="color:#a5d6ff">22</span>
</span></span><span style="display:flex;"><span>  to_port            = <span style="color:#a5d6ff">22</span>
</span></span><span style="display:flex;"><span>  protocol           = <span style="color:#a5d6ff">&#34;tcp&#34;</span>
</span></span><span style="display:flex;"><span>  cidr_blocks        = [each.value]
</span></span><span style="display:flex;"><span>  security_group_id  = aws_security_group.bastion.id
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And just like with the <code>count</code> meta-argument, with the <code>for_each</code>, resource addresses will have the identifier named by the values provided to <code>for_each</code>.</p>
<p>For example, here is how I would reference a resource created in the module with <code>for_each</code> described earlier:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span>bucket_name = module.bucket[<span style="color:#a5d6ff">&#34;photos&#34;</span>].name
</span></span></code></pre></div><div class="substack-embedded-container">
    <h3>Subscribe to blog updates!</h3>
    <iframe title="Substack" class="substack-embedded-iframe" src="https://devdosvid.substack.com/embed" height="250"
            loading="lazy"></iframe>
</div>
<h2 id="conditional-resource-arguments-attributes-setting">Conditional resource arguments (attributes) setting</h2>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/01/16/some-techniques-to-enhance-your-terraform-proficiency/conditional-resource-argument_hu_800103069fc576.webp"width="400"height="400.00" />
        
    
</figure>

<p>Now let&rsquo;s go deeper and see how resource arguments can be conditionally set (or not).</p>
<p>First, let&rsquo;s review the conditional argument value setting with the <code>null</code> data type:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#ff7b72">resource</span> <span style="color:#a5d6ff">&#34;aws_launch_template&#34;</span> <span style="color:#a5d6ff">&#34;this&#34;</span> {
</span></span><span style="display:flex;"><span>  name     = <span style="color:#a5d6ff">&#34;my-launch-template&#34;</span>
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  key_name = var.use_default_keypair <span style="color:#ff7b72;font-weight:bold">?</span> var.keypair_name <span style="color:#ff7b72;font-weight:bold">:</span> null
</span></span><span style="display:flex;"><span>  ...
</span></span></code></pre></div><p>Here I want to skip the usage of the EC2 Key Pair for the Launch Template in some instances and Terraform allows me to write the conditional expression that will set the <code>null</code> value for the argument. It means the <em>absence</em> or <em>omission</em> and Terraform would behave the same as if you did not specify the argument at all.</p>
<p>Dynamic blocks are another case where conditional creation suits best. Take a look at the following piece of CloudFront resource code where I want to either describe the configuration for the custom error response or omit that completely:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#ff7b72">resource</span> <span style="color:#a5d6ff">&#34;aws_cloudfront_distribution&#34;</span> <span style="color:#a5d6ff">&#34;cdn&#34;</span> {
</span></span><span style="display:flex;"><span>  enabled = <span style="color:#79c0ff">true</span>
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  dynamic <span style="color:#a5d6ff">&#34;custom_error_response&#34;</span> {
</span></span><span style="display:flex;"><span>    for_each = var.custom_error_response =<span style="color:#ff7b72;font-weight:bold">=</span> null <span style="color:#ff7b72;font-weight:bold">?</span> [] <span style="color:#ff7b72;font-weight:bold">:</span> [var.custom_error_response]
</span></span><span style="display:flex;"><span>    iterator = cer
</span></span><span style="display:flex;"><span>    content {
</span></span><span style="display:flex;"><span>      error_code            = lookup(cer.value, <span style="color:#a5d6ff">&#34;error_code&#34;</span>, null)
</span></span><span style="display:flex;"><span>      error_caching_min_ttl = lookup(cer.value, <span style="color:#a5d6ff">&#34;error_caching_min_ttl&#34;</span>, null)
</span></span><span style="display:flex;"><span>      response_code         = lookup(cer.value, <span style="color:#a5d6ff">&#34;response_code&#34;</span>, null)
</span></span><span style="display:flex;"><span>      response_page_path    = lookup(cer.value, <span style="color:#a5d6ff">&#34;response_page_path&#34;</span>, null)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>custom_error_response</code> variable is <code>null</code> by default, but it has the <code>object</code> type, and users can assign the variable with the required nested specifications if needed. And when they do it, Terraform will add the <code>custom_error_response</code> block to the resource configuration. Otherwise, it will be omitted entirely.</p>
<h2 id="convert-types-in-terraform-with-ease">Convert types in Terraform with ease</h2>
<p><figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/01/16/some-techniques-to-enhance-your-terraform-proficiency/types-converstion_hu_e3e70aec17c92843.webp"width="400"height="400.00" />
        
    
</figure>

Ok, let&rsquo;s move to the less conditional things now 😅</p>
<p>Terraform has several type conversion functions: <code>tobool()</code>, <code>tolist()</code>,<code>tomap()</code>, <code>tonumber()</code>, <code>toset()</code>, and <code>tostring()</code>. Their purpose is to convert the input values to the compatible types.</p>
<p>For example, suppose I need to pass the set to the <code>for_each</code> (it accepts only sets and maps types of value), but I got the list as an input; let&rsquo;s say I got it as an output from another module. In such a case, I would do something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span>for_each = toset(var.remote_access_ports)
</span></span></code></pre></div><p>However, I can make my code cleaner and avoid the explicit conversion — I just need to define the value type in the configuration block of the <code>my_list</code> variable. Terraform will do the conversion automatically when the value is assigned.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#ff7b72">variable</span> <span style="color:#a5d6ff">&#34;remote_access_ports&#34;</span> {
</span></span><span style="display:flex;"><span>  description = <span style="color:#a5d6ff">&#34;Ports for remote access&#34;</span>
</span></span><span style="display:flex;"><span>  type        = set(string)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>While Terraform can do a lot of implicit conversions for you, explicit type conversions are practical during values normalization or when you need to calculate some complex value for a variable. For example, the Local Values, known as <code>locals</code>, are the most suitable place for doing that.</p>
<p>By the way, although there is a <code>tolist()</code> function, there is no such thing as the <code>tostring()</code> function. But what if you need to convert the list to string in Terraform?</p>
<p>The <code>one()</code> function can help here: it takes a list, set, or tuple value with either zero or one element and returns either <code>null</code> or that one element in the form of string.</p>
<p>It&rsquo;s useful in cases when a resource created using conditional expression is represented as either a zero- or one-element list, and you need to get a single value which may be either <code>null</code> or <code>string</code>, for example:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#ff7b72">resource</span> <span style="color:#a5d6ff">&#34;aws_kms_key&#34;</span> <span style="color:#a5d6ff">&#34;main&#34;</span> {
</span></span><span style="display:flex;"><span>  count               = var.ebs_encrypted <span style="color:#ff7b72;font-weight:bold">?</span> <span style="color:#a5d6ff">1</span> <span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  enable_key_rotation = <span style="color:#79c0ff">true</span>
</span></span><span style="display:flex;"><span>  tags                = var.tags
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">
</span></span></span><span style="display:flex;"><span><span style="color:#ff7b72">resource</span> <span style="color:#a5d6ff">&#34;aws_kms_alias&#34;</span> <span style="color:#a5d6ff">&#34;main&#34;</span> {
</span></span><span style="display:flex;"><span>  count         = var.ebs_encrypted <span style="color:#ff7b72;font-weight:bold">?</span> <span style="color:#a5d6ff">1</span> <span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  name          = <span style="color:#a5d6ff">&#34;alias/encrypt-ebs&#34;</span>
</span></span><span style="display:flex;"><span>  target_key_id = one(aws_kms_key.main[<span style="color:#ff7b72;font-weight:bold">*</span>]key_id)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="write-yaml-or-json-as-terraform-code-hcl">Write YAML or JSON as Terraform code (HCL)</h2>
<p><figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/01/16/some-techniques-to-enhance-your-terraform-proficiency/write-yaml-json-as-terraform-code_hu_fceb6d283c60b5ff.webp"width="400"height="400.00" />
        
    
</figure>

Sometimes you need to supply JSON or YAML files to the services you manage with Terraform. For example, if you want to create something with CloudFormation using Terraform (and I am not kidding). Sometimes the AWS Terraform provider does not support the needed resource, and you want to maintain the whole infrastructure code using only one tool.</p>
<p>Instead of maintaining another file in JSON or YAML format, you can embed JSON or YAML code management into HCL by taking benefit of the  <code>jsonencode()</code> or <code>yamlencode()</code>  functions.</p>
<p>The attractiveness of this approach is that you can reference other Terraform resources or their attributes right in the code of your object, and you have more freedom in terms of the code syntax and its formatting comparable to native JSON or YAML.</p>
<p>Here is how it looks like:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span>locals {
</span></span><span style="display:flex;"><span>	some_string = <span style="color:#a5d6ff">&#34;ult&#34;</span>
</span></span><span style="display:flex;"><span>  myjson_object = jsonencode({
</span></span><span style="display:flex;"><span>    <span style="color:#a5d6ff">&#34;Hashicorp Products&#34;</span><span style="color:#ff7b72;font-weight:bold">:</span> {
</span></span><span style="display:flex;"><span>      Terra<span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#34;form&#34;</span>
</span></span><span style="display:flex;"><span>      Con<span style="color:#ff7b72;font-weight:bold">:</span>   <span style="color:#a5d6ff">&#34;sul&#34;</span>
</span></span><span style="display:flex;"><span>      Vag<span style="color:#ff7b72;font-weight:bold">:</span>   <span style="color:#a5d6ff">&#34;rant&#34;</span>
</span></span><span style="display:flex;"><span>      Va<span style="color:#ff7b72;font-weight:bold">:</span>    local.some_string
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The value of the <code>myjson_object</code> local variable would look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#7ee787">&#34;Hashicorp Products&#34;</span>: {
</span></span><span style="display:flex;"><span>    <span style="color:#7ee787">&#34;Con&#34;</span>: <span style="color:#a5d6ff">&#34;sul&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#7ee787">&#34;Terra&#34;</span>: <span style="color:#a5d6ff">&#34;form&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#7ee787">&#34;Va&#34;</span>: <span style="color:#a5d6ff">&#34;ult&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#7ee787">&#34;Vag&#34;</span>: <span style="color:#a5d6ff">&#34;rant&#34;</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And here is a piece of real-world example:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span>locals {
</span></span><span style="display:flex;"><span>  cf_template_body = jsonencode({
</span></span><span style="display:flex;"><span>    Resources <span style="color:#ff7b72;font-weight:bold">:</span> {
</span></span><span style="display:flex;"><span>      DedicatedHostGroup <span style="color:#ff7b72;font-weight:bold">:</span> {
</span></span><span style="display:flex;"><span>        Type <span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#34;AWS::ResourceGroups::Group&#34;</span>
</span></span><span style="display:flex;"><span>        Properties <span style="color:#ff7b72;font-weight:bold">:</span> {
</span></span><span style="display:flex;"><span>          Name <span style="color:#ff7b72;font-weight:bold">:</span> var.service_name
</span></span><span style="display:flex;"><span>          Configuration <span style="color:#ff7b72;font-weight:bold">:</span> [
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>              Type <span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#34;AWS::EC2::HostManagement&#34;</span>
</span></span><span style="display:flex;"><span>              Parameters <span style="color:#ff7b72;font-weight:bold">:</span> [
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                  Name <span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#34;auto-allocate-host&#34;</span>
</span></span><span style="display:flex;"><span>                  Values <span style="color:#ff7b72;font-weight:bold">:</span> [var.auto_allocate_host]
</span></span><span style="display:flex;"><span>                },
</span></span><span style="display:flex;"><span>			...
</span></span><span style="display:flex;"><span>			...
</span></span></code></pre></div><h2 id="create-custom-file-templates-in-terraform">Create custom file templates in Terraform</h2>
<p><figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2022/01/16/some-techniques-to-enhance-your-terraform-proficiency/templatize-stuff_hu_7ee38532b37a40f5.webp"width="400"height="400.00" />
        
    
</figure>

The last case in this blog but not the least by its efficacy — render source file content as a template in Terraform.</p>
<p>Let&rsquo;s review the following scenario: you launch an EC2 instance and want to supply it with a bash script (via the user-data parameter) for some additional configuration at launch.</p>
<p>Suppose we have the following bash script <code>instance-init.sh</code> that sets the hostname and registers our instance in a monitoring system:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8b949e;font-weight:bold;font-style:italic">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span>hostname example.com
</span></span><span style="display:flex;"><span>bash /opt/system-init/register-monitoring.sh
</span></span></code></pre></div><p>But what if you want to set a different hostname per instance, and some instances should not be registered in the monitoring system?</p>
<p>In such a case, here is how the script file content will look:</p>
<pre tabindex="0"><code class="language-gotemplate" data-lang="gotemplate">#!/bin/bash

hostname ${system_hostname}
%{ if register_monitoring }
bash /opt/system-init/register-monitoring.sh
%{endif}
</code></pre><p>And when you supply this file as an argument for the EC2 instance resource in Terraform, you will use the <code>templatefile()</code> function to make the magic happen:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#ff7b72">resource</span> <span style="color:#a5d6ff">&#34;aws_instance&#34;</span> <span style="color:#a5d6ff">&#34;web&#34;</span> {
</span></span><span style="display:flex;"><span>  ami           = var.my_ami_id
</span></span><span style="display:flex;"><span>  instance_type = var.instance_type
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  user_data = templatefile(<span style="color:#a5d6ff">&#34;</span><span style="color:#a5d6ff">${</span>path.module<span style="color:#a5d6ff">}</span><span style="color:#a5d6ff">/instance-init.tftpl&#34;</span>, {
</span></span><span style="display:flex;"><span>    system_hostname     = var.system_hostname
</span></span><span style="display:flex;"><span>    register_monitoring = var.add_to_monitoring
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And of course, you can create a template from any file type. The only requirement here is that the template file must exist on the disk at the beginning of the Terraform execution.</p>
<h2 id="key-takeaways">Key takeaways</h2>
<p>Terraform is far beyond the standard resource management operations. With the power of built-in functions, you can write more versatile code and reusable Terraform modules.</p>
<p>✅ Use <a href="https://www.terraform.io/language/expressions/conditionals">conditional expressions</a> with <a href="https://www.terraform.io/language/meta-arguments/count">count</a> and <a href="https://www.terraform.io/language/meta-arguments/for_each">for_each</a> meta-arguments, when the creation of a resource depends on some context or user input.</p>
<p>✅ Take advantage of <a href="https://www.terraform.io/language/expressions/types#type-conversion">implicit type conversion</a> when working with input variables and their values to keep your code cleaner.</p>
<p>✅ Embed YAML and JSON-based objects right into your Terraform code using built-in <a href="https://www.terraform.io/language/functions/jsonencode">encoding</a> <a href="https://www.terraform.io/language/functions/yamlencode">functions</a>.</p>
<p>✅ And when you need to pass some files to the managed service, you can treat them as <a href="https://www.terraform.io/language/functions/templatefile">templates</a> and make them multipurpose.</p>
<p>Thank you for reading down to this point! 🤗</p>
<p>If you have some favorite Terraform tricks — I would love to know!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Guide to Using Terraform in CI/CD</title>
      <link>https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/</link>
      <pubDate>Wed, 24 Nov 2021 22:20:45 +0200</pubDate>
      <guid>https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/</guid>
      <description>How to configure, how to run, and what to mind for when using Terraform in CI/CD</description>
      <content:encoded><![CDATA[<p>Terraform by itself automates a lot of things: it creates, changes, and versions your cloud resources. Although many teams run Terraform locally (sometimes with wrapper scripts), running Terraform in CI/CD can boost the organization&rsquo;s performance and ensure consistent deployments.</p>
<p>In this article, I would like to review different approaches to integrating Terraform into generic deployment pipelines.</p>
<h1 id="where-to-store-the-terraform-code">Where to store the Terraform code</h1>
<p>Storing Terraform code in the same repository as the application code or maintaining a separate repository for the infrastructure?</p>
<p>This question has no strict and clear answer, but here are some insights that may help you decide:</p>
<ul>
<li>The Terraform and application code coupled together represent one unit, so it&rsquo;s simple to maintain by one team;</li>
<li>Conversely, if you have a dedicated team that manages infrastructure (e.g., platform team), a separate repository for infrastructure is more convenient because it&rsquo;s a standalone project in that case.</li>
<li>When infrastructure code is stored with the application, sometimes you have to deal with additional rules for the pipeline to separate triggers for these code parts. But sometimes (e.g., serverless apps) changes to either part (app/infra) should trigger the deployment.</li>
</ul>
<div class="attention">
    There is no right or wrong approach, but whichever you choose, remember to follow the <strong>Don’t Repeat Yourself (DRY)</strong> principle: make the infrastructure code modular by logically grouping resources into higher abstractions and reusing these modules.
</div>
<h1 id="preparing-terraform-execution-environment">Preparing Terraform execution environment</h1>
<p>Running Terraform locally generally means that all dependencies are already in-place: you have the binary installed and present in the user&rsquo;s <code>PATH</code> and perhaps even some providers already stored in the <code>.terraform</code> directory.</p>
<p>But when you shift Terraform runs from your local machine to stateless pipelines, this is not the case. However, you can still have a pre-built environment — this will speed up the pipeline execution and provide control over the process.</p>
<p>Docker image with a Terraform binary is one of the popular solutions that address this. Once created, you can execute Terraform within a container context with configuration files mounted as a Docker volume.</p>
<p>You can use the official <a href="https://hub.docker.com/r/hashicorp/terraform/">image from Hashicorp</a>, but sometimes it makes sense to maintain your own Docker images with additional tools you may need. For instance, you can bake the <code>tfsec</code> tool into the image to use it for security inspection and have it ready inside the Docker container without the need to install it every time.</p>
<p>Here is an example of a Dockerfile that builds an image with a custom Terraform version (you can override it as a build argument) and a <code>tfsec</code> tool. This example also shows how to verify the installed Terraform binary to make sure it&rsquo;s signed by HashiCorp before we run it.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#ff7b72">FROM</span><span style="color:#a5d6ff"> alpine:3.14</span><span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span><span style="color:#ff7b72">ARG</span> <span style="color:#79c0ff">TERRAFORM_VERSION</span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">1</span>.0.11<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span><span style="color:#ff7b72">ARG</span> <span style="color:#79c0ff">TFSEC_VERSION</span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">0</span>.59.0<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span><span style="color:#ff7b72">RUN</span> apk add --no-cache --virtual .sig-check gnupg<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span><span style="color:#ff7b72">RUN</span> wget -O /usr/bin/tfsec https://github.com/aquasecurity/tfsec/releases/download/v<span style="color:#a5d6ff">${</span><span style="color:#79c0ff">TFSEC_VERSION</span><span style="color:#a5d6ff">}</span>/tfsec-linux-amd64 <span style="color:#79c0ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#79c0ff"></span>    <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> chmod +x /usr/bin/tfsec<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span><span style="color:#ff7b72">RUN</span> cd /tmp <span style="color:#79c0ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#79c0ff"></span>    <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> wget <span style="color:#a5d6ff">&#34;https://releases.hashicorp.com/terraform/</span><span style="color:#a5d6ff">${</span><span style="color:#79c0ff">TERRAFORM_VERSION</span><span style="color:#a5d6ff">}</span><span style="color:#a5d6ff">/terraform_</span><span style="color:#a5d6ff">${</span><span style="color:#79c0ff">TERRAFORM_VERSION</span><span style="color:#a5d6ff">}</span><span style="color:#a5d6ff">_linux_amd64.zip&#34;</span> <span style="color:#79c0ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#79c0ff"></span>    <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> wget https://keybase.io/hashicorp/pgp_keys.asc <span style="color:#79c0ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#79c0ff"></span>    <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> gpg --import pgp_keys.asc <span style="color:#79c0ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#79c0ff"></span>    <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> gpg --fingerprint --list-signatures <span style="color:#a5d6ff">&#34;HashiCorp Security&#34;</span> | grep -q <span style="color:#a5d6ff">&#34;C874 011F 0AB4 0511 0D02  1055 3436 5D94 72D7 468F&#34;</span> <span style="color:#ff7b72;font-weight:bold">||</span> exit <span style="color:#a5d6ff">1</span> <span style="color:#79c0ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#79c0ff"></span>    <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> gpg --fingerprint --list-signatures <span style="color:#a5d6ff">&#34;HashiCorp Security&#34;</span> | grep -q <span style="color:#a5d6ff">&#34;34365D9472D7468F&#34;</span> <span style="color:#ff7b72;font-weight:bold">||</span> exit <span style="color:#a5d6ff">1</span> <span style="color:#79c0ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#79c0ff"></span>    <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> wget https://releases.hashicorp.com/terraform/<span style="color:#a5d6ff">${</span><span style="color:#79c0ff">TERRAFORM_VERSION</span><span style="color:#a5d6ff">}</span>/terraform_<span style="color:#a5d6ff">${</span><span style="color:#79c0ff">TERRAFORM_VERSION</span><span style="color:#a5d6ff">}</span>_SHA256SUMS <span style="color:#79c0ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#79c0ff"></span>    <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> wget https://releases.hashicorp.com/terraform/<span style="color:#a5d6ff">${</span><span style="color:#79c0ff">TERRAFORM_VERSION</span><span style="color:#a5d6ff">}</span>/terraform_<span style="color:#a5d6ff">${</span><span style="color:#79c0ff">TERRAFORM_VERSION</span><span style="color:#a5d6ff">}</span>_SHA256SUMS.sig <span style="color:#79c0ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#79c0ff"></span>    <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> gpg --verify terraform_<span style="color:#a5d6ff">${</span><span style="color:#79c0ff">TERRAFORM_VERSION</span><span style="color:#a5d6ff">}</span>_SHA256SUMS.sig terraform_<span style="color:#a5d6ff">${</span><span style="color:#79c0ff">TERRAFORM_VERSION</span><span style="color:#a5d6ff">}</span>_SHA256SUMS <span style="color:#ff7b72;font-weight:bold">||</span> exit <span style="color:#a5d6ff">1</span> <span style="color:#79c0ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#79c0ff"></span>    <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> sha256sum -c terraform_<span style="color:#a5d6ff">${</span><span style="color:#79c0ff">TERRAFORM_VERSION</span><span style="color:#a5d6ff">}</span>_SHA256SUMS 2&gt;&amp;<span style="color:#a5d6ff">1</span> | grep -q <span style="color:#a5d6ff">&#34;terraform_</span><span style="color:#a5d6ff">${</span><span style="color:#79c0ff">TERRAFORM_VERSION</span><span style="color:#a5d6ff">}</span><span style="color:#a5d6ff">_linux_amd64.zip: OK&#34;</span> <span style="color:#ff7b72;font-weight:bold">||</span> exit <span style="color:#a5d6ff">1</span> <span style="color:#79c0ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#79c0ff"></span>    <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> unzip terraform_<span style="color:#a5d6ff">${</span><span style="color:#79c0ff">TERRAFORM_VERSION</span><span style="color:#a5d6ff">}</span>_linux_amd64.zip -d /bin <span style="color:#79c0ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#79c0ff"></span>    <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> rm -rf /tmp/* <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> apk del .sig-check<span style="color:#f85149">
</span></span></span></code></pre></div><p>But the main functionality of Terraform is delivered by provider plugins. It takes time to download the provider: for example, the AWS provider is about 250MB, and in a large scale, with hundreds of Terraform runs per day, this makes a difference.</p>
<p>There are two common ways to deal with it: either use a shared cache available to your pipeline workloads or bake provider binaries into the runtime environment (i.e., Docker image).</p>
<p>The critical element for both approaches is the configuration of the plugin cache directory path. By default, Terraform looks for plugins and downloads them in the <code>.terraform</code> directory, which is local to the main project directory. But you can override this, and you can leverage the <code>TF_PLUGIN_CACHE_DIR</code> environment variable to do that.</p>
<p>If supported by your CI/CD tool, the shared cache can significantly reduce the operational burden because all your pipeline runtime environments can use it to get the needed provider versions.</p>
<p>So all you have to do is to maintain the provider versions in the shared cache and instruct Terraform to use it:</p>
<ul>
<li>Mount the cache directory to the pipeline runtime (i.e., docker container) and specify its internal path</li>
<li>Set the value of the <code>TF_PLUGIN_CACHE_DIR</code> environment variable accordingly</li>
</ul>
<p>On the other hand, you can bake the provider binaries into the Docker image and inject the value for the <code>TF_PLUGIN_CACHE_DIR</code> environment variable right into the Dockerfile.</p>
<div class="attention">
    This approach takes more operational effort <strong>but makes the Terraform environment self-sufficient and stateless</strong>. It also allows you to set strict boundaries around permitted provider versions as a security measure.
</div>
<h1 id="planning-and-applying-changes">Planning and Applying changes</h1>
<p>Now let&rsquo;s review the ways to automate planning and applying of changes. Although <code>terraform apply</code> can do both, it&rsquo;s sometimes useful to separate these actions.</p>
<h2 id="initialization">Initialization</h2>
<p>CI/CD pipelines generally run in stateless environments. Thus, every subsequent run of Terraform looks like a fresh start, so the project needs to be initialized before other actions can be performed.</p>
<p>The usage of the <code>init</code> command in CI/CD slightly differs from its common local usage:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>&gt; terraform init -input<span style="color:#ff7b72;font-weight:bold">=</span>false
</span></span></code></pre></div><p>The <code>-input=false</code> option prevents Terraform CLI from asking for user actions (it will throw an error if the input was required).</p>
<p><em>Also, there is <code>-no-color</code> option that prevents the usage of color codes in a shell, so the output will look much cleaner if your CI/CD logging system cannot render the terminal formatting.</em></p>
<p>Another option of the init command that is useful in CI — is the <code>-backend-config</code>. That option allows you to override the backend configuration in your code or define it if you prefer to use partial configuration, thus creating more uniform pipelines.</p>
<p>For example, here is how you can use the same code with different roles in different environments on AWS:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>&gt; terraform init -input<span style="color:#ff7b72;font-weight:bold">=</span>false <span style="color:#79c0ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#79c0ff"></span>-backend-config<span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">&#34;role_arn=arn:aws:iam::012345678901:role/QADeploymentAutomation&#34;</span>
</span></span></code></pre></div><p>Terraform <code>init</code> produces two artifacts:</p>
<ul>
<li><code>.terraform</code> directory, which Terraform uses to manage cached provider plugins and modules, and record backend information</li>
<li><code>.terraform.lock.hcl</code> file, which Terraform uses to track provider dependencies</li>
</ul>
<p>They both must be present in the project directory to successfully run the subsequent plan and apply commands.</p>
<p>However, I suggest checking in <code>.terraform.lock.hcl</code> to your repository as suggested by HashiCorp (<a href="https://www.terraform.io/docs/language/dependency-lock.html">Dependency Lock File</a>): this way you will be able to control dependencies more thoroughly, and you will not worry about transferring this file between build stages.</p>
<h2 id="plan">Plan</h2>
<p>The  <code>terraform plan</code> command helps you validate the changes manually. However, there are ways to use it in automation as well.</p>
<p>By default, Terraform prints the plan output in a human-friendly format but also supports machine-readable JSON. With additional command-line options, you can extend your CI experience.</p>
<p>For example, you can use your validation conditions to decide whether to apply the changes automatically; or you can parse the plan details and integrate the summary into a Pull Request description. Let’s review a simple example that illustrates it.</p>
<p>First, you need to save the plan output to the file:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>&gt; terraform plan -input<span style="color:#ff7b72;font-weight:bold">=</span>false -compact-warnings -out<span style="color:#ff7b72;font-weight:bold">=</span>plan.file
</span></span></code></pre></div><p>The main point here is the <code>-out</code> option — it tells Terraform to save its output into a binary plan file, and we will talk about it in the next paragraph.</p>
<p>The <code>-compact-warnings</code> option suppresses the warning-level messages produced by Terraform.</p>
<p>Also, the <code>plan</code> command has the <code>-detailed-exitcode</code> option that returns detailed exit codes when the command exits. For example, you can leverage this in a script that wraps Terraform and adds more conditional logic to its execution, because CIs will generally fail the pipeline on a command’s non-zero exit code. However, that may add complexity to the pipeline logic.</p>
<p>So if you need to get detailed info about the plan, I suggest parsing the plan output.</p>
<p>When you have a plan file, you can read it in JSON format and parse it. Here is a code snippet that illustrates that:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>&gt; terraform show -json plan.file| jq -r <span style="color:#a5d6ff">&#39;([.resource_changes[]?.change.actions?]|flatten)|{&#34;create&#34;:(map(select(.==&#34;create&#34;))|length),&#34;update&#34;:(map(select(.==&#34;update&#34;))|length),&#34;delete&#34;:(map(select(.==&#34;delete&#34;))|length)}&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a5d6ff">&#34;create&#34;</span>: 1,
</span></span><span style="display:flex;"><span>  <span style="color:#a5d6ff">&#34;update&#34;</span>: 0,
</span></span><span style="display:flex;"><span>  <span style="color:#a5d6ff">&#34;delete&#34;</span>: <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72;font-weight:bold">}</span>
</span></span></code></pre></div><p>Another way to see the information about changes, is to run the <code>plan</code> command with <code>-json</code> option and parse its output to stdout (available starting from Terraform 1.0.5):</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>&gt; terraform plan -json|jq <span style="color:#a5d6ff">&#39;select( .type == &#34;change_summary&#34;)|.&#34;@message&#34;&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#a5d6ff">&#34;Plan: 1 to add, 0 to change, 0 to destroy.&#34;</span>
</span></span></code></pre></div><p><div class="attention">
    This technique can make your Pull Request messages more informative and improve your collaboration with teammates.
</div>
You can write a custom script/function that sends a Pull Request comment to VCS using its API. Or you can try the existing features of your VCS: with GitHub Actions, you can use the <a href="https://github.com/marketplace/actions/terraform-pr-commenter">Terraform PR Commenter</a> or similar action to achieve that; for GitLab, there is a built-in functionality that integrates plan results into the Merge Request — <a href="https://docs.gitlab.com/ee/user/infrastructure/iac/mr_integration.html">Terraform integration in Merge Requests</a>.</p>
<p>You can find more information about the specification of the JSON output here — <a href="https://www.terraform.io/docs/internals/json-format.html">Terraform JSON Output Format</a>.</p>
<h2 id="apply">Apply</h2>
<p>When the plan file is ready, and the proposed changes are expected and approved, it&rsquo;s time to <code>apply</code> them.</p>
<p>Here is how the <code>apply</code> command may look like in automation:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>terraform apply -input<span style="color:#ff7b72;font-weight:bold">=</span>false -compact-warnings plan.file
</span></span></code></pre></div><p>Here, the <code>plan.file</code> is the file we got from the previous plan step.</p>
<p>Alternatively, you might want to omit the planning phase at all. In that case, the following command will apply the configuration immediately, without the need for a plan:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>terraform apply -input<span style="color:#ff7b72;font-weight:bold">=</span>false -compact-warnings -auto-approve
</span></span></code></pre></div><p>Here, the <code>-auto-approve</code> option tells Terraform to create the plan implicitly and skip the interactive approval of that plan before applying.</p>
<p>Whichever way you choose, keep in mind the destructive nature of the apply command. Hence, the fully automated apply of configuration generally works well with environments that tolerate unexpected downtimes, such as development or testing. Whereas plan review is recommended for production-grade environments, and in that case, the <code>apply</code> job is configured for a manual trigger.</p>
<h1 id="dealing-with-stateless-environments">Dealing with stateless environments</h1>
<p>If you run <code>init</code>, <code>plan</code>, and <code>apply</code> commands in different environments, you need to care for some artifacts produced by Terraform:</p>
<ul>
<li>The <code>.terraform</code> directory with information about modules, providers, and the state file (even in the case of remote state).</li>
<li>The <code>.terraform.lock.hcl</code> file — the dependency lock file which Terraform uses to check the integrity of provider versions used for the project. If your VCS does not track it, you&rsquo;ll need to pass that file to the <code>plan</code> and <code>apply</code> commands to make them work after <code>init</code>.</li>
<li>The output file of the <code>plan</code> command is essential for the <code>apply</code> command, so treat it as a vital artifact. This file includes a full copy of the project configuration, the state, and variables passed to the <code>plan</code> command (if any). Therefore, mind the security precautions because sensitive information may be present there.</li>
</ul>
<p>There is one shortcut, though. You can execute the <code>init</code> and <code>plan</code> commands within the same step/stage and transfer the artifacts only once — to the <code>apply</code> execution.</p>
<h1 id="using-the-command-line-and-environments-variables">Using the command-line and environments variables</h1>
<p>Last but not least, a few words about ways to maximize the advantage of variables when running Terraform in CI.</p>
<p>There are two common ways how you can pass values for the variables used in the configuration:</p>
<ol>
<li>Using a <code>-var-file</code> option with the variable definitions file — a filename ending in <code>.tfvars</code> or <code>.tfvars.json</code>. For example:
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>terraform apply -var-file<span style="color:#ff7b72;font-weight:bold">=</span>development.tfvars -input<span style="color:#ff7b72;font-weight:bold">=</span>false -no-color -compact-warnings -auto-approve
</span></span></code></pre></div>Also, Terraform can automatically load the variables from files named exactly <code>terraform.tfvars</code> or <code>terraform.tfvars.json</code>: with that approach, you don’t need to specify the tfvar file as a command option explicitly.</li>
<li>Using environment variables with the prefix <code>TF_VAR_</code>. Implicitly, Terraform always looks for the environment variables (within its process context) with that prefix, so the same &ldquo;instance_type&rdquo; variables from the example above can be passed as follows:
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>export <span style="color:#79c0ff">TF_VAR_instance_type</span><span style="color:#ff7b72;font-weight:bold">=</span>t3.nano
</span></span><span style="display:flex;"><span>terraform -input<span style="color:#ff7b72;font-weight:bold">=</span>false -no-color -compact-warnings -auto-approve
</span></span></code></pre></div></li>
</ol>
<p>The latter method is widely used in CI because modern CI/CD tools support the management of the environment variables for automation jobs.</p>
<p>Please refer to the following official documentation if you want to know more about variables — <a href="https://www.terraform.io/docs/language/values/variables.html">Terraform Input Variables</a>.</p>
<p>Along with that, Terraform supports several configuration parameters in the form of environment variables. These parameters are optional; however, they can simplify the automation management and streamline its code.</p>
<ul>
<li><code>TF_INPUT</code> — when set to &ldquo;false&rdquo; or &ldquo;0&rdquo;, this tells Terraform to behave the same way as with the <code>-input=false</code> flag;</li>
<li><code>TF_CLI_ARGS</code> — can contain a set of command-line options that will be passed to one or another Terraform command. Therefore, the following notation can simplify the execution of <code>apply</code> and <code>plan</code> commands by unifying their options for CI:
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>export <span style="color:#79c0ff">TF_CLI_ARGS</span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">&#34;-input=false -no-color -compact-warnings&#34;</span>
</span></span><span style="display:flex;"><span>terraform plan ...
</span></span><span style="display:flex;"><span>terraform apply ...
</span></span></code></pre></div>You can advantage this even more when using this variable as the environment configuration of stages or jobs in a CI/CD tool.</li>
<li><code>TF_IN_AUTOMATION</code>  — when set to any non-empty value (e.g., &ldquo;true&rdquo;), Terraform stops suggesting commands run after the one you execute, hence producing less output.</li>
</ul>
<h1 id="key-takeaways">Key takeaways</h1>
<p>There are two primary outcomes from automating Terraform executions: consistent results and integrating with the code or project management solutions. Although the exact implementation of Terraform in CI may vary per project or team, try to aim the following goals when working on it:</p>
<ul>
<li>Ease of code management</li>
<li>A secure and controlled execution environment</li>
<li>Coherent runs of init, plan, apply phases</li>
<li>Leveraging of built-in Terraform capabilities</li>
</ul>
<h5 id="i-originally-wrote-this-article-for-the-spaceliftio-technical-blog-but-i-decided-to-keep-it-here-as-well-for-the-history-the-canonical-link-to-their-blog-has-been-set-accordingly">I originally wrote this article for the Spacelift.io technical blog. But I decided to keep it here as well, for the history. The canonical link to their blog has been set accordingly.</h5>
]]></content:encoded>
    </item>
    <item>
      <title>Terraform Workflow — Working Individually and in a Team</title>
      <link>https://devdosvid.blog/2020/09/16/terraform-workflow-working-individually-and-in-a-team/</link>
      <pubDate>Wed, 16 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://devdosvid.blog/2020/09/16/terraform-workflow-working-individually-and-in-a-team/</guid>
      <description>An overview of best practices for working with Terraform individually or in a team</description>
      <content:encoded><![CDATA[<p>The work with Terraform code may become tangled sometimes. Here are some guides on how to streamline it and make it transparent for you and your team.</p>
<p>It is extremely helpful in a team, and can benefit you even if you work individually. A good workflow enables you to streamline a process, organize it, and make it less error-prone.</p>
<p>This article summaries several approaches when working with Terraform, both individually and in a team. I tried to gather the most common ones, but you might also want to develop your own.</p>
<p>The common requirement for all of them is a version control system (such as Git). This is how you ensure nothing is lost and all your code changes are properly versioned tracked.</p>
<h2 id="basic-concepts">Basic Concepts</h2>
<p>Let’s define the basic actions first.</p>
<p>All described workflows are built on top of three key steps: Write, Plan, and Apply. Nevertheless, their details and actions vary between workflows.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/09/16/terraform-workflow-working-individually-and-in-a-team/tf-workflow_hu_67ccf615b4552cfc.webp"
                 alt="Basic 3-steps Terraform workflow"width="800"height="89.88" />
        
    
    <figcaption>
        <p>Basic 3-steps Terraform workflow
            </p>
    </figcaption>
</figure>

<p><strong>Write</strong> – this is where you make changes to the code.</p>
<p><strong>Plan</strong> – this is where you review changes and decide whether to accept them.</p>
<p><strong>Apply</strong> – this is where you accept changes and apply them against real infrastructure.</p>
<p>It&rsquo;s a simple idea with a variety of possible implementations.</p>
<h2 id="core-individual-workflow">Core individual workflow</h2>
<p>This is the most simple workflow if you work alone on a relatively small TF project. This workflow suits both local and remote backends well.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/09/16/terraform-workflow-working-individually-and-in-a-team/tf-workflow-individual_hu_4cb162ed50a9602b.webp"
                 alt="Git-based Terraform workflow"width="800"height="267.41" />
        
    
    <figcaption>
        <p>Git-based Terraform workflow
            </p>
    </figcaption>
</figure>

<h3 id="write">Write</h3>
<p>You clone the remote code repo or pull the latest changes, edit the configuration code, then run the <code>terraform validate</code> and <code>terraform fmt</code> commands to make sure your code works well.</p>
<h3 id="plan">Plan</h3>
<p>This is where you run the <code>terraform plan</code> command to make sure that your changes do what you need. This is a good time to commit your code changes changes (or you can do it in the next step).</p>
<h3 id="apply">Apply</h3>
<p>This is when you run <code>terraform apply</code> and introduce the changes to real infrastructure objects. Also, this is when you push committed changes to the remote repository.</p>
<h2 id="core-team-workflow">Core team workflow</h2>
<p>This workflow is good for when you work with configuration code in a team and want to use feature branches to manage the changes accurately.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/09/16/terraform-workflow-working-individually-and-in-a-team/tf-core-workflow-team_hu_d3a97430ca465c56.webp"
                 alt="Git-based Terraform workflow in a team"width="800"height="298.41" />
        
    
    <figcaption>
        <p>Git-based Terraform workflow in a team
            </p>
    </figcaption>
</figure>

<h3 id="write-1">Write</h3>
<p>Start by checking out a new branch, make your changes, and run the <code>terraform validate</code> and <code>terraform fmt</code> commands to make sure your code works well.</p>
<p>Running <code>terraform plan</code> at this step will help ensure that you&rsquo;ll get what you expect.</p>
<h3 id="plan-1">Plan</h3>
<p>This is where code and plan reviews happen.</p>
<p>Add the output of the <code>terraform plan</code> command to the Pull Request with your changes. It would be a good idea to add only the changed parts of the common output, which is the part that starts with &ldquo;Terraform will perform the following actions&rdquo; string.</p>
<h3 id="apply-1">Apply</h3>
<p>Once the PR is reviewed and merged to the upstream branch, it is safe to finally pull the upstream branch locally and apply the configuration with <code>terraform apply</code>.</p>
<h2 id="team-workflow-with-automation">Team workflow with automation</h2>
<p>In a nutshell, this workflow allows you to introduce a kind of smoke test for your infrastructure code (using <code>plan</code>) and also to automate the feedback in the CI process.</p>
<p>The automated part of this workflow consists of a speculative plan on commit and/or Pull Request (PR ), along with adding the output of <code>plan</code> to the comment of the PR. A speculative plan mean just to show the changes, and not apply them afterward.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/09/16/terraform-workflow-working-individually-and-in-a-team/tf-workflow-team-automation-1_hu_3a84f3744d814e55.webp"
                 alt="Git-based Terraform workflow with automation"width="800"height="272.90" />
        
    
    <figcaption>
        <p>Git-based Terraform workflow with automation
            </p>
    </figcaption>
</figure>

<h3 id="write-2">Write</h3>
<p>This step is the same as in the previous workflow.</p>
<h3 id="plan-2">Plan</h3>
<p>This is where your CI tool does its job.</p>
<p>Let’s review this step by step:</p>
<p>1️⃣ You create a PR with the code changes you wish to implement.</p>
<p>2️⃣ The CI pipeline is triggered by an event from your code repository (such as webhook push) and it runs a speculative plan against your code.</p>
<p>3️⃣ The list of changes (a so-called &ldquo;plan diff&rdquo;) is added to PR for review by the CI.</p>
<p>4️⃣ Once merged, the CI pipeline runs again and you get the final plan that&rsquo;s ready to be applied to the infrastructure.</p>
<h3 id="apply-2">Apply</h3>
<p>Now that you have a branch (i.e. main) with the fresh code to apply, you need to pull it locally and run <code>terraform apply</code>.</p>
<p>You can also add the automated apply here – step 5 in the picture below. This may be very useful for disposable environments such as testing, staging, development, and so on.</p>
<p>The exact CI tool to be used here is up to you: Jenkins, GitHub Actions, and Travis CI all work well.</p>
<p>An important thing to note is that the CI pipeline must be configured in a bi-directional way with your repository to get the code from it and report back with comments to PR.</p>
<p>As an option, you may consider using Terraform Cloud which has a lot of functionality, including the above mentioned repo integration, even with the free subscription.</p>
<p>If you have never worked with Terraform Cloud before and want to advice to get started, I&rsquo;ll provide the links at the end of this article.</p>
<h2 id="import-workflow">Import workflow</h2>
<p>This workflow refers to a situation when you have some objects already created (i.e., up and running), and you need to manage them with Terraform.</p>
<p>Suppose we already have an S3 bucket in AWS called &ldquo;someassetsbucket&rdquo; and we want to include it into our configuration code.‌‌</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/09/16/terraform-workflow-working-individually-and-in-a-team/tf-workflow-import_hu_9147950a544cbc1a.webp"
                 alt="Terraform resource import workflow"width="800"height="238.20" />
        
    
    <figcaption>
        <p>Terraform resource import workflow
            </p>
    </figcaption>
</figure>

<h3 id="prepare">Prepare</h3>
<p>You should create a resource block to be used later for the real object you’re going to import.</p>
<p>You don’t need to fill the arguments in it at the start, so it may be just a blank resource block, for example:</p>
<pre tabindex="0"><code>resource &#34;aws_s3_bucket&#34; &#34;someassetsbucket&#34; {

}
</code></pre><h3 id="import">Import</h3>
<p>Now you need to import the information about the real object into your existing Terraform state file.</p>
<p>This can be done with the <code>terraform import</code> command, for example:</p>
<pre tabindex="0"><code>terraform import aws_s3_bucket.assets &#34;someassetsbucket&#34;
</code></pre><p>Be sure to also check the list of possible options import accepts with <code>terraform import -h</code></p>
<h3 id="write-3">Write</h3>
<p>Now you need to write the corresponding Terraform code for this bucket.</p>
<p>To avoid modifying your real object on the <code>terraform apply</code> action, you should specify all needed arguments with the exact values from the import phase.</p>
<p>You can see the details by running the <code>terraform state show</code> command, for example:</p>
<pre tabindex="0"><code>terraform state show aws_s3_bucket.assets
</code></pre><p>The output of this command will be very similar to the configuration code. But it contains both arguments and attributes of the resource, so you need to clean it up before applying it.</p>
<p>You can use one of the following tactics:</p>
<ul>
<li>either copy/paste it, and then run <code>terraform validate</code> and <code>terraform plan</code> several times to make sure there are no errors like &ldquo;argument is not expected here&rdquo; or &ldquo;this field cannot be set&rdquo;</li>
<li>or you can pick and write only the necessary arguments</li>
</ul>
<p>In any case, be sure to refer to the documentation of the resource during this process.</p>
<h3 id="plan-3">Plan</h3>
<p>The goal is to have a <code>terraform plan</code> output showing &ldquo;~ update in-place&rdquo; changes only.</p>
<p>However, it is not always clear whether the real object will be modified or only the state file will be updated. This is why you should understand how a real object works and know its life cycle to make sure it is safe to apply the plan.</p>
<h3 id="apply-3">Apply</h3>
<p>This is usual the <code>terraform apply</code> action.</p>
<p>Once applied, your configuration and state file will correspond to the real object configuration.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>Here is an overview of Terraform Cloud for those who never worked with it before: <a href="https://www.terraform.io/docs/cloud/overview.html">‌‌Overview of Terraform Cloud Features</a></p>
<p>And here is a nice tutorial to start with: <a href="https://learn.hashicorp.com/collections/terraform/cloud-get-started">Get Started - Terraform Cloud</a></p>
<p>Also, here is an overview of workflows at scale from the HashiCorp CTO which might be useful for more experienced Terraform users: <a href="https://www.hashicorp.com/resources/terraform-workflow-best-practices-at-scale">Terraform Workflow Best Practices at Scale</a></p>
<p>Thank you for reading. I hope you will try one of these workflows, or develop your own!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Terraform Certification Tips</title>
      <link>https://devdosvid.blog/2020/09/15/terraform-certification-tips/</link>
      <pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://devdosvid.blog/2020/09/15/terraform-certification-tips/</guid>
      <description>Summary of a learning path to HashiCorp Certified — Terraform Associate</description>
      <content:encoded><![CDATA[<p>I successfully passed the &ldquo;HashiCorp Certified — Terraform Associate&rdquo; exam last Friday and decided to share some advice for exam preparation.</p>
<h2 id="make-yourself-a-plan">Make yourself a plan</h2>
<p>Make a list of things you are going to go through: links to the study materials, practice tasks, some labs, some articles on relative blogs (Medium, Dev.to, etc.).
It should look at a &ldquo;todo&rdquo; or &ldquo;check&rdquo;-list. It may seem silly at first glance, but the list with checkboxes does its &ldquo;cognitive magic&rdquo;. When you go point by point, marking items as &ldquo;done&rdquo;, you feel the progress and this motivates you to keep going further.
For example, you can make a plan from the resources I outlined below in this article.</p>
<p>I encourage you to explore the Internet for something by yourself as well. Who knows, perhaps you will find some learning course that fits you better. And that is great! However, when you find it, take extra 5-10 minutes to go through its curriculum and create a list with lessons.</p>
<p>It feels so nice to cross out items off the todo list, believe me 😄
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/09/15/terraform-certification-tips/todo-list_hu_56f5ee47bfb2ea75.webp"width="585"height="540" />
        
    
</figure>
</p>
<h2 id="go-through-the-official-study-guide">Go through the official Study Guide</h2>
<p>Despite your findings on the Internet, I strongly suggest going through the official study guide</p>
<p><a href="https://learn.hashicorp.com/tutorials/terraform/associate-study">Study Guide - Terraform Associate Certification</a></p>
<p>It took me about 20 hours to complete it (including practice tasks based on topics in the guide), and it was the core of my studying. I did not buy or search for some third-party course intentionally because I did have some Terraform experience before starting the preparation. But give the official guide a chance even if you found some course. It is well-made and matches real exam questions very precisely.</p>
<p>Also, there is an official <a href="https://learn.hashicorp.com/tutorials/terraform/associate-review">Exam Review</a>. Someone might find this even better because it is a direct mapping of each exam objective to HashiCorp&rsquo;s documentation and training.</p>
<h2 id="take-additional-tutorials">Take additional tutorials</h2>
<p>Here is a list of additional tutorials and materials I suggest adding into your learning program:</p>
<h4 id="official-guides--documentation">Official guides / documentation:</h4>
<ul>
<li><a href="https://learn.hashicorp.com/collections/terraform/automation">Automate Terraform</a></li>
<li><a href="https://learn.hashicorp.com/collections/terraform/cloud">Collaborate using Terraform Cloud</a></li>
<li><a href="https://learn.hashicorp.com/collections/terraform/0-13">Terraform tutorials</a></li>
<li><a href="https://learn.hashicorp.com/collections/terraform/modules">Reuse Configuration with Modules</a></li>
<li><a href="https://www.hashicorp.com/resources/a-practitioner-s-guide-to-using-hashicorp-terraform-cloud-with-github">A Practitioner’s Guide to Using HashiCorp Terraform Cloud with GitHub</a></li>
<li><a href="https://learn.hashicorp.com/collections/terraform/policy">Enforce Policy with Sentinel</a></li>
</ul>
<h4 id="third-party-articles-and-guides">Third-party articles and guides:</h4>
<ul>
<li><a href="https://prefetch.net/blog/2020/04/27/using-the-terraform-console-to-debug-interpolation-syntax/">Using the terraform console to debug interpolation syntax</a></li>
<li><a href="https://www.youtube.com/playlist?list=PL5VXZTK6spA2HF5Kf0rI9RDRHF9Hopffr">YouTube playlist with exam-like questions review</a></li>
</ul>
<h2 id="find-yourself-some-practice">Find yourself some practice</h2>
<h4 id="mockup-a-project">Mockup a project</h4>
<p>You can greatly improve your practice by mocking some real business cases.</p>
<p>If you already work in some company you can set up the project you&rsquo;re working with using Terraform. If you don’t have a real project or afraid to accidentally violate NDA, try this open-source demo project: <a href="https://github.com/gothinkster/realworld">Real World Example Apps</a>.</p>
<p>It is a collection of different codebases for front-end and back-end used to build the same project. Just find the combination that suits your experience better and try to build the infrastructure for it using Terraform.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/09/15/terraform-certification-tips/real-world-demo_hu_ee5c37b3cd7c8a0a.webp"width="585"height="405" />
        
    
</figure>

<h4 id="answer-forum-topics">Answer forum topics</h4>
<p>Last but not least advice — try to answer some questions on the official <a href="https://discuss.hashicorp.com/c/terraform-core/">Terraform forum</a>.</p>
<p>This is a nice way to test your knowledge, help others, and develop the community around Terraform. Just register there, look for the latest topics, and have fun!</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/09/15/terraform-certification-tips/tf-forum_hu_33d86d1c47a6aa31.webp"width="585"height="650" />
        
    
</figure>

<p>🍀 I sincerely wish you exciting preparation and a successful exam! 🍀</p>
]]></content:encoded>
    </item>
    <item>
      <title>What are Terraform Modules and how do they work?</title>
      <link>https://devdosvid.blog/2020/09/09/what-are-terraform-modules-and-how-do-they-work/</link>
      <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://devdosvid.blog/2020/09/09/what-are-terraform-modules-and-how-do-they-work/</guid>
      <description>Explanation of Terraform modules and their main concepts in English.</description>
      <content:encoded><![CDATA[<p>Surprisingly, a lot of beginners skip over Terraform modules for the sake of simplicity, or so they think. Later, they find themselves going through hundreds of lines of configuration code.</p>
<p>I assume you already know some basics about Terraform or even tried to use it in some way before reading the article.</p>
<p>Please note: I do not use real code examples with some specific provider like AWS or Google intentionally, just for the sake of simplicity.</p>
<div class="substack-embedded-container">
    <h3>Subscribe to blog updates!</h3>
    <iframe title="Substack" class="substack-embedded-iframe" src="https://devdosvid.substack.com/embed" height="250"
            loading="lazy"></iframe>
</div>
<h2 id="terraform-modules">Terraform modules</h2>
<p>You already write modules even if you think you don’t.</p>
<p>Even when you don&rsquo;t create a module intentionally, if you use Terraform, you are already writing a module – a so-called &ldquo;root&rdquo; module.</p>
<p>Any number of Terraform configuration files <code>(.tf)</code> in a directory (even one) forms a module.</p>
<h3 id="what-does-the-module-do">What does the module do?</h3>
<p>A Terraform module allows you to create logical abstraction on the top of some resource set. In other words, a module allows you to group resources together and reuse this group later, possibly many times.</p>
<p>Let&rsquo;s assume we have a virtual server with some features hosted in the cloud. What set of resources might describe that server? For example:
– the virtual machine itself (created from some image)
– an attached block device of specified size (for additional storage)
– a static public IP mapped to the server&rsquo;s virtual network interface
– a set of firewall rules to be attached to the server
– something else&hellip; (i.e. another block device, additional network interface, etc)</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/09/09/what-are-terraform-modules-and-how-do-they-work/1_hu_40dd7eb9bc593566.webp"
                 alt="Terraform module example"width="425"height="253" />
        
    
    <figcaption>
        <p>Terraform module example
            </p>
    </figcaption>
</figure>

<p>Now let&rsquo;s assume that you need to create this server with a set of resources many times. This is where modules are really helpful – you don&rsquo;t want to repeat the same configuration code over and over again, do you?</p>
<p>Here is an example that illustrates how our &ldquo;server&rdquo; module might be called.
&ldquo;To call a module&rdquo; means to use it in the configuration file.</p>
<p>Here we create 5 instances of the &ldquo;server&rdquo; using single set of configurations (in the module):</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#ff7b72">module</span> <span style="color:#a5d6ff">&#34;server&#34;</span> {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    count         = <span style="color:#a5d6ff">5</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    source        = <span style="color:#a5d6ff">&#34;./module_server&#34;</span>
</span></span><span style="display:flex;"><span>    some_variable = some_value
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="modules-organisation-child-and-root">Modules organisation: child and root</h3>
<p>Of course, you would probably want to create more than one module. Here are some common examples:</p>
<ul>
<li>for a network (i.e. VPC)</li>
<li>for a static content hosting (i.e. buckets)</li>
<li>for a load balancer and it&rsquo;s related resources</li>
<li>for a logging configuration</li>
<li>and whatever else you consider a distinct logical component of the infrastructure</li>
</ul>
<p>Let&rsquo;s say we have two different modules: a &ldquo;server&rdquo; module and a &ldquo;network&rdquo; module. The module called &ldquo;network&rdquo; is where we define and configure our virtual network and place servers in it:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#ff7b72">module</span> <span style="color:#a5d6ff">&#34;server&#34;</span> {
</span></span><span style="display:flex;"><span>    source        = <span style="color:#a5d6ff">&#34;./module_server&#34;</span>
</span></span><span style="display:flex;"><span>    some_variable = some_value
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">
</span></span></span><span style="display:flex;"><span><span style="color:#ff7b72">module</span> <span style="color:#a5d6ff">&#34;network&#34;</span> {  
</span></span><span style="display:flex;"><span>    source              = <span style="color:#a5d6ff">&#34;./module_network&#34;</span>
</span></span><span style="display:flex;"><span>    some_other_variable = some_other_value
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Once we have some custom modules, we can refer to them as &ldquo;child&rdquo; modules. And the configuration file where we call child modules relates to the root module.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/09/09/what-are-terraform-modules-and-how-do-they-work/2_hu_a16dc9d6d2cd822d.webp"
                 alt="Terraform modules relations"width="800"height="299.75" />
        
    
    <figcaption>
        <p>Terraform modules relations
            </p>
    </figcaption>
</figure>

<p>A child module can be sourced from a number of places:</p>
<ul>
<li>local paths</li>
<li>official Terraform Registry (if you&rsquo;re familiar with other registries, i.e. Docker Registry then you already understand the idea)</li>
<li>Git repository (a custom one or GitHub/BitBucket)</li>
<li>HTTP URL to .zip archive with module</li>
</ul>
<p>But how can you pass resources details between modules?</p>
<p>In our example, the servers should be created in a network. So how can we tell the &ldquo;server&rdquo; module to create VMs in a network which was created in a module called &ldquo;network&rdquo;?</p>
<p>This is where <strong>encapsulation</strong> comes in.</p>
<h2 id="module-encapsulation">Module encapsulation</h2>
<p>Encapsulation in Terraform consists of two basic concepts: module scope and explicit resources exposure.</p>
<h3 id="module-scope">Module Scope</h3>
<p>All resource instances, names, and therefore, resource visibility, are isolated in a module&rsquo;s scope. For example, module &ldquo;A&rdquo; can&rsquo;t see and does not know about resources in module &ldquo;B&rdquo; by default.</p>
<p>Resource visibility, sometimes called resource isolation, ensures that resources will have unique names within a module&rsquo;s namespace. For example, with our 5 instances of the &ldquo;server&rdquo; module:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>module.server<span style="color:#ff7b72;font-weight:bold">[</span>0<span style="color:#ff7b72;font-weight:bold">]</span>.resource_type.resource_name
</span></span><span style="display:flex;"><span>module.server<span style="color:#ff7b72;font-weight:bold">[</span>1<span style="color:#ff7b72;font-weight:bold">]</span>.resource_type.resource_name
</span></span><span style="display:flex;"><span>module.server<span style="color:#ff7b72;font-weight:bold">[</span>2<span style="color:#ff7b72;font-weight:bold">]</span>.resource_type.resource_name
</span></span></code></pre></div><p>On the other hand, we could create two instances of the same module with different names:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#ff7b72">module</span> <span style="color:#a5d6ff">&#34;server-alpha&#34;</span> {    
</span></span><span style="display:flex;"><span>    source        = <span style="color:#a5d6ff">&#34;./module_server&#34;</span>
</span></span><span style="display:flex;"><span>    some_variable = some_value
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">module</span> <span style="color:#a5d6ff">&#34;server-beta&#34;</span> {
</span></span><span style="display:flex;"><span>    source        = <span style="color:#a5d6ff">&#34;./module_server&#34;</span>
</span></span><span style="display:flex;"><span>    some_variable = some_value
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this case, the naming or address of resources would be as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>module.server-alpha.resource_type.resource_name
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>module.server-beta.resource_type.resource_name
</span></span></code></pre></div><h3 id="explicit-resources-exposure">Explicit resources exposure</h3>
<p>If you want to access some details for the resources in another module, you&rsquo;ll need to explicitly configure that.</p>
<p>By default, our module &ldquo;server&rdquo; doesn&rsquo;t know about the network that was created in the &ldquo;network&rdquo; module.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/09/09/what-are-terraform-modules-and-how-do-they-work/3_hu_c452e97d87cc038e.webp"
                 alt="Resource incapsulation in Terraform modules"width="800"height="255.43" />
        
    
    <figcaption>
        <p>Resource incapsulation in Terraform modules
            </p>
    </figcaption>
</figure>

<p>So we must declare an <code>output</code> value in the &ldquo;network&rdquo; module to export its resource, or an attribute of a resource, to other modules.</p>
<p>The module &ldquo;server&rdquo; must declare a <code>variable</code> to be used later as the input.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/09/09/what-are-terraform-modules-and-how-do-they-work/4_hu_247ff679f92b4d48.webp"
                 alt="Module outputs and input variables"width="800"height="573.38" />
        
    
    <figcaption>
        <p>Module outputs and input variables
            </p>
    </figcaption>
</figure>

<p>This explicit declaration of the output is the way to expose some resource (or information about it) outside — to the scope of the &lsquo;root&rsquo; module, hence to make it available for other modules.</p>
<p>Next, when we call the child module &ldquo;server&rdquo;  in the root module, we should assign the output from the &ldquo;network&rdquo; module to the variable of the &ldquo;server&rdquo; module:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#79c0ff">network_id</span> <span style="color:#ff7b72;font-weight:bold">=</span> module.network.network_id
</span></span></code></pre></div><p>Here is how the final code for calling our child modules will look like in result:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#ff7b72">module</span> <span style="color:#a5d6ff">&#34;server&#34;</span> {
</span></span><span style="display:flex;"><span>    count         = <span style="color:#a5d6ff">5</span>
</span></span><span style="display:flex;"><span>    source        = <span style="color:#a5d6ff">&#34;./module_server&#34;</span>
</span></span><span style="display:flex;"><span>    some_variable = some_value
</span></span><span style="display:flex;"><span>    network_id    = module.network.network_id
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">
</span></span></span><span style="display:flex;"><span><span style="color:#ff7b72">module</span> <span style="color:#a5d6ff">&#34;network&#34;</span> {  
</span></span><span style="display:flex;"><span>    source              = <span style="color:#a5d6ff">&#34;./module_network&#34;</span>
</span></span><span style="display:flex;"><span>    some_other_variable = some_other_value
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This example configuration would create 5 instances of the same server, with all the necessary resources, in the network we created with as a separate module.</p>
<h3 id="wrap-up">Wrap up</h3>
<p>Now you should understand what modules are and what do they do.</p>
<p>If you&rsquo;re at the beginning of your Terraform journey, here are some suggestions for the next steps.</p>
<p>I encourage you to take this short tutorial from HashiCorp, the creators of Terraform, about modules:  <a href="https://learn.hashicorp.com/collections/terraform/modules">&ldquo;Organize Configuration&rdquo;</a></p>
<p>Also, there is a great comprehensive study guide which covers everything from beginner to advanced concepts about Terraform: <a href="https://learn.hashicorp.com/tutorials/terraform/associate-study?in=terraform/certification">&ldquo;Study Guide - Terraform Associate Certification&rdquo;</a></p>
<p>The modular code structure makes your configuration more flexible and yet easy to be understood by others. The latter is especially useful in teamwork.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Terraform CLI shortcuts</title>
      <link>https://devdosvid.blog/2020/08/25/terraform-cli-shortcuts/</link>
      <pubDate>Tue, 25 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://devdosvid.blog/2020/08/25/terraform-cli-shortcuts/</guid>
      <description>A bunch of small tools I use to simplify Terraform workflow</description>
      <content:encoded><![CDATA[<p>Here is some CLI shortcuts I use day-to-day to simplify and speed-up my Terraform workflow.
Requirements &mdash; bash-compatible interpreter, because aliases and functions described below will work with bash, zsh and ohmyzsh.</p>
<p>In order to use any of described aliases of functions, you need to place it in your <code>~/.bashrc</code> or <code>~/.zshrc</code> file (or any other configuration file you have for your shell).</p>
<p>Then just source this file, for example: <code>source ~/.zshrc</code></p>
<h2 id="function-list-outputs-and-variables-of-given-module">Function: list outputs and variables of given module</h2>
<p>You need to provide the path to module directory, and this function will list all declared variables and outputs module has. It comes very useful when you don&rsquo;t remember them all and just need to take a quick look.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">## TerraForm MOdule Explained</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">function</span> tfmoe <span style="color:#ff7b72;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>  echo -e <span style="color:#a5d6ff">&#34;\nOutputs:&#34;</span>
</span></span><span style="display:flex;"><span>  grep -r <span style="color:#a5d6ff">&#34;output \&#34;.*\&#34;&#34;</span> <span style="color:#79c0ff">$1</span> |awk <span style="color:#a5d6ff">&#39;{print &#34;\t&#34;,$2}&#39;</span> |tr -d <span style="color:#a5d6ff">&#39;&#34;&#39;</span>
</span></span><span style="display:flex;"><span>  echo -e <span style="color:#a5d6ff">&#34;\nVariables:&#34;</span>
</span></span><span style="display:flex;"><span>  grep -r <span style="color:#a5d6ff">&#34;variable \&#34;.*\&#34;&#34;</span> <span style="color:#79c0ff">$1</span> |awk <span style="color:#a5d6ff">&#39;{print &#34;\t&#34;,$2}&#39;</span> |tr -d <span style="color:#a5d6ff">&#39;&#34;&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72;font-weight:bold">}</span></span></span></code></pre></div>
<p>Example usage:</p>
<pre tabindex="0"><code class="language-terminal" data-lang="terminal">user@localhost $: tfmoe ./module_alb

Outputs:
	 alb_arn

Variables:
	 acm_certificate_arn
	 lb_name
	 alb_sg_list
	 subnets_id_list
	 tags
</code></pre><h2 id="function-pre-fill-module-directory-with-configuration-files">Function: pre-fill module directory with configuration files</h2>
<p>You need to provide a path to the module directory and this function will create a bunch of empty &lsquo;default&rsquo; .tf files in it.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">#TerraForm MOdule Initialize</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">function</span> tfmoi <span style="color:#ff7b72;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>  touch <span style="color:#79c0ff">$1</span>/variables.tf
</span></span><span style="display:flex;"><span>  touch <span style="color:#79c0ff">$1</span>/outputs.tf
</span></span><span style="display:flex;"><span>  touch <span style="color:#79c0ff">$1</span>/versions.tf
</span></span><span style="display:flex;"><span>  touch <span style="color:#79c0ff">$1</span>/main.tf
</span></span><span style="display:flex;"><span><span style="color:#ff7b72;font-weight:bold">}</span>
</span></span></code></pre></div><p>Example usage:</p>
<pre tabindex="0"><code class="language-terminal" data-lang="terminal">user@localhost $: mkdir ./module_foo &amp;&amp; temoi $_

user@localhost $: ls ./module_foo
main.tf      outputs.tf   variables.tf versions.tf
</code></pre><h2 id="aliases">Aliases</h2>
<p>The purpose of these aliases is just to keep you from typing long commands when you want to do a simple action.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>alias <span style="color:#79c0ff">tf</span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">&#39;terraform&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>alias <span style="color:#79c0ff">tfv</span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">&#39;terraform validate&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>alias <span style="color:#79c0ff">tfi</span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">&#39;terraform init&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>alias <span style="color:#79c0ff">tfp</span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">&#39;terraform plan&#39;</span> 
</span></span></code></pre></div><p>This one is useful because it makes format tool to go in-depth (recursively) through directories.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>alias <span style="color:#79c0ff">tfm</span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">&#39;terraform fmt -recursive&#39;</span>
</span></span></code></pre></div><p>Example usage:</p>
<pre tabindex="0"><code class="language-terminal" data-lang="terminal">user@localhost $: tfm 
module_ecs_cluster/ecs.tf
module_alb/alb.tf
</code></pre>]]></content:encoded>
    </item>
    <item>
      <title>Terraform explained in English</title>
      <link>https://devdosvid.blog/2020/05/02/terraform-explained-in-english/</link>
      <pubDate>Sat, 02 May 2020 00:00:00 +0000</pubDate>
      <guid>https://devdosvid.blog/2020/05/02/terraform-explained-in-english/</guid>
      <description>What is Terraform, how does it work, why and when do you need it</description>
      <content:encoded><![CDATA[<p>You might have heard about Terraform before, but if you have never tried it, this blog can help you to get the main point.</p>
<h2 id="a-few-words-about-infrastructure-as-code">A few words about “Infrastructure as Code&quot;</h2>
<p>First of all, Terraform is the way to manage the infrastructure in the form of code. The same way developers write the code to create applications, Terraform code can create the resources in virtual data centers (i.e., clouds).</p>
<p>Infrastructure as Code, or IaC, is when you describe and manage your infrastructure as… (guess what?) …code, literally.</p>
<p>In a nutshell, that means you can define all the elements (servers, networks, storage, etc.) and resources (memory, CPU, etc.) of your infrastructure in configuration files, and manage it in a way similar to how you handle the source code of the applications: branches, releases, and all that stuff.</p>
<p>And the main idea behind the IaC approach is that it manages the state of things and must remain the single source of truth (configuration truth) for your infrastructure.</p>
<p>First, you define the state via the code. Then IaC tool (Terraform, for example) applies this state to the infrastructure: all that is missing according to the code will be created, all that differs from the code will be changed, and all that exists in the infrastructure but is not described via code — will be destroyed.</p>
<h2 id="why-and-when-do-you-need-the-terraform-for-a-project">Why and when do you need the Terraform for a project?</h2>
<p>Terraform is a specific tool, hence like any other tool, it has its particular application area. There is no strict definition of project kind that needs Terraform (surprise!), but in general, you need to consider using Terraform if you answer ‘yes’ to one of the following questions:</p>
<ul>
<li>Do you have multiple logical elements of the same kind (in plural) in your infrastructure, i.e., several web servers, several application servers, several database servers?</li>
<li>Do you have numerous environments (or workspaces) where you run your applications, i.e., development, staging, QA, production?</li>
<li>Do you spend a significant amount of time managing the changes in the environment(s) where you run your applications?</li>
</ul>
<h2 id="how-does-it-work">How does it work?</h2>
<p>Terraform works with the source code of configuration and interprets the code into real objects inside on-premise or cloud platforms.</p>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/05/02/terraform-explained-in-english/how-it-works-optimized_hu_45dd8a37a45d42dc.webp"
                 alt="How Terraform works"width="800"height="400.00" />
        
    
    <figcaption>
        <p>How Terraform works in a nutshell
            </p>
    </figcaption>
</figure>

<p>Terraform supports many platforms: cloud providers such as AWS, Azure, GCP, DigitalOcean, and other platforms such as OVH, 1&amp;1, Hetzner, etc. It also supports infrastructure software such as Docker, Kubernetes, Chef, and even databases and monitoring software. That is why Terraform is so popular — it is an actual Swiss knife in the operations world.</p>
<p>So to create, change, or destroy the infrastructure, Terraform needs the source code.</p>
<p>The <strong>source code</strong> is a set of configuration files that defines your infrastructure state. The code uses its syntax, but it looks very user-friendly. Here is an example: the following configuration block describes the virtual server (EC2 instance) in AWS.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hcl" data-lang="hcl"><span style="display:flex;"><span><span style="color:#ff7b72">resource</span> <span style="color:#a5d6ff">&#34;aws_instance&#34; &#34;web_server&#34;</span> {
</span></span><span style="display:flex;"><span>  ami           <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;ami-a1b2c3d4&#34;</span>
</span></span><span style="display:flex;"><span>  instance_type <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;t3.micro&#34;</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Terraform can automatically detect the dependencies between resources described in the code and also allows you to add custom dependencies when needed.</p>
<p>When you apply the code the first time, Terraform creates a so-called “<strong>state file</strong>,&quot; which Terraform uses to map your code to resources created in the hosting platform. Terraform will use each subsequent “apply&quot; action to compare the code changes with the sate file to decide what should be done (and in what order) against real infrastructure.</p>
<p>One of the essential functions of the state file is the management of dependencies between the resources. For example (some technical nuances are omitted for simplicity): if you have a server created inside some network and you are going to change the network configuration in Terraform code, Terraform will know it should change that server configuration, or the server should be re-created inside the updated network.</p>
<h2 id="what-does-terraform-consist-of">What does Terraform consist of:</h2>
<p>Terraform configuration code consists of several elements: providers, resources, modules, input variables, output values, local values, expressions, functions.</p>
<h3 id="provider">Provider</h3>
<p><strong>Provider</strong> is an entity that defines what exactly is possible to do with the cloud or on-premises infrastructure platform you manage via Terraform.</p>
<p>It translates your code into proper API calls to the hosting provider, transforming your configuration into real object: servers, networks, databases, and so on.</p>
<h3 id="resource">Resource</h3>
<p><strong>Resource</strong> is the essential part of the configuration code. That is where the definition of infrastructure objects happens.</p>
<p>Resources are the main building blocks of the whole code. A resource can represent some object in the hosting provider (example: server) or the part of a compound object (example: attachable storage for a server)</p>
<p>Every resource has a type and local name. For example, here is how EC2 instance configuration may look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hcl" data-lang="hcl"><span style="display:flex;"><span><span style="color:#ff7b72">resource</span> <span style="color:#a5d6ff">&#34;aws_instance&#34; &#34;web_server&#34;</span> {
</span></span><span style="display:flex;"><span>  ami           <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;ami-a1b2c3d4&#34;</span>
</span></span><span style="display:flex;"><span>  instance_type <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;t3.micro&#34;</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>The <code>aws_instance</code> is a resource type, and <code>web_server</code> is the local resource name. Later, when Terraform applies this code, it will create an EC2 instance with some particular ID in AWS.</p>
<p>Once created, Terraform will store the ID in the state file with mapping information that logically connects it with <code>web_server</code>.</p>
<p>The <code>ami</code>, <code>instance_type</code>, and <code>private_ip</code> are the arguments with values that define the actual state of the resource. However, there are many value types, depending on the particular argument and particular resource type, so I will not focus on them here.</p>
<h3 id="modules">Modules</h3>
<figure>
    
    
        
        
        
        
        
        
        <img loading="lazy"
             src="/2020/05/02/terraform-explained-in-english/module-example_hu_1bfc5a5ad1a31420.webp"
                 alt="Terraform module"width="800"height="400.00" />
        
    
    <figcaption>
        <p>Terraform module
            </p>
    </figcaption>
</figure>

<p><strong>Modules</strong> is the kind of logical containers or groups for resources you define and use together. The purpose of modules is the grouping of resources and the possibility of reusing the same code with different variables.</p>
<p>Let’s get back to the example with the EC2 instance and say you need to have a static public IP address with it. In such a case, here is how the module for web server may look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hcl" data-lang="hcl"><span style="display:flex;"><span><span style="color:#ff7b72">resource</span> <span style="color:#a5d6ff">&#34;aws_instance&#34; &#34;web_server&#34;</span> {
</span></span><span style="display:flex;"><span>  ami           <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;ami-a1b2c3d4&#34;</span>
</span></span><span style="display:flex;"><span>  instance_type <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;t3.micro&#34;</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">resource</span> <span style="color:#a5d6ff">&#34;aws_eip&#34; &#34;web_server_public_ip&#34;</span> {
</span></span><span style="display:flex;"><span>  instance      <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;${aws_instance.web_server.id}&#34;</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Having these two resources together allows us to think of it as a stand-alone unit you can reuse later, for example, in our development, staging, and production environments. And not by copying and pasting it, but via reference to the module defined only once.</p>
<p>Please note: we specified an instance argument inside the <code>aws_eip</code> resource to reference another resource details (the ID of an instance). It is possible because of the way how Terraform treats dependencies. For example, when it detects the dependency (or you define it explicitly), Terraform creates the leading resource first. Only after the resource is created and available Terraform will create the dependent one.</p>
<p>The modules is a kind of standalone topic in Terraform. There is <a href="/2020/09/09/terraform-modules-explained.html">a separate article in my blog</a> that explains what modules are and how do they work.</p>
<h3 id="variables">Variables</h3>
<p><strong>Input variables</strong> work as parameters for the modules so module code could be reusable. Let’s look at the previous example: it has some hardcoded values — instance image ID and instance type. Here is how you can make it more abstract and reusable:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hcl" data-lang="hcl"><span style="display:flex;"><span><span style="color:#ff7b72">variable</span> <span style="color:#a5d6ff">&#34;image_id&#34;</span> {
</span></span><span style="display:flex;"><span>  type          <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#ff7b72">string</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">variable</span> <span style="color:#a5d6ff">&#34;instance_type&#34;</span> {
</span></span><span style="display:flex;"><span>  type          <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#ff7b72">string</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">resource</span> <span style="color:#a5d6ff">&#34;aws_instance&#34; &#34;web_server&#34;</span> {
</span></span><span style="display:flex;"><span>  ami           <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#ff7b72">var</span>.<span style="color:#ff7b72">image_id</span>
</span></span><span style="display:flex;"><span>  instance_type <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#ff7b72">var</span>.<span style="color:#ff7b72">instance_type</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Values for the variables then can be passed either via CLI and environment variables (if you have only the one, so-called root module) or via explicit values in the block where you call a module, for example:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hcl" data-lang="hcl"><span style="display:flex;"><span><span style="color:#ff7b72">module</span> <span style="color:#a5d6ff">&#34;web_server_production&#34;</span> {
</span></span><span style="display:flex;"><span>  source        <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;./modules/web_server&#34;</span>
</span></span><span style="display:flex;"><span>  image_id      <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;ami-a1b2c3d4&#34;</span>
</span></span><span style="display:flex;"><span>  instance_type <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;m5.large&#34;</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">module</span> <span style="color:#a5d6ff">&#34;web_server_development&#34;</span> {
</span></span><span style="display:flex;"><span>  source        <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;./modules/web_server&#34;</span>
</span></span><span style="display:flex;"><span>  image_id      <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;ami-a2b3c4d5&#34;</span>
</span></span><span style="display:flex;"><span>  instance_type <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;t3.micro&#34;</span>
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p><strong>Output values</strong> are similar to the &ldquo;return&rdquo; of a function in development language. You can use them for dependencies management (for example, when a module requires something from another module) and print specific values at the end of Terraform work (for example, to be used for notification in the CI/CD process).</p>
<p><strong>Local values</strong>, <strong>expressions</strong>, <strong>functions</strong> — three more things that augment the capabilities of Terraform and make it more similar to a programming language (which is excellent, by the way).</p>
<p>The local values are used inside modules for extended data manipulations.</p>
<p>The expressions are used to set the values (for many things), such as the value of some argument in resource configuration. For example, they used either to refer something (just as we referenced instance ID <code>&quot;${aws_instance.web_server.id}&quot;</code> in the example above) or to compute the value within your configuration.</p>
<p>The functions in Terraform are built-in jobs you can call to transform and combine values. For example, the <code>tolist()</code> function converts its argument to a list value.</p>
<h2 id="and-this-is-it">And this is it?</h2>
<p>Yes, in short words — this is what Terraform is. Not rocket science if it&rsquo;s about to manage a small infrastructure, but it gets more complicated with bigger infrastructure. Like any other engineering tool, though.</p>
<h2 id="okay-what-next">Okay, what next?</h2>
<p>If you read down to this point, then it means it is worth &ldquo;get your hands dirty&rdquo; and to try building your Infrastructure with Terraform. There are plenty of courses and books (and the &ldquo;Terraform up and running&rdquo; is one of the most popular). Still, my learning path started from the following: <a href="https://learn.hashicorp.com/terraform">Official guide from Hashicorp</a> — comprehensive and free guide from Terraform developers. Just pick your favorite cloud (AWS, Azure, GCP) and go through the topics.</p>
<p>Another thing worth your attention is <a href="https://blog.gruntwork.io/a-comprehensive-guide-to-terraform-b3d32832baca">A Comprehensive Guide to Terraform</a>.</p>
<p>Once you finish this guide, I suggest jumping into the more real-world things and describing the infrastructure of the most common project you work with.</p>
<p>Your hands-on experience is the best way to learn Terraform!</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
