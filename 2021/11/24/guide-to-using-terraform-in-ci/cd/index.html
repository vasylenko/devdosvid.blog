<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Guide to Using Terraform in CI/CD | devDosvid — my engineering experience</title><meta name=keywords content="terraform,cli,automation"><meta name=description content="How to configure, how to run, and what to mind for when using Terraform in CI/CD"><meta name=author content="Serhii Vasylenko"><link rel=canonical href=https://spacelift.io/blog/terraform-in-ci-cd><link crossorigin=anonymous href=/assets/css/stylesheet.min.8c2dcc5cb47fe875a9d7c6448ddfbf696619a7d770664fc2b8babad30d2e5890.css integrity="sha256-jC3MXLR/6HWp18ZEjd+/aWYZp9dwZk/CuLq60w0uWJA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://devdosvid.blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://devdosvid.blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://devdosvid.blog/favicon-32x32.png><link rel=apple-touch-icon href=https://devdosvid.blog/apple-touch-icon.png><link rel=mask-icon href=https://devdosvid.blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=text/javascript>window.heap=window.heap||[],heap.load=function(i,o){window.heap.appid=i,window.heap.config=o=o||{},e=document.createElement("script"),e.type="text/javascript",e.async=!0,e.src="https://cdn.heapanalytics.com/js/heap-"+i+".js",n=document.getElementsByTagName("script")[0],n.parentNode.insertBefore(e,n);for(var e,n,a=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},s=["addEventProperties","addUserProperties","clearEventProperties","identify","resetIdentity","removeEventProperty","setEventProperties","track","unsetEventProperty"],t=0;t<s.length;t++)heap[s[t]]=a(s[t])},heap.load("2300872157")</script><meta name=twitter:creator content="@vasylenko"><meta name=twitter:site content="@vasylenko"><meta property="og:title" content="Guide to Using Terraform in CI/CD"><meta property="og:description" content="How to configure, how to run, and what to mind for when using Terraform in CI/CD"><meta property="og:type" content="article"><meta property="og:url" content="https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/"><meta property="og:image" content="https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/cover-image.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-24T22:20:45+02:00"><meta property="article:modified_time" content="2022-01-20T16:19:51+02:00"><meta property="og:site_name" content="devDosvid — my engineering experience"><meta property="og:see_also" content="https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/"><meta property="og:see_also" content="https://devdosvid.blog/2022/01/16/some-techniques-to-enhance-your-terraform-proficiency/"><meta property="og:see_also" content="https://devdosvid.blog/2020/08/25/terraform-cli-shortcuts/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/cover-image.png"><meta name=twitter:title content="Guide to Using Terraform in CI/CD"><meta name=twitter:description content="How to configure, how to run, and what to mind for when using Terraform in CI/CD"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://devdosvid.blog/posts/"},{"@type":"ListItem","position":3,"name":"Guide to Using Terraform in CI/CD","item":"https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Guide to Using Terraform in CI/CD","name":"Guide to Using Terraform in CI\/CD","description":"How to configure, how to run, and what to mind for when using Terraform in CI/CD","keywords":["terraform","cli","automation"],"articleBody":"Terraform by itself automates a lot of things: it creates, changes, and versions your cloud resources. Although many teams run Terraform locally (sometimes with wrapper scripts), running Terraform in CI/CD can boost the organization’s performance and ensure consistent deployments.\nIn this article, I would like to review different approaches to integrating Terraform into generic deployment pipelines.\nWhere to store the Terraform code Storing Terraform code in the same repository as the application code or maintaining a separate repository for the infrastructure?\nThis question has no strict and clear answer, but here are some insights that may help you decide:\n The Terraform and application code coupled together represent one unit, so it’s simple to maintain by one team; Conversely, if you have a dedicated team that manages infrastructure (e.g., platform team), a separate repository for infrastructure is more convenient because it’s a standalone project in that case. When infrastructure code is stored with the application, sometimes you have to deal with additional rules for the pipeline to separate triggers for these code parts. But sometimes (e.g., serverless apps) changes to either part (app/infra) should trigger the deployment.  There is no right or wrong approach, but whichever you choose, remember to follow the Don’t Repeat Yourself (DRY) principle: make the infrastructure code modular by logically grouping resources into higher abstractions and reusing these modules.  Preparing Terraform execution environment Running Terraform locally generally means that all dependencies are already in-place: you have the binary installed and present in the user’s PATH and perhaps even some providers already stored in the .terraform directory.\nBut when you shift Terraform runs from your local machine to stateless pipelines, this is not the case. However, you can still have a pre-built environment — this will speed up the pipeline execution and provide control over the process.\nDocker image with a Terraform binary is one of the popular solutions that address this. Once created, you can execute Terraform within a container context with configuration files mounted as a Docker volume.\nYou can use the official image from Hashicorp, but sometimes it makes sense to maintain your own Docker images with additional tools you may need. For instance, you can bake the tfsec tool into the image to use it for security inspection and have it ready inside the Docker container without the need to install it every time.\nHere is an example of a Dockerfile that builds an image with a custom Terraform version (you can override it as a build argument) and a tfsec tool. This example also shows how to verify the installed Terraform binary to make sure it’s signed by HashiCorp before we run it.\nFROMalpine:3.14ARG TERRAFORM_VERSION=1.0.11ARG TFSEC_VERSION=0.59.0RUN apk add --no-cache --virtual .sig-check gnupgRUN wget -O /usr/bin/tfsec https://github.com/aquasecurity/tfsec/releases/download/v${TFSEC_VERSION}/tfsec-linux-amd64 \\  \u0026\u0026 chmod +x /usr/bin/tfsecRUN cd /tmp \\  \u0026\u0026 wget \"https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip\" \\  \u0026\u0026 wget https://keybase.io/hashicorp/pgp_keys.asc \\  \u0026\u0026 gpg --import pgp_keys.asc \\  \u0026\u0026 gpg --fingerprint --list-signatures \"HashiCorp Security\" | grep -q \"C874 011F 0AB4 0511 0D02 1055 3436 5D94 72D7 468F\" || exit 1 \\  \u0026\u0026 gpg --fingerprint --list-signatures \"HashiCorp Security\" | grep -q \"34365D9472D7468F\" || exit 1 \\  \u0026\u0026 wget https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_SHA256SUMS \\  \u0026\u0026 wget https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_SHA256SUMS.sig \\  \u0026\u0026 gpg --verify terraform_${TERRAFORM_VERSION}_SHA256SUMS.sig terraform_${TERRAFORM_VERSION}_SHA256SUMS || exit 1 \\  \u0026\u0026 sha256sum -c terraform_${TERRAFORM_VERSION}_SHA256SUMS 2\u00261 | grep -q \"terraform_${TERRAFORM_VERSION}_linux_amd64.zip: OK\" || exit 1 \\  \u0026\u0026 unzip terraform_${TERRAFORM_VERSION}_linux_amd64.zip -d /bin \\  \u0026\u0026 rm -rf /tmp/* \u0026\u0026 apk del .sig-checkBut the main functionality of Terraform is delivered by provider plugins. It takes time to download the provider: for example, the AWS provider is about 250MB, and in a large scale, with hundreds of Terraform runs per day, this makes a difference.\nThere are two common ways to deal with it: either use a shared cache available to your pipeline workloads or bake provider binaries into the runtime environment (i.e., Docker image).\nThe critical element for both approaches is the configuration of the plugin cache directory path. By default, Terraform looks for plugins and downloads them in the .terraform directory, which is local to the main project directory. But you can override this, and you can leverage the TF_PLUGIN_CACHE_DIR environment variable to do that.\nIf supported by your CI/CD tool, the shared cache can significantly reduce the operational burden because all your pipeline runtime environments can use it to get the needed provider versions.\nSo all you have to do is to maintain the provider versions in the shared cache and instruct Terraform to use it:\n Mount the cache directory to the pipeline runtime (i.e., docker container) and specify its internal path Set the value of the TF_PLUGIN_CACHE_DIR environment variable accordingly  On the other hand, you can bake the provider binaries into the Docker image and inject the value for the TF_PLUGIN_CACHE_DIR environment variable right into the Dockerfile.\nThis approach takes more operational effort but makes the Terraform environment self-sufficient and stateless. It also allows you to set strict boundaries around permitted provider versions as a security measure.  Planning and Applying changes Now let’s review the ways to automate planning and applying of changes. Although terraform apply can do both, it’s sometimes useful to separate these actions.\nInitialization CI/CD pipelines generally run in stateless environments. Thus, every subsequent run of Terraform looks like a fresh start, so the project needs to be initialized before other actions can be performed.\nThe usage of the init command in CI/CD slightly differs from its common local usage:\n terraform init -input=false The -input=false option prevents Terraform CLI from asking for user actions (it will throw an error if the input was required).\nAlso, there is -no-color option that prevents the usage of color codes in a shell, so the output will look much cleaner if your CI/CD logging system cannot render the terminal formatting.\nAnother option of the init command that is useful in CI — is the -backend-config. That option allows you to override the backend configuration in your code or define it if you prefer to use partial configuration, thus creating more uniform pipelines.\nFor example, here is how you can use the same code with different roles in different environments on AWS:\n terraform init -input=false \\ -backend-config=\"role_arn=arn:aws:iam::012345678901:role/QADeploymentAutomation\" Terraform init produces two artifacts:\n .terraform directory, which Terraform uses to manage cached provider plugins and modules, and record backend information .terraform.lock.hcl file, which Terraform uses to track provider dependencies  They both must be present in the project directory to successfully run the subsequent plan and apply commands.\nHowever, I suggest checking in .terraform.lock.hcl to your repository as suggested by HashiCorp (Dependency Lock File): this way you will be able to control dependencies more thoroughly, and you will not worry about transferring this file between build stages.\nPlan The terraform plan command helps you validate the changes manually. However, there are ways to use it in automation as well.\nBy default, Terraform prints the plan output in a human-friendly format but also supports machine-readable JSON. With additional command-line options, you can extend your CI experience.\nFor example, you can use your validation conditions to decide whether to apply the changes automatically; or you can parse the plan details and integrate the summary into a Pull Request description. Let’s review a simple example that illustrates it.\nFirst, you need to save the plan output to the file:\n terraform plan -input=false -compact-warnings -out=plan.file The main point here is the -out option — it tells Terraform to save its output into a binary plan file, and we will talk about it in the next paragraph.\nThe -compact-warnings option suppresses the warning-level messages produced by Terraform.\nAlso, the plan command has the -detailed-exitcode option that returns detailed exit codes when the command exits. For example, you can leverage this in a script that wraps Terraform and adds more conditional logic to its execution, because CIs will generally fail the pipeline on a command’s non-zero exit code. However, that may add complexity to the pipeline logic.\nSo if you need to get detailed info about the plan, I suggest parsing the plan output.\nWhen you have a plan file, you can read it in JSON format and parse it. Here is a code snippet that illustrates that:\n terraform show -json plan.file| jq -r '([.resource_changes[]?.change.actions?]|flatten)|{\"create\":(map(select(.==\"create\"))|length),\"update\":(map(select(.==\"update\"))|length),\"delete\":(map(select(.==\"delete\"))|length)}' {  \"create\": 1,  \"update\": 0,  \"delete\": 0 } Another way to see the information about changes, is to run the plan command with -json option and parse its output to stdout (available starting from Terraform 1.0.5):\n terraform plan -json|jq 'select( .type == \"change_summary\")|.\"@message\"' \"Plan: 1 to add, 0 to change, 0 to destroy.\" This technique can make your Pull Request messages more informative and improve your collaboration with teammates.  You can write a custom script/function that sends a Pull Request comment to VCS using its API. Or you can try the existing features of your VCS: with GitHub Actions, you can use the Terraform PR Commenter or similar action to achieve that; for GitLab, there is a built-in functionality that integrates plan results into the Merge Request — Terraform integration in Merge Requests.\nYou can find more information about the specification of the JSON output here — Terraform JSON Output Format.\nApply When the plan file is ready, and the proposed changes are expected and approved, it’s time to apply them.\nHere is how the apply command may look like in automation:\nterraform apply -input=false -compact-warnings plan.file Here, the plan.file is the file we got from the previous plan step.\nAlternatively, you might want to omit the planning phase at all. In that case, the following command will apply the configuration immediately, without the need for a plan:\nterraform apply -input=false -compact-warnings -auto-approve Here, the -auto-approve option tells Terraform to create the plan implicitly and skip the interactive approval of that plan before applying.\nWhichever way you choose, keep in mind the destructive nature of the apply command. Hence, the fully automated apply of configuration generally works well with environments that tolerate unexpected downtimes, such as development or testing. Whereas plan review is recommended for production-grade environments, and in that case, the apply job is configured for a manual trigger.\nDealing with stateless environments If you run init, plan, and apply commands in different environments, you need to care for some artifacts produced by Terraform:\n The .terraform directory with information about modules, providers, and the state file (even in the case of remote state). The .terraform.lock.hcl file — the dependency lock file which Terraform uses to check the integrity of provider versions used for the project. If your VCS does not track it, you’ll need to pass that file to the plan and apply commands to make them work after init. The output file of the plan command is essential for the apply command, so treat it as a vital artifact. This file includes a full copy of the project configuration, the state, and variables passed to the plan command (if any). Therefore, mind the security precautions because sensitive information may be present there.  There is one shortcut, though. You can execute the init and plan commands within the same step/stage and transfer the artifacts only once — to the apply execution.\nUsing the command-line and environments variables Last but not least, a few words about ways to maximize the advantage of variables when running Terraform in CI.\nThere are two common ways how you can pass values for the variables used in the configuration:\n Using a -var-file option with the variable definitions file — a filename ending in .tfvars or .tfvars.json. For example: terraform apply -var-file=development.tfvars -input=false -no-color -compact-warnings -auto-approve Also, Terraform can automatically load the variables from files named exactly terraform.tfvars or terraform.tfvars.json: with that approach, you don’t need to specify the tfvar file as a command option explicitly. Using environment variables with the prefix TF_VAR_. Implicitly, Terraform always looks for the environment variables (within its process context) with that prefix, so the same “instance_type” variables from the example above can be passed as follows: export TF_VAR_instance_type=t3.nano terraform -input=false -no-color -compact-warnings -auto-approve   The latter method is widely used in CI because modern CI/CD tools support the management of the environment variables for automation jobs.\nPlease refer to the following official documentation if you want to know more about variables — Terraform Input Variables.\nAlong with that, Terraform supports several configuration parameters in the form of environment variables. These parameters are optional; however, they can simplify the automation management and streamline its code.\n TF_INPUT — when set to “false” or “0”, this tells Terraform to behave the same way as with the -input=false flag; TF_CLI_ARGS — can contain a set of command-line options that will be passed to one or another Terraform command. Therefore, the following notation can simplify the execution of apply and plan commands by unifying their options for CI: export TF_CLI_ARGS=\"-input=false -no-color -compact-warnings\" terraform plan ... terraform apply ... You can advantage this even more when using this variable as the environment configuration of stages or jobs in a CI/CD tool. TF_IN_AUTOMATION — when set to any non-empty value (e.g., “true”), Terraform stops suggesting commands run after the one you execute, hence producing less output.  Key takeaways There are two primary outcomes from automating Terraform executions: consistent results and integrating with the code or project management solutions. Although the exact implementation of Terraform in CI may vary per project or team, try to aim the following goals when working on it:\n Ease of code management A secure and controlled execution environment Coherent runs of init, plan, apply phases Leveraging of built-in Terraform capabilities  I originally wrote this article for the Spacelift.io technical blog. But I decided to keep it here as well, for the history. The canonical link to their blog has been set accordingly. ","wordCount":"2264","inLanguage":"en","image":"https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/cover-image.png","datePublished":"2021-11-24T22:20:45+02:00","dateModified":"2022-01-20T16:19:51+02:00","author":{"@type":"Person","name":"Serhii Vasylenko"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/"},"publisher":{"@type":"Person","name":"devDosvid — my engineering experience","logo":{"@type":"ImageObject","url":"https://devdosvid.blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://devdosvid.blog accesskey=h title="🏠 Home (Alt + H)">🏠 Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://devdosvid.blog/index.xml title="RSS Feed"><span>RSS Feed</span></a></li><li><a href=https://devdosvid.blog/archive title="All posts"><span>All posts</span></a></li><li><a href=https://devdosvid.blog/about/ title="About me"><span>About me</span></a></li><li><a href=https://devdosvid.blog/cv/ title="My CV"><span>My CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://devdosvid.blog>Home</a>&nbsp;»&nbsp;<a href=https://devdosvid.blog/posts/>Posts</a></div><h1 class=post-title>Guide to Using Terraform in CI/CD</h1><div class=post-description>How to configure, how to run, and what to mind for when using Terraform in CI/CD</div><div class=post-meta><span title="2021-11-24 22:20:45 +0200 +0200">November 24, 2021</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2264 words&nbsp;·&nbsp;Serhii Vasylenko&nbsp;|&nbsp;<a href=mailto:contact@devdosvid.blog rel="noopener noreferrer" target=_blank>📩 Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy srcset="https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/cover-image_hu936efe48bd11ed6f1abd12862168c743_32042_360x0_resize_box_3.png 360w ,https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/cover-image_hu936efe48bd11ed6f1abd12862168c743_32042_480x0_resize_box_3.png 480w ,https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/cover-image_hu936efe48bd11ed6f1abd12862168c743_32042_720x0_resize_box_3.png 720w ,https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/cover-image_hu936efe48bd11ed6f1abd12862168c743_32042_1080x0_resize_box_3.png 1080w ,https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/cover-image.png 1200w" sizes="(min-width: 768px) 720px, 100vw" src=https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/cover-image.png alt width=1200 height=600></figure><div class=post-content><p>Terraform by itself automates a lot of things: it creates, changes, and versions your cloud resources. Although many teams run Terraform locally (sometimes with wrapper scripts), running Terraform in CI/CD can boost the organization&rsquo;s performance and ensure consistent deployments.</p><p>In this article, I would like to review different approaches to integrating Terraform into generic deployment pipelines.</p><h1 id=where-to-store-the-terraform-code>Where to store the Terraform code<a hidden class=anchor aria-hidden=true href=#where-to-store-the-terraform-code>#</a></h1><p>Storing Terraform code in the same repository as the application code or maintaining a separate repository for the infrastructure?</p><p>This question has no strict and clear answer, but here are some insights that may help you decide:</p><ul><li>The Terraform and application code coupled together represent one unit, so it&rsquo;s simple to maintain by one team;</li><li>Conversely, if you have a dedicated team that manages infrastructure (e.g., platform team), a separate repository for infrastructure is more convenient because it&rsquo;s a standalone project in that case.</li><li>When infrastructure code is stored with the application, sometimes you have to deal with additional rules for the pipeline to separate triggers for these code parts. But sometimes (e.g., serverless apps) changes to either part (app/infra) should trigger the deployment.</li></ul><div class=attention>There is no right or wrong approach, but whichever you choose, remember to follow the <strong>Don’t Repeat Yourself (DRY)</strong> principle: make the infrastructure code modular by logically grouping resources into higher abstractions and reusing these modules.</div><h1 id=preparing-terraform-execution-environment>Preparing Terraform execution environment<a hidden class=anchor aria-hidden=true href=#preparing-terraform-execution-environment>#</a></h1><p>Running Terraform locally generally means that all dependencies are already in-place: you have the binary installed and present in the user&rsquo;s <code>PATH</code> and perhaps even some providers already stored in the <code>.terraform</code> directory.</p><p>But when you shift Terraform runs from your local machine to stateless pipelines, this is not the case. However, you can still have a pre-built environment — this will speed up the pipeline execution and provide control over the process.</p><p>Docker image with a Terraform binary is one of the popular solutions that address this. Once created, you can execute Terraform within a container context with configuration files mounted as a Docker volume.</p><p>You can use the official <a href=https://hub.docker.com/r/hashicorp/terraform/>image from Hashicorp</a>, but sometimes it makes sense to maintain your own Docker images with additional tools you may need. For instance, you can bake the <code>tfsec</code> tool into the image to use it for security inspection and have it ready inside the Docker container without the need to install it every time.</p><p>Here is an example of a Dockerfile that builds an image with a custom Terraform version (you can override it as a build argument) and a <code>tfsec</code> tool. This example also shows how to verify the installed Terraform binary to make sure it&rsquo;s signed by HashiCorp before we run it.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#6ab825;font-weight:700>FROM</span><span style=color:#ed9d13> alpine:3.14</span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#6ab825;font-weight:700>ARG</span> <span style=color:#40ffff>TERRAFORM_VERSION</span>=<span style=color:#3677a9>1</span>.0.11<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#6ab825;font-weight:700>ARG</span> <span style=color:#40ffff>TFSEC_VERSION</span>=<span style=color:#3677a9>0</span>.59.0<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#6ab825;font-weight:700>RUN</span> apk add --no-cache --virtual .sig-check gnupg<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#6ab825;font-weight:700>RUN</span> wget -O /usr/bin/tfsec https://github.com/aquasecurity/tfsec/releases/download/v<span style=color:#ed9d13>${</span><span style=color:#40ffff>TFSEC_VERSION</span><span style=color:#ed9d13>}</span>/tfsec-linux-amd64 <span style=color:#ed9d13>\
</span></span></span><span style=display:flex><span><span style=color:#ed9d13></span>    &amp;&amp; chmod +x /usr/bin/tfsec<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#6ab825;font-weight:700>RUN</span> <span style=color:#24909d>cd</span> /tmp <span style=color:#ed9d13>\
</span></span></span><span style=display:flex><span><span style=color:#ed9d13></span>    &amp;&amp; wget <span style=color:#ed9d13>&#34;https://releases.hashicorp.com/terraform/</span><span style=color:#ed9d13>${</span><span style=color:#40ffff>TERRAFORM_VERSION</span><span style=color:#ed9d13>}</span><span style=color:#ed9d13>/terraform_</span><span style=color:#ed9d13>${</span><span style=color:#40ffff>TERRAFORM_VERSION</span><span style=color:#ed9d13>}</span><span style=color:#ed9d13>_linux_amd64.zip&#34;</span> <span style=color:#ed9d13>\
</span></span></span><span style=display:flex><span><span style=color:#ed9d13></span>    &amp;&amp; wget https://keybase.io/hashicorp/pgp_keys.asc <span style=color:#ed9d13>\
</span></span></span><span style=display:flex><span><span style=color:#ed9d13></span>    &amp;&amp; gpg --import pgp_keys.asc <span style=color:#ed9d13>\
</span></span></span><span style=display:flex><span><span style=color:#ed9d13></span>    &amp;&amp; gpg --fingerprint --list-signatures <span style=color:#ed9d13>&#34;HashiCorp Security&#34;</span> | grep -q <span style=color:#ed9d13>&#34;C874 011F 0AB4 0511 0D02  1055 3436 5D94 72D7 468F&#34;</span> || <span style=color:#24909d>exit</span> <span style=color:#3677a9>1</span> <span style=color:#ed9d13>\
</span></span></span><span style=display:flex><span><span style=color:#ed9d13></span>    &amp;&amp; gpg --fingerprint --list-signatures <span style=color:#ed9d13>&#34;HashiCorp Security&#34;</span> | grep -q <span style=color:#ed9d13>&#34;34365D9472D7468F&#34;</span> || <span style=color:#24909d>exit</span> <span style=color:#3677a9>1</span> <span style=color:#ed9d13>\
</span></span></span><span style=display:flex><span><span style=color:#ed9d13></span>    &amp;&amp; wget https://releases.hashicorp.com/terraform/<span style=color:#ed9d13>${</span><span style=color:#40ffff>TERRAFORM_VERSION</span><span style=color:#ed9d13>}</span>/terraform_<span style=color:#ed9d13>${</span><span style=color:#40ffff>TERRAFORM_VERSION</span><span style=color:#ed9d13>}</span>_SHA256SUMS <span style=color:#ed9d13>\
</span></span></span><span style=display:flex><span><span style=color:#ed9d13></span>    &amp;&amp; wget https://releases.hashicorp.com/terraform/<span style=color:#ed9d13>${</span><span style=color:#40ffff>TERRAFORM_VERSION</span><span style=color:#ed9d13>}</span>/terraform_<span style=color:#ed9d13>${</span><span style=color:#40ffff>TERRAFORM_VERSION</span><span style=color:#ed9d13>}</span>_SHA256SUMS.sig <span style=color:#ed9d13>\
</span></span></span><span style=display:flex><span><span style=color:#ed9d13></span>    &amp;&amp; gpg --verify terraform_<span style=color:#ed9d13>${</span><span style=color:#40ffff>TERRAFORM_VERSION</span><span style=color:#ed9d13>}</span>_SHA256SUMS.sig terraform_<span style=color:#ed9d13>${</span><span style=color:#40ffff>TERRAFORM_VERSION</span><span style=color:#ed9d13>}</span>_SHA256SUMS || <span style=color:#24909d>exit</span> <span style=color:#3677a9>1</span> <span style=color:#ed9d13>\
</span></span></span><span style=display:flex><span><span style=color:#ed9d13></span>    &amp;&amp; sha256sum -c terraform_<span style=color:#ed9d13>${</span><span style=color:#40ffff>TERRAFORM_VERSION</span><span style=color:#ed9d13>}</span>_SHA256SUMS 2&gt;&amp;<span style=color:#3677a9>1</span> | grep -q <span style=color:#ed9d13>&#34;terraform_</span><span style=color:#ed9d13>${</span><span style=color:#40ffff>TERRAFORM_VERSION</span><span style=color:#ed9d13>}</span><span style=color:#ed9d13>_linux_amd64.zip: OK&#34;</span> || <span style=color:#24909d>exit</span> <span style=color:#3677a9>1</span> <span style=color:#ed9d13>\
</span></span></span><span style=display:flex><span><span style=color:#ed9d13></span>    &amp;&amp; unzip terraform_<span style=color:#ed9d13>${</span><span style=color:#40ffff>TERRAFORM_VERSION</span><span style=color:#ed9d13>}</span>_linux_amd64.zip -d /bin <span style=color:#ed9d13>\
</span></span></span><span style=display:flex><span><span style=color:#ed9d13></span>    &amp;&amp; rm -rf /tmp/* &amp;&amp; apk del .sig-check<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>But the main functionality of Terraform is delivered by provider plugins. It takes time to download the provider: for example, the AWS provider is about 250MB, and in a large scale, with hundreds of Terraform runs per day, this makes a difference.</p><p>There are two common ways to deal with it: either use a shared cache available to your pipeline workloads or bake provider binaries into the runtime environment (i.e., Docker image).</p><p>The critical element for both approaches is the configuration of the plugin cache directory path. By default, Terraform looks for plugins and downloads them in the <code>.terraform</code> directory, which is local to the main project directory. But you can override this, and you can leverage the <code>TF_PLUGIN_CACHE_DIR</code> environment variable to do that.</p><p>If supported by your CI/CD tool, the shared cache can significantly reduce the operational burden because all your pipeline runtime environments can use it to get the needed provider versions.</p><p>So all you have to do is to maintain the provider versions in the shared cache and instruct Terraform to use it:</p><ul><li>Mount the cache directory to the pipeline runtime (i.e., docker container) and specify its internal path</li><li>Set the value of the <code>TF_PLUGIN_CACHE_DIR</code> environment variable accordingly</li></ul><p>On the other hand, you can bake the provider binaries into the Docker image and inject the value for the <code>TF_PLUGIN_CACHE_DIR</code> environment variable right into the Dockerfile.</p><div class=attention>This approach takes more operational effort <strong>but makes the Terraform environment self-sufficient and stateless</strong>. It also allows you to set strict boundaries around permitted provider versions as a security measure.</div><h1 id=planning-and-applying-changes>Planning and Applying changes<a hidden class=anchor aria-hidden=true href=#planning-and-applying-changes>#</a></h1><p>Now let&rsquo;s review the ways to automate planning and applying of changes. Although <code>terraform apply</code> can do both, it&rsquo;s sometimes useful to separate these actions.</p><h2 id=initialization>Initialization<a hidden class=anchor aria-hidden=true href=#initialization>#</a></h2><p>CI/CD pipelines generally run in stateless environments. Thus, every subsequent run of Terraform looks like a fresh start, so the project needs to be initialized before other actions can be performed.</p><p>The usage of the <code>init</code> command in CI/CD slightly differs from its common local usage:</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; terraform init -input=<span style=color:#24909d>false</span>
</span></span></code></pre></div><p>The <code>-input=false</code> option prevents Terraform CLI from asking for user actions (it will throw an error if the input was required).</p><p><em>Also, there is <code>-no-color</code> option that prevents the usage of color codes in a shell, so the output will look much cleaner if your CI/CD logging system cannot render the terminal formatting.</em></p><p>Another option of the init command that is useful in CI — is the <code>-backend-config</code>. That option allows you to override the backend configuration in your code or define it if you prefer to use partial configuration, thus creating more uniform pipelines.</p><p>For example, here is how you can use the same code with different roles in different environments on AWS:</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; terraform init -input=<span style=color:#24909d>false</span> <span style=color:#ed9d13>\
</span></span></span><span style=display:flex><span><span style=color:#ed9d13></span>-backend-config=<span style=color:#ed9d13>&#34;role_arn=arn:aws:iam::012345678901:role/QADeploymentAutomation&#34;</span>
</span></span></code></pre></div><p>Terraform <code>init</code> produces two artifacts:</p><ul><li><code>.terraform</code> directory, which Terraform uses to manage cached provider plugins and modules, and record backend information</li><li><code>.terraform.lock.hcl</code> file, which Terraform uses to track provider dependencies</li></ul><p>They both must be present in the project directory to successfully run the subsequent plan and apply commands.</p><p>However, I suggest checking in <code>.terraform.lock.hcl</code> to your repository as suggested by HashiCorp (<a href=https://www.terraform.io/docs/language/dependency-lock.html>Dependency Lock File</a>): this way you will be able to control dependencies more thoroughly, and you will not worry about transferring this file between build stages.</p><h2 id=plan>Plan<a hidden class=anchor aria-hidden=true href=#plan>#</a></h2><p>The <code>terraform plan</code> command helps you validate the changes manually. However, there are ways to use it in automation as well.</p><p>By default, Terraform prints the plan output in a human-friendly format but also supports machine-readable JSON. With additional command-line options, you can extend your CI experience.</p><p>For example, you can use your validation conditions to decide whether to apply the changes automatically; or you can parse the plan details and integrate the summary into a Pull Request description. Let’s review a simple example that illustrates it.</p><p>First, you need to save the plan output to the file:</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; terraform plan -input=<span style=color:#24909d>false</span> -compact-warnings -out=plan.file
</span></span></code></pre></div><p>The main point here is the <code>-out</code> option — it tells Terraform to save its output into a binary plan file, and we will talk about it in the next paragraph.</p><p>The <code>-compact-warnings</code> option suppresses the warning-level messages produced by Terraform.</p><p>Also, the <code>plan</code> command has the <code>-detailed-exitcode</code> option that returns detailed exit codes when the command exits. For example, you can leverage this in a script that wraps Terraform and adds more conditional logic to its execution, because CIs will generally fail the pipeline on a command’s non-zero exit code. However, that may add complexity to the pipeline logic.</p><p>So if you need to get detailed info about the plan, I suggest parsing the plan output.</p><p>When you have a plan file, you can read it in JSON format and parse it. Here is a code snippet that illustrates that:</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; terraform show -json plan.file| jq -r <span style=color:#ed9d13>&#39;([.resource_changes[]?.change.actions?]|flatten)|{&#34;create&#34;:(map(select(.==&#34;create&#34;))|length),&#34;update&#34;:(map(select(.==&#34;update&#34;))|length),&#34;delete&#34;:(map(select(.==&#34;delete&#34;))|length)}&#39;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#ed9d13>&#34;create&#34;</span>: 1,
</span></span><span style=display:flex><span>  <span style=color:#ed9d13>&#34;update&#34;</span>: 0,
</span></span><span style=display:flex><span>  <span style=color:#ed9d13>&#34;delete&#34;</span>: <span style=color:#3677a9>0</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Another way to see the information about changes, is to run the <code>plan</code> command with <code>-json</code> option and parse its output to stdout (available starting from Terraform 1.0.5):</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; terraform plan -json|jq <span style=color:#ed9d13>&#39;select( .type == &#34;change_summary&#34;)|.&#34;@message&#34;&#39;</span>
</span></span><span style=display:flex><span><span style=color:#ed9d13>&#34;Plan: 1 to add, 0 to change, 0 to destroy.&#34;</span>
</span></span></code></pre></div><p><div class=attention>This technique can make your Pull Request messages more informative and improve your collaboration with teammates.</div>You can write a custom script/function that sends a Pull Request comment to VCS using its API. Or you can try the existing features of your VCS: with GitHub Actions, you can use the <a href=https://github.com/marketplace/actions/terraform-pr-commenter>Terraform PR Commenter</a> or similar action to achieve that; for GitLab, there is a built-in functionality that integrates plan results into the Merge Request — <a href=https://docs.gitlab.com/ee/user/infrastructure/iac/mr_integration.html>Terraform integration in Merge Requests</a>.</p><p>You can find more information about the specification of the JSON output here — <a href=https://www.terraform.io/docs/internals/json-format.html>Terraform JSON Output Format</a>.</p><h2 id=apply>Apply<a hidden class=anchor aria-hidden=true href=#apply>#</a></h2><p>When the plan file is ready, and the proposed changes are expected and approved, it&rsquo;s time to <code>apply</code> them.</p><p>Here is how the <code>apply</code> command may look like in automation:</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>terraform apply -input=<span style=color:#24909d>false</span> -compact-warnings plan.file
</span></span></code></pre></div><p>Here, the <code>plan.file</code> is the file we got from the previous plan step.</p><p>Alternatively, you might want to omit the planning phase at all. In that case, the following command will apply the configuration immediately, without the need for a plan:</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>terraform apply -input=<span style=color:#24909d>false</span> -compact-warnings -auto-approve
</span></span></code></pre></div><p>Here, the <code>-auto-approve</code> option tells Terraform to create the plan implicitly and skip the interactive approval of that plan before applying.</p><p>Whichever way you choose, keep in mind the destructive nature of the apply command. Hence, the fully automated apply of configuration generally works well with environments that tolerate unexpected downtimes, such as development or testing. Whereas plan review is recommended for production-grade environments, and in that case, the <code>apply</code> job is configured for a manual trigger.</p><h1 id=dealing-with-stateless-environments>Dealing with stateless environments<a hidden class=anchor aria-hidden=true href=#dealing-with-stateless-environments>#</a></h1><p>If you run <code>init</code>, <code>plan</code>, and <code>apply</code> commands in different environments, you need to care for some artifacts produced by Terraform:</p><ul><li>The <code>.terraform</code> directory with information about modules, providers, and the state file (even in the case of remote state).</li><li>The <code>.terraform.lock.hcl</code> file — the dependency lock file which Terraform uses to check the integrity of provider versions used for the project. If your VCS does not track it, you&rsquo;ll need to pass that file to the <code>plan</code> and <code>apply</code> commands to make them work after <code>init</code>.</li><li>The output file of the <code>plan</code> command is essential for the <code>apply</code> command, so treat it as a vital artifact. This file includes a full copy of the project configuration, the state, and variables passed to the <code>plan</code> command (if any). Therefore, mind the security precautions because sensitive information may be present there.</li></ul><p>There is one shortcut, though. You can execute the <code>init</code> and <code>plan</code> commands within the same step/stage and transfer the artifacts only once — to the <code>apply</code> execution.</p><h1 id=using-the-command-line-and-environments-variables>Using the command-line and environments variables<a hidden class=anchor aria-hidden=true href=#using-the-command-line-and-environments-variables>#</a></h1><p>Last but not least, a few words about ways to maximize the advantage of variables when running Terraform in CI.</p><p>There are two common ways how you can pass values for the variables used in the configuration:</p><ol><li>Using a <code>-var-file</code> option with the variable definitions file — a filename ending in <code>.tfvars</code> or <code>.tfvars.json</code>. For example:<div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>terraform apply -var-file=development.tfvars -input=<span style=color:#24909d>false</span> -no-color -compact-warnings -auto-approve
</span></span></code></pre></div>Also, Terraform can automatically load the variables from files named exactly <code>terraform.tfvars</code> or <code>terraform.tfvars.json</code>: with that approach, you don’t need to specify the tfvar file as a command option explicitly.</li><li>Using environment variables with the prefix <code>TF_VAR_</code>. Implicitly, Terraform always looks for the environment variables (within its process context) with that prefix, so the same &ldquo;instance_type&rdquo; variables from the example above can be passed as follows:<div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#24909d>export</span> <span style=color:#40ffff>TF_VAR_instance_type</span>=t3.nano
</span></span><span style=display:flex><span>terraform -input=<span style=color:#24909d>false</span> -no-color -compact-warnings -auto-approve
</span></span></code></pre></div></li></ol><p>The latter method is widely used in CI because modern CI/CD tools support the management of the environment variables for automation jobs.</p><p>Please refer to the following official documentation if you want to know more about variables — <a href=https://www.terraform.io/docs/language/values/variables.html>Terraform Input Variables</a>.</p><p>Along with that, Terraform supports several configuration parameters in the form of environment variables. These parameters are optional; however, they can simplify the automation management and streamline its code.</p><ul><li><code>TF_INPUT</code> — when set to &ldquo;false&rdquo; or &ldquo;0&rdquo;, this tells Terraform to behave the same way as with the <code>-input=false</code> flag;</li><li><code>TF_CLI_ARGS</code> — can contain a set of command-line options that will be passed to one or another Terraform command. Therefore, the following notation can simplify the execution of <code>apply</code> and <code>plan</code> commands by unifying their options for CI:<div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#24909d>export</span> <span style=color:#40ffff>TF_CLI_ARGS</span>=<span style=color:#ed9d13>&#34;-input=false -no-color -compact-warnings&#34;</span>
</span></span><span style=display:flex><span>terraform plan ...
</span></span><span style=display:flex><span>terraform apply ...
</span></span></code></pre></div>You can advantage this even more when using this variable as the environment configuration of stages or jobs in a CI/CD tool.</li><li><code>TF_IN_AUTOMATION</code> — when set to any non-empty value (e.g., &ldquo;true&rdquo;), Terraform stops suggesting commands run after the one you execute, hence producing less output.</li></ul><h1 id=key-takeaways>Key takeaways<a hidden class=anchor aria-hidden=true href=#key-takeaways>#</a></h1><p>There are two primary outcomes from automating Terraform executions: consistent results and integrating with the code or project management solutions. Although the exact implementation of Terraform in CI may vary per project or team, try to aim the following goals when working on it:</p><ul><li>Ease of code management</li><li>A secure and controlled execution environment</li><li>Coherent runs of init, plan, apply phases</li><li>Leveraging of built-in Terraform capabilities</li></ul><h5 id=i-originally-wrote-this-article-for-the-spaceliftio-technical-blog-but-i-decided-to-keep-it-here-as-well-for-the-history-the-canonical-link-to-their-blog-has-been-set-accordingly>I originally wrote this article for the Spacelift.io technical blog. But I decided to keep it here as well, for the history. The canonical link to their blog has been set accordingly.<a hidden class=anchor aria-hidden=true href=#i-originally-wrote-this-article-for-the-spaceliftio-technical-blog-but-i-decided-to-keep-it-here-as-well-for-the-history-the-canonical-link-to-their-blog-has-been-set-accordingly>#</a></h5></div><footer class=post-footer><div class="sp-form-outer sp-force-hide"><div id=sp-form-211745 sp-id=211745 sp-hash=9ef750f82b8d5e11b34ea23df27756cb738d703108d46ebff940b44ce4757404 sp-lang=en class="sp-form sp-form-regular sp-form-embed" sp-show-options=%7B%22satellite%22%3Afalse%2C%22maDomain%22%3A%22login.sendpulse.com%22%2C%22formsDomain%22%3A%22forms.sendpulse.com%22%2C%22condition%22%3A%22onEnter%22%2C%22scrollTo%22%3A25%2C%22delay%22%3A10%2C%22repeat%22%3A3%2C%22background%22%3A%22rgba(0%2C%200%2C%200%2C%200.5)%22%2C%22position%22%3A%22bottom-right%22%2C%22animation%22%3A%22%22%2C%22hideOnMobile%22%3Afalse%2C%22urlFilter%22%3Afalse%2C%22urlFilterConditions%22%3A%5B%7B%22force%22%3A%22hide%22%2C%22clause%22%3A%22contains%22%2C%22token%22%3A%22%22%7D%5D%2C%22analytics%22%3A%7B%22ga%22%3A%7B%22eventLabel%22%3A%22Subscription_form_devDosvid%22%2C%22send%22%3Afalse%7D%2C%22ym%22%3A%7B%22counterId%22%3Anull%2C%22eventLabel%22%3Anull%2C%22targetId%22%3Anull%2C%22send%22%3Afalse%7D%7D%2C%22utmEnable%22%3Afalse%7D><div class=sp-form-fields-wrapper><div class=sp-message><div></div></div><form novalidate class=sp-element-container><div class="sp-field sp-field-full-width-add sp-field-full-width sp-field-full-width-add-active" sp-id=sp-d7ac453c-4371-4ac2-94ad-209ba95924ce data-><div><h3>Subscribe to be notified about blog updates!</h3></div></div><div class=sp-field sp-id=sp-07c6298b-0a1a-4417-b7d9-b2205b910fc7><label class=sp-control-label><span>Email</span><strong>*</strong></label><input type=email sp-type=email name=sform[email] class=sp-form-control placeholder=username@example.com sp-tips=%7B%22required%22%3A%22Required%20field%22%2C%22wrong%22%3A%22Wrong%20email%22%7D autocomplete=on required></div><div class="sp-field sp-button-container" sp-id=sp-92706abe-5113-4db0-b255-c64ad75a46f7><button id=sp-92706abe-5113-4db0-b255-c64ad75a46f7 class=sp-button>Subscribe</button></div></form></div></div></div><script type=text/javascript async src=//web.webformscr.com/apps/fc3/build/default-handler.js?1651223786960></script><div class=post-series><p>Check out other posts of the <b>"Terraform Proficiency"</b> series:</p><ul><li><a href="https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/?utm_blogseries=terraform-proficiency">New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2</a></li><li><a href="https://devdosvid.blog/2022/01/16/some-techniques-to-enhance-your-terraform-proficiency/?utm_blogseries=terraform-proficiency">Some Techniques to Enhance Your Terraform Proficiency</a></li><li style=opacity:.75>Guide to Using Terraform in CI/CD</li><li><a href="https://devdosvid.blog/2020/08/25/terraform-cli-shortcuts/?utm_blogseries=terraform-proficiency">Terraform CLI shortcuts</a></li></ul></div><ul class=post-tags></ul><div class=license><p>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nd/4.0/>Creative Commons Attribution-NoDerivatives 4.0 International License</a></p></div><nav class=paginav><a class=prev href=https://devdosvid.blog/2022/01/16/some-techniques-to-enhance-your-terraform-proficiency/><span class=title>« Prev Page</span><br><span>Some Techniques to Enhance Your Terraform Proficiency</span></a>
<a class=next href=https://devdosvid.blog/2021/11/05/apply-cloudfront-security-headers-with-terraform/><span class=title>Next Page »</span><br><span>Apply Cloudfront Security Headers With Terraform</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://devdosvid.blog>devDosvid — my engineering experience</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>