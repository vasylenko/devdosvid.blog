<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Mastering AWS API Gateway V2 HTTP and AWS Lambda With Terraform | devDosvid blog</title>
<meta name=keywords content="AWS API Gateway V2,Serverless Architecture,AWS Lambda Functions,Terraform Automation,Cloud Computing,Infrastructure as Code,Cost-Efficient Cloud Services,Lambda Authorizer,API Gateway Integration"><meta name=description content="The article provides insights into using AWS API Gateway and AWS Lambda with Terraform for efficient, cost-effective serverless solutions."><meta name=author content="Serhii Vasylenko"><link rel=canonical href=https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/><link crossorigin=anonymous href=/assets/css/stylesheet.5646840c6f09d9c80952a9aac690950f7d6243912ac8bdf52882c5d1990edd8c.css integrity="sha256-VkaEDG8J2cgJUqmqxpCVD31iQ5EqyL31KILF0ZkO3Yw=" rel="preload stylesheet" as=style><link rel=icon href=https://devdosvid.blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://devdosvid.blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://devdosvid.blog/favicon-32x32.png><link rel=apple-touch-icon href=https://devdosvid.blog/apple-touch-icon.png><link rel=mask-icon href=https://devdosvid.blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><style>@font-face{font-family:albert sans;font-style:normal;font-display:swap;font-weight:300;src:url(/assets/fonts/AlbertSans-Light.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:italic;font-display:swap;font-weight:300;src:url(/assets/fonts/AlbertSans-LightItalic.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:normal;font-display:swap;font-weight:400;src:url(/assets/fonts/AlbertSans-Regular.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:italic;font-display:swap;font-weight:400;src:url(/assets/fonts/AlbertSans-Italic.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:normal;font-display:swap;font-weight:500;src:url(/assets/fonts/AlbertSans-Medium.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:italic;font-display:swap;font-weight:500;src:url(/assets/fonts/AlbertSans-MediumItalic.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:normal;font-display:swap;font-weight:600;src:url(/assets/fonts/AlbertSans-SemiBold.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:italic;font-display:swap;font-weight:600;src:url(/assets/fonts/AlbertSans-SemiBoldItalic.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style><meta name=twitter:creator content="@vasylenko"><meta name=twitter:site content="@vasylenko"><script async src=https://scripts.simpleanalyticscdn.com/latest.js></script><meta property="og:url" content="https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/"><meta property="og:site_name" content="devDosvid blog"><meta property="og:title" content="Mastering AWS API Gateway V2 HTTP and AWS Lambda With Terraform"><meta property="og:description" content="The article provides insights into using AWS API Gateway and AWS Lambda with Terraform for efficient, cost-effective serverless solutions."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-09T03:33:10+01:00"><meta property="article:modified_time" content="2025-02-09T18:58:16+01:00"><meta property="og:image" content="https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/cover-image.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/cover-image.jpg"><meta name=twitter:title content="Mastering AWS API Gateway V2 HTTP and AWS Lambda With Terraform"><meta name=twitter:description content="The article provides insights into using AWS API Gateway and AWS Lambda with Terraform for efficient, cost-effective serverless solutions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://devdosvid.blog/posts/"},{"@type":"ListItem","position":2,"name":"Mastering AWS API Gateway V2 HTTP and AWS Lambda With Terraform","item":"https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Mastering AWS API Gateway V2 HTTP and AWS Lambda With Terraform","name":"Mastering AWS API Gateway V2 HTTP and AWS Lambda With Terraform","description":"The article provides insights into using AWS API Gateway and AWS Lambda with Terraform for efficient, cost-effective serverless solutions.","keywords":["AWS API Gateway V2","Serverless Architecture","AWS Lambda Functions","Terraform Automation","Cloud Computing","Infrastructure as Code","Cost-Efficient Cloud Services","Lambda Authorizer","API Gateway Integration"],"articleBody":"With a solid foundation in AWS API Gateway and Lambda for serverless architecture, my recent deep dive into these cloud computing services felt like uncovering new layers in familiar territory. This article aims to be a comprehensive guide for developers and DevOps professionals looking to master serverless solutions using AWS and Terraform.\nThe article provides an in-depth guide to combining AWS API Gateway V2 HTTP API (yes, this is the official name of that service üòÑ) and AWS Lambda services to implement a simple, robust, and cost-effective serverless back-end using Terraform.\nThe journey was enlightening and engaging, especially as I were transforming these services into Infrastructure as Code. Through this article, I aim to share those moments of insight and the practical, hands-on tips that emerged from weaving these AWS services into a seamless, serverless architecture.\nNavigating the System Design: HTTP API Gateway and Lambda in Action Beginning our journey, we examine the complexities of serverless architecture, focusing on HTTP API and Lambda. A comprehensive system diagram will guide us as we analyze each component‚Äôs function and their collaborative roles in the larger infrastructure.\nHTTP API Gateway and AWS Lambda flowchart In our architecture, the HTTP API delegates access control to the Lambda function called ‚ÄúAuthorizer‚Äù. This function stands as the gatekeeper, ensuring that only legitimate requests pass through to the underlying business logic.\nThe HTTP API can have multiple routes (e.g., ‚Äú/calendar,‚Äù ‚Äú/meters,‚Äù and so on) and use different Authorizers per route or a single one for all of them. Clients that send their requests to the API must include specific identification information in their request header or query string. In this project, I go with a single authorizer to keep it simple.\nUpon receiving a request, the API service forwards a payload to the Authorizer containing metadata about the request, such as headers and query string components. The Authorizer processes this metadata (headers, in my case) to determine the request‚Äôs legitimacy.\nThe decision, Allow or Deny, is passed back to the API, and if allowed, the API service then forwards the original request to the back-end, which, in this case, is implemented by additional Lambda functions. Otherwise, the client gets a response with a 403 status code, and the original request is not passed to the back-end.\nSubscribe to blog updates! Behind The Decision: Why Such a Setup? Choosing the right architectural setup is critical in balancing simplicity, cost-efficiency, and security. In this section, we uncover why integrating AWS HTTP API Gateway with Lambda Authorizer is a compelling choice, offering a streamlined approach without compromising security.\nCost-Effectiveness: Balancing Performance and Price The AWS HTTP API is noteworthy for its streamlined and simple design compared to other API Gateway options. That translates directly into cost savings for businesses. Its efficiency makes it an ideal choice for cost-effective serverless computing, especially for those looking to optimize their cloud infrastructure with Terraform automation. Here is a more detailed comparison of different API Gateway options ‚Äî Cost optimization.\nSecurity with Lambda Authorizer. This option means a Lambda function used for authorization, which is lean and efficient. It generally requires a bare minimum of resources. It executes quickly, particularly when configured with the ARM-based environment and 128M RAM allocation, costing $0,0000017 per second of running time, with $0.20 per 1M requests per month.\nüí∞ This pricing and performance combination are well-suited for rapid, lightweight authorizations. Together with AWS Lambda as a back-end, it makes a cost-effective solution. For example, if we add a few more Lambdas to back-end and assume that our setup receives 10000 requests per month, it would cost around $0.6 per month. Here is the link to detailed calculations ‚Äî AWS Pricing Calculator.\nSimplicity in Configuration: The Power of Header-Based Authorization A header-based authentication method facilitates straightforward client-server communication, often requiring less coding and resources to implement compared to more complex schemes.\nAlthough HTTP API offers stronger JWT-based authorization and mutual TLS authentication, header-based authorization remains a suitable choice for simpler applications that prioritize ease and quickness. By the way, there is also an option for IAM-based authorization whose core idea is the ‚Äúprivate API‚Äù or internal usage of the API (e.g., solely inside the VPC, no internet), but with ‚ÄúIAM Anywhere,‚Äù this can be expanded to practically anywhere. üòÅ\nThis architecture suits applications requiring rapid development and deployment without complex authorization mechanisms. It‚Äôs ideal for small to medium-sized serverless applications or specific use cases in larger systems where quick, cost-effective, and secure access to APIs is a priority.\nüí° Imagine a retail company wanting to manage its inventory efficiently. By leveraging AWS API Gateway and Lambda, they can develop a system where each item‚Äôs RFID tags are scanned and processed through an API endpoint. When a product is moved or sold, its status is updated in real-time in the database, facilitated by Lambda functions. This serverless architecture ensures high availability and scalability and significantly reduces operational costs, a crucial factor for the highly competitive retail industry. This example showcases how our serverless setup can be effectively utilized in retail for streamlined inventory tracking and management.\nExploring AWS Lambda: Features and Integration Diving into AWS Lambda, this section explores its features and indispensable role within the serverless infrastructure. We will unravel the complexities of Lambda functions and examine the practicalities of deploying and managing these functions within the project.\nAWS Lambda Runtime and Deployment Model üöÄ Choosing the AWS Lambda runtime arm64, combined with the OS-only runtime based on Amazon Linux 2023, strategically boosts cost efficiency and performance. This choice aligns with the best practices for serverless computing in AWS, offering an optimal solution for those seeking to leverage AWS services for scalable cloud solutions.\nParticularly effective for Go-based functions, this runtime configuration is lean yet powerful. For applications in other languages, delving into language-specific runtimes based on AL 2023 can also leverage the latest efficiencies of AWS-managed operating systems.\nI also welcome you to read this benchmarking analysis to get more insights about the ARM-based environment for AWS Lambda ‚Äî Comparing AWS Lambda Arm vs. x86 Performance, Cost, and Analysis. The .zip deployment model is chosen for its simplicity, avoiding additional management of the image registry (ECR) and Docker images. Also, AWS automatically patches .zip functions for the latest runtime security and bug fixes.\nEfficient Terraform Coding for AWS Lambda In our architecture, AWS Lambda functions serve dual purposes ‚Äî as an authentication gatekeeper and a robust back-end for business logic. Despite varying code across functions, their configurations share much of similarities.\nBy adhering to the DRY (Don‚Äôt Repeat Yourself) principle, I have crafted a Terraform module to streamline the management of Lambda functions and their dependencies. This approach ensures maintainable and scalable infrastructure. The module‚Äôs structure is as follows:\naws_lambda_function ‚Äî to describe the core configuration of the function aws_iam_role + aws_iam_role_policy + aws_iam_policy_document ‚Äî to manage the access from Lambda to other resources (e.g., SSM Parameter Store) aws_cloudwatch_log_group ‚Äî to keep the execution logs aws_ssm_parameter ‚Äî to store sensitive information (e.g., secrets) and other configurations that we should keep separate from the source code. This Terraform module implements a project-specific use case for Lambda functions. However, if you‚Äôre seeking for a generic all-in-one module for AWS Lambda, I recommend checking out this one ‚Äî Terraform AWS Lambda Module by Anton Babenko.\nTo efficiently develop Terraform code for Lambda functions, use the following techniques:\nUse local values, expressions, and variables to implement consistent naming across different resources logically grouped by a module or project; Use function environment variables to connect the code with SSM Parameter Store parameters or Secrets Manager secrets to protect sensitive data like tokens or credentials; Use for_each meta-argument and for expression to reduce the amount of code and automate the configuration for resources of the same type (e.g., ssm_parameter) or code blocks within a resource. Below is a practical example illustrating these Terraform strategies in action:\nlocals { full_function_name = \"${var.project_name}-${var.function_name}\" } resource \"aws_lambda_function\" \"this\" { function_name = local.full_function_name role = aws_iam_role.this.arn architectures = [\"arm64\"] filename = var.deployment_file package_type = \"Zip\" runtime = \"provided.al2023\" handler = \"bootstrap.handler\" timeout = var.function_timeout environment { variables = { for item in var.function_ssm_parameter_names : upper(replace(item, \"-\", \"_\")) =\u003e aws_ssm_parameter.function_ssm_parameters[item].name } } } resource \"aws_ssm_parameter\" \"function_ssm_parameters\" { for_each = var.function_ssm_parameter_names name = \"/projects/${var.project_name}/lambda/${var.function_name}/${each.value}\" type = \"SecureString\" key_id = data.aws_kms_alias.ssm.arn value = \"1\" lifecycle { ignore_changes = [ value, ] } } resource \"aws_cloudwatch_log_group\" \"this\" { name = \"/aws/lambda/${local.full_function_name}\" log_group_class = \"STANDARD\" retention_in_days = 7 } The complete terraform module code is available in the project repository.\nIn this Terraform code, I deliberately hardcoded specific arguments for an optimal Lambda runtime configuration, ensuring efficiency and performance.\nThen variables and local values, set only once, implement a naming convention for all resource arguments, making it easy to understand the infrastructure and change the naming and attributes later.\nLambda‚Äôs environment variables and corresponding SSM parameters coexist effectively with the help of for_each and for. I used the for_each meta-argument to dynamically create SSM Parameter resources and the for expression to configure environment variables in AWS Lambda. This also means that if the function_ssm_parameter_names variable value is not provided, then Terraform does not create either SSM parameter resources or the environment code block inside the Lambda resource because the default value of that variable is an empty set. By the way, I have another blog post that explains several techniques to enhance your Terraform proficiency ‚Äî check it out!\nInvoking Lambda: Permissions and Resource-Based Policies Configured with just a few input variables, the Terraform module efficiently outputs the aws_lambda_function resource. This streamlined output is then adeptly used to facilitate subsequent configurations within the HTTP API.\nmodule \"lambda_api_gw_authorizer\" { source = \"./modules/lambda\" deployment_file = \"../backend/lambda-apigw-authorizer/deployment.zip\" function_name = \"api-gateway-authorizer\" project_name = local.project_name function_ssm_parameters = [ \"authorization-token\" ] } module \"lambda_calendar_backend\" { source = \"./modules/lambda\" deployment_file = \"../backend/lambda-calendar-backend/deployment.zip\" function_name = \"calendar-backend\" project_name = local.project_name function_ssm_parameters = [ \"google-api-oauth-token\", \"google-api-credentials\" ] } As an example of module output usage, here is the configuration of aws_lambda_permissions resource that I use outside the AWS Lambda module to allow the HTTP API service to invoke the function used as Authorizer:\nresource \"aws_lambda_permission\" \"allow_api_gw_invoke_authorizer\" { statement_id = \"allowInvokeFromAPIGatewayAuthorizer\" action = \"lambda:InvokeFunction\" function_name = module.lambda_api_gw_authorizer.lambda.function_name principal = \"apigateway.amazonaws.com\" source_arn = \"${aws_apigatewayv2_api.this.execution_arn}/authorizers/${aws_apigatewayv2_authorizer.header_based_authorizer.id}\" } The Lambda resource-based policy combines the trust and permission policies, and provides a simple yet efficient way to grant other AWS services or principals the ability to invoke Lambda functions. It is important to note that for an API to invoke a function, Lambda requires its execution ARN, not the resource ARN. As a side note, check out this AWS Lambda Operator Guide, which offers specialized advice on developing, securing, and monitoring applications based on AWS Lambda.\nLet‚Äôs switch to the HTTP API part to see how it looks and learn how it integrates Lambda functions.\nDeep Dive into HTTP API Gateway Now, we focus on the HTTP API Gateway, delving into its essential concepts, seamless integration with AWS Lambda, and using Terraform efficiently for streamlined configuration.\nBut before we do that, and since we have partially covered the Terraform code already, I‚Äôd like to illustrate the logical connection between three main components of the project‚Äôs Terraform codebase: AWS Lambda, HTTP API, and API Routes.\nAWS Lambda and HTTP API Terraform integration diagram I will explain the API Route module in detail a bit later, but for now, for the broader context, here is what happens inside Terraform: AWS HTTP API code logically represents the ‚Äúglobal‚Äù (within a project) set of resources and uses the function created by the Lambda Terraform module for the Authorizer configuration. Meanwhile, the API Route Terraform module configures specific routes for the HTTP API (hence, requires some info from it) with integration to back-ends implemented by Lambdas (hence, requires some info from them, too).\nBack to HTTP API overview. The following components of the HTTP API constitute its backbone:\nRoute ‚Äî a combination of the HTTP method (e.g., GET or POST) with the API route (e.g., /meters). For example: ‚ÄúPOST /meters‚Äù. Routes can optionally use Authorizers ‚Äî a mechanism to control access to the HTTP API. Integration ‚Äî the technical and logical connection between the Route and one of the supported back-end resources. For example, with AWS Lambda integration, API Gateway sends the entire request as input to a back-end Lambda function and then transforms the Lambda function output to a front-end HTTP response. Stage and Deployment ‚Äî A stage serves as a designated reference to a deployment, essentially capturing a snapshot of the API at a certain point. It‚Äôs employed to control and optimize a specific deployment version. For instance, stage configurations can be adjusted to tailor request throttling, set up logging, or establish stage variables to be used by API (if needed). Implementing AWS API Gateway V2 HTTP API with Terraform Below, I detail the Terraform resources essential for implementing the HTTP API, ensuring a transparent and effective setup:\naws_apigatewayv2_api ‚Äî the HTTP API itself; aws_apigatewayv2_route ‚Äî the Route for the API that must specify the integration target (e.g., Lambda) and, optionally, the Authorizer; aws_apigatewayv2_authorizer ‚Äî the Authorizer to use for Routes; aws_apigatewayv2_integration ‚Äî the resource that specifies the back-end where the API sends the requests (e.g., AWS Lambda); aws_lambda_permission ‚Äî the resource-based policy for AWS Lambda to allow the invocations from the API; aws_apigatewayv2_stage ‚Äî the name of the Stage that references the Deployment. Applying Terraform for HTTP API Gateway and Lambda Authorizer The HTTP API is the simplest in the API Gateway family (so far), so its Terraform resource has relatively few configuration options, most of which can be left at their default values.\nAs for the Authorizer, it can have two options for letting API know its decision: simple response and IAM policy.\nThe simple response just returns a Boolean value to indicate whether the API should allow the request (True) or forbid it (False).\nThe IAM policy option is customizable and allows crafting custom policy statements that allow granular access to explicitly provided resources.\nIn this project, I follow the way of simplicity and use the ‚Äúsimple response‚Äù, so the response from Lambda Authorizer to HTTP API looks as follows:\n{ \"isAuthorized\": true/false } Let‚Äôs review the HTTP API resource along with the API Authorizer that I used for all routes:\nresource \"aws_apigatewayv2_api\" \"this\" { name = local.project_name protocol_type = \"HTTP\" } resource \"aws_apigatewayv2_authorizer\" \"header_based_authorizer\" { api_id = aws_apigatewayv2_api.this.id authorizer_type = \"REQUEST\" name = \"header-based-authorizer\" authorizer_payload_format_version = \"2.0\" authorizer_uri = module.lambda_api_gw_authorizer.lambda.invoke_arn enable_simple_responses = true identity_sources = [\"$request.header.authorization\"] authorizer_result_ttl_in_seconds = 3600 } resource \"aws_lambda_permission\" \"allow_api_gw_invoke_authorizer\" { statement_id = \"allowInvokeFromAPIGatewayAuthorizer\" action = \"lambda:InvokeFunction\" function_name = module.lambda_api_gw_authorizer.lambda.function_name principal = \"apigateway.amazonaws.com\" source_arn = \"${aws_apigatewayv2_api.this.execution_arn}/authorizers/${aws_apigatewayv2_authorizer.header_based_authorizer.id}\" } The complete code is available in the project repository.\nConsider the following key points when Terraforming this part.\nidentity_sources argument of the aws_apigatewayv2_authorizer resource: This is where I defined what exactly the Authorizer should validate. I used the header named authorization so the Authorizer Lambda function would check its value to decide whether to authorize the request.\nüí° Check out other options available to use as the identity source ‚Äî Identity sources.\nauthorizer_uri argument of the aws_apigatewayv2_authorizer resource: It is the invocation ARN of the Lambda function used as Authorizer (not the Lambda‚Äôs resource ARN).\nauthorizer_result_ttl_in_seconds argument of the aws_apigatewayv2_authorizer resource: This allows to skip the Authorizer invocation for the given time if a client provided the same identity source values (e.g., authorization header).\nAWS API Gateway HTTP can employ the identity sources as the cache key to preserve the authorization results for a while. Should a client provide identical parameters in identity sources within the preset TTL duration, API Gateway will retrieve the result from the cached authorizer instead of calling upon it again. This helps save a lot on AWS Lambda Authorizer invocations and works great with simple scenarios. However, it might be cumbersome if you need severral custom authorization responses per function or if you use custom IAM policies instead of the ‚Äúsimple response‚Äù option. source_arn argument of aws_lambda_permission: Similar to the authorizer_uri argument, this one expects the execution ARN of the HTTP API followed by the Authorizer identifier.\nNow, let‚Äôs see how Routes are codified with Terraform.\nApplying Terraform for HTTP API Routes üí° Because an API typically has multiple routes, creating another Terraform module that implements the configurable HTTP API Gateway route is beneficial. Hence, the aws_apigatewayv2_route, aws_apigatewayv2_integration, and aws_lambda_permission resources would constitute such a module.\nThis Terraform module implements a specific use case for HTTP API Gateway. However, if you‚Äôre seeking for a generic all-in-one module for API Gateway, I recommend checking out this one ‚Äî Terraform AWS API Gateway Module by Anton Babenko.\nresource \"aws_apigatewayv2_route\" \"this\" { api_id = var.api_id route_key = var.route_key authorization_type = \"CUSTOM\" authorizer_id = var.authorizer_id target = \"integrations/${aws_apigatewayv2_integration.this.id}\" } resource \"aws_apigatewayv2_integration\" \"this\" { api_id = var.api_id integration_type = \"AWS_PROXY\" connection_type = \"INTERNET\" integration_uri = var.lambda_invocation_arn payload_format_version = \"2.0\" } resource \"aws_lambda_permission\" \"this\" { statement_id = \"allowInvokeFromAPIGatewayRoute\" action = \"lambda:InvokeFunction\" function_name = var.lambda_function_name principal = \"apigateway.amazonaws.com\" source_arn = \"${var.api_gw_execution_arn}/*/*/*/*\" } First, I want to highlight several key aspects for understanding the resources‚Äô arguments within that module.\nThe target argument of the aws_apigatewayv2_route resource implies that the integration ID should be prefixed with the ‚Äúintegrations/‚Äù keyword.\nWhile the connection_type argument of the aws_apigatewayv2_integration resource specifies ‚ÄúINTERNET‚Äù, it does not mean that the Lambda function must have the publicly available URL. This value must be used unless you work with a VPC endpoint for API Gateway for internal usage.\nFor the source_arn argument in the aws_lambda_permission resource, similar to earlier, it requires the execution ARN of the API. However, this time, it is the integration of the HTTP API Route with Lambda. And the ARN format of this one is different and a bit tricky:\narn:partition:execute-api:region:account-id:api-id/stage/http-method/resource-path\nThe arn:partition:execute-api:region:account-id:api-id part constitutes the execution ARN of the HTTP API itself, so for the sake of simplicity, I decided to go with wildcards after it.\nFor your convenience, here is the detailed specification of API Gateway ARNs.\nThe HTTP API Route module expects several input variables:\nauthorizer_id ‚Äî the identifier of the Authorizer to use on this route; route_key ‚Äî the route key for the route, e.g., GET /foo/bar; api_id ‚Äî the identifier of HTTP API created earlier; lambda_invocation_arn ‚Äî the Invocation ARN of the Lambda function; lambda_function_name ‚Äî the name of the Lambda function to integrate with the route; api_gw_execution_arn ‚Äî the Execution ARN of the HTTP API that invokes a Lambda function. Let‚Äôs take a closer look on API Gateway V2 HTTP API route.\nA route consists of an HTTP method and a resource path with an optional variable. Based on the pre-defined convention, it uses a simplified routing configuration and methods request model (comparable to other APIs).\nWhile I was working with the HTTP API, I found this simplified approach to be great because it allows easy access to the request context from AWS Lambda functions, for example:\nA path variable in a route, e.g., GET /calendars/{calendar-name}, would be available for the integrated AWS Lambda by its name inside the pathParameter JSON field, e.g., pathParamters.calendar-name, of the event object sent by API to Lambda. In other words, you do not need to explicitly set the mapping between the path variable and its representation to the back-end. A request query string is parsed into separate parameter-value pairs and available in the queryStringParameters field of the event object sent by API to Lambda. Again, without the explicit mapping configuration. Here, you can read more about the Route specification of HTTP API and how to transform requests and responses from the API side if you need to adjust something:\nWorking with routes for HTTP APIs Transforming API requests and responses Now back to Terraform. Below is the code snippet that illustrates the call of the API Route Terraform module:\nmodule \"route_calendars\" { source = \"./modules/api-gateway-route\" api_id = aws_apigatewayv2_api.this.id route_key = \"GET /calendars/{calendar-name}\" api_gw_execution_arn = aws_apigatewayv2_api.this.execution_arn lambda_invocation_arn = module.lambda_calendar_backend.lambda.invoke_arn lambda_function_name = module.lambda_calendar_backend.lambda.function_name authorizer_id = aws_apigatewayv2_authorizer.header_based_authorizer.id } This module logically relies on both the HTTP API and Lambda resources to configure their integration by implementing the Route.\nEnhancing Security and Monitoring of AWS API Gateway V2 HTTP API Several additional options are available to monitor and protect the HTTP API: logs, metrics, and throttling.\nOverview of HTTP API monitoring and protection options Logging, metrics, and throttling are configured on the Stage level but allow configuration granularity for the Routes.\nFor logs, you can configure the CloudWatch log group, the log format (JSON, CLF, XML, CSV), and content filters. The logging variables allow you to customize the information that appears in logs. I will provide an example of such a configuration later in the article.\nBy default, API Gateway sends only API and stage-level metrics to CloudWatch in one-minute periods. However, you can enable detailed metrics and additionally collect the per-route metrics.\nTo safeguard your HTTP API from excessive requests, you can employ throttling settings, which allow you to set limits per individual route as well as for all routes collectively.\nConfiguring monitoring and protection for HTTP API with Terraform Now, let‚Äôs see how Terraform helps configure the protection and monitoring for HTTP API.\nAs mentioned earlier, API Gateway applies these configurations at the Stage level, which is why the aws_apigatewayv2_stage resource encapsulates them all.\nresource \"aws_apigatewayv2_stage\" \"default\" { api_id = aws_apigatewayv2_api.this.id name = \"$default\" auto_deploy = true description = \"Default stage (i.e., Production mode)\" default_route_settings { throttling_burst_limit = 1 throttling_rate_limit = 1 } access_log_settings { destination_arn = aws_cloudwatch_log_group.api_gateway_logs_inkyframe.arn format = jsonencode({ authorizerError = \"$context.authorizer.error\", identitySourceIP = \"$context.identity.sourceIp\", integrationError = \"$context.integration.error\", integrationErrorMessage = \"$context.integration.errorMessage\" integrationLatency = \"$context.integration.latency\", integrationRequestId = \"$context.integration.requestId\", integrationStatus = \"$context.integration.integrationStatus\", integrationStatusCode = \"$context.integration.status\", requestErrorMessage = \"$context.error.message\", requestErrorMessageString = \"$context.error.messageString\", requestId = \"$context.requestId\", routeKey = \"$context.routeKey\", }) } } Here, I applied the default throttling settings: for my project, 1 request per second was enough at that point.\nü§î There is a nuance, though, that makes Terraforming API Gateway a little inconvenient ‚Äî the IAM role that allows API to write logs must be defined on a region level. Therefore, if you maintain several Terraform projects for the same AWS account, you might need to have the following configuration stand separately to avoid conflicts or misunderstandings:\nresource \"aws_api_gateway_account\" \"this\" { cloudwatch_role_arn = aws_iam_role.api_gateway_cloudwatch_logs.arn } resource \"aws_iam_role\" \"api_gateway_cloudwatch_logs\" { name = \"api-gateway-cloudwatch-logs\" assume_role_policy = jsonencode({ Version = \"2012-10-17\" Statement = [ { Effect = \"Allow\" Principal = { Service = \"apigateway.amazonaws.com\" } Action = \"sts:AssumeRole\" } ] }) managed_policy_arns = [\"arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs\"] } resource \"aws_cloudwatch_log_group\" \"api_gateway_logs_inkyframe\" { name = \"/aws/apigateway/inkyframe\" log_group_class = \"STANDARD\" retention_in_days = 7 } And one more thing about HTTP API deployments and stages. I use the special $default keyword to have a single stage (hence, the default one), and I also used automatic deployments: with any change made to API configuration, AWS will automatically generate a new Deployment and bound it with the Stage. If you prefer controlling deployments manually, there is a special resource exists that implements this ‚Äî aws_apigatewayv2_deployment\nresource \"aws_apigatewayv2_deployment\" \"example\" { api_id = aws_apigatewayv2_api.example.id description = \"Example deployment\" triggers = { redeployment = sha1(join(\",\", tolist([ jsonencode(aws_apigatewayv2_integration.example), jsonencode(aws_apigatewayv2_route.example), ]))) } lifecycle { create_before_destroy = true } } In that case, the aws_apigatewayv2_stage resource requires the deployment_id argument to link itself with a particular Deployment and, therefore, represent the state of the API configuration.\nAlso, API Gateway requires at least one configured API Route before the deployment is initiated/created. However, these resources do not explicitly depend on each other via attribute references. To avoid the race condition in Terraform, you need to reference the Route resource in the aws_apigatewayv2_deployment resource via the triggers argument (as shown above) or via the depends_on meta-argument. Otherwise, Terraform will try to apply changes to both resources simultaneously.\nAfterword: Simplifying Serverless Architectures In wrapping up our exploration of AWS HTTP API Gateway, AWS Lambda, and Terraform, we‚Äôve delved into how these powerful tools work in tandem to streamline and enhance serverless architectures. This article aimed to combine my experience with new knowledge and demystify the complexities of used services, showcasing their capabilities in creating efficient, cost-effective solutions for modern cloud-based applications.\nWe focused on practical implementation and the tangible benefits of combining these technologies. By leveraging Terraform, we‚Äôve seen how infrastructure management can be simplified, allowing for clearer, more maintainable code. The combination of AWS Lambda and HTTP API Gateway has demonstrated the efficiency of serverless computing, offering scalability and performance without the burden of extensive configuration and management.\nThis exploration underlines the importance of choosing the right tools and strategies in cloud computing. It reminds developers and architects that creating robust and efficient serverless systems is within reach with a thoughtful approach and the right set of tools. As the cloud landscape continues to evolve, staying informed and adaptable is key to harnessing the full potential of these technologies. üíö\n","wordCount":"4116","inLanguage":"en","image":"https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/cover-image.jpg","datePublished":"2024-01-09T03:33:10+01:00","dateModified":"2025-02-09T18:58:16+01:00","author":{"@type":"Person","name":"Serhii Vasylenko"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/"},"publisher":{"@type":"Person","name":"devDosvid blog","logo":{"@type":"ImageObject","url":"https://devdosvid.blog/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://devdosvid.blog/ accesskey=h title="üè† Home (Alt + H)">üè† Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://devdosvid.blog/index.xml title="RSS Feed"><span>RSS Feed</span></a></li><li><a href=https://devdosvid.blog/archive title="All posts"><span>All posts</span></a></li><li><a href=https://devdosvid.blog/about/ title="About me"><span>About me</span></a></li><li><a href=https://devdosvid.blog/series title="Post Series"><span>Post Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://devdosvid.blog/>Home</a>&nbsp;¬ª&nbsp;<a href=https://devdosvid.blog/posts/>Posts</a></div><h1 class=post-title>Mastering AWS API Gateway V2 HTTP and AWS Lambda With Terraform</h1><div class=post-description>The article provides insights into using AWS API Gateway and AWS Lambda with Terraform for efficient, cost-effective serverless solutions.</div><div class=post-meta><span title='2024-01-09 03:33:10 +0100 +0100'>January 9, 2024</span>&nbsp;¬∑&nbsp;Serhii Vasylenko&nbsp;|&nbsp;<a href=mailto:contact@devdosvid.blog rel="noopener noreferrer" target=_blank>Contact me</a></div></header><figure class=entry-cover><img srcset="https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/cover-image_hu16537410265255779989.jpg 360w ,https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/cover-image_hu6777607600591574027.jpg 480w ,https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/cover-image_hu17322352398411692043.jpg 720w ,https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/cover-image_hu14950693147577697377.jpg 1080w ,https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/cover-image.jpg 1200w" sizes="(min-width: 768px) 720px, 100vw" src=https://devdosvid.blog/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/cover-image.jpg alt="Illustration of a cloud symbol containing icons of a gear, an API symbol, and geometric shapes, representing cloud computing and API management." width=1200 height=630></figure><div class=post-content><p>With a solid foundation in AWS API Gateway and Lambda for serverless architecture, my recent deep dive into these cloud computing services felt like uncovering new layers in familiar territory. This article aims to be a comprehensive guide for developers and DevOps professionals looking to master serverless solutions using AWS and Terraform.</p><p>The article provides an in-depth guide to <strong>combining AWS API Gateway V2 HTTP API</strong> (yes, this is the official name of that service üòÑ) <strong>and AWS Lambda</strong> services to implement a simple, robust, and cost-effective serverless back-end using Terraform.</p><p>The journey was enlightening and engaging, especially as I were transforming these services into Infrastructure as Code. Through this article, I aim to share those moments of insight and the practical, hands-on tips that emerged from weaving these AWS services into a seamless, serverless architecture.</p><h2 id=navigating-the-system-design-http-api-gateway-and-lambda-in-action>Navigating the System Design: HTTP API Gateway and Lambda in Action<a hidden class=anchor aria-hidden=true href=#navigating-the-system-design-http-api-gateway-and-lambda-in-action>#</a></h2><p>Beginning our journey, we examine the complexities of serverless architecture, focusing on HTTP API and Lambda. A comprehensive system diagram will guide us as we analyze each component&rsquo;s function and their collaborative roles in the larger infrastructure.</p><figure><img loading=lazy src=/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/api-gateway-lambda-authorization-flow_hu930799113825989666.webp alt="HTTP API Gateway and AWS Lambda flowchart" width=800 height=440.50><figcaption><p>HTTP API Gateway and AWS Lambda flowchart</p></figcaption></figure><p>In our architecture, the HTTP API delegates access control to the Lambda function called &ldquo;Authorizer&rdquo;. This function stands as the gatekeeper, ensuring that only legitimate requests pass through to the underlying business logic.</p><p>The HTTP API can have multiple routes (e.g., &ldquo;/calendar,&rdquo; &ldquo;/meters,&rdquo; and so on) and use different Authorizers per route or a single one for all of them. Clients that send their requests to the API must include specific identification information in their request header or query string. In this project, I go with a single authorizer to keep it simple.</p><p>Upon receiving a request, the API service forwards a payload to the Authorizer containing metadata about the request, such as headers and query string components. The Authorizer processes this metadata (headers, in my case) to determine the request&rsquo;s legitimacy.</p><p>The decision, Allow or Deny, is passed back to the API, and if allowed, the API service then forwards the original request to the back-end, which, in this case, is implemented by additional Lambda functions. Otherwise, the client gets a response with a 403 status code, and the original request is not passed to the back-end.</p><div class=substack-embedded-container><h3>Subscribe to blog updates!</h3><iframe title=Substack class=substack-embedded-iframe src=https://devdosvid.substack.com/embed height=250 loading=lazy></iframe></div><h2 id=behind-the-decision-why-such-a-setup>Behind The Decision: Why Such a Setup?<a hidden class=anchor aria-hidden=true href=#behind-the-decision-why-such-a-setup>#</a></h2><p>Choosing the right architectural setup is critical in balancing simplicity, cost-efficiency, and security. In this section, we uncover why integrating AWS HTTP API Gateway with Lambda Authorizer is a compelling choice, offering a streamlined approach without compromising security.</p><h3 id=cost-effectiveness-balancing-performance-and-price>Cost-Effectiveness: Balancing Performance and Price<a hidden class=anchor aria-hidden=true href=#cost-effectiveness-balancing-performance-and-price>#</a></h3><p>The AWS HTTP API is noteworthy for its streamlined and simple design compared to other API Gateway options. That translates directly into cost savings for businesses. Its efficiency makes it an ideal choice for cost-effective serverless computing, especially for those looking to optimize their cloud infrastructure with Terraform automation. Here is a more detailed comparison of different API Gateway options ‚Äî <a href=https://docs.aws.amazon.com/whitepapers/latest/best-practices-api-gateway-private-apis-integration/cost-optimization.html>Cost optimization</a>.</p><p>Security with Lambda Authorizer. This option means a Lambda function used for authorization, which is lean and efficient. It generally requires a bare minimum of resources. It executes quickly, particularly when configured with the ARM-based environment and 128M RAM allocation, costing $0,0000017 per second of running time, with $0.20 per 1M requests per month.</p><p>üí∞ This pricing and performance combination are well-suited for rapid, lightweight authorizations. Together with AWS Lambda as a back-end, it makes a cost-effective solution. For example, if we add a few more Lambdas to back-end and assume that our setup receives 10000 requests per month, it would cost around $0.6 per month. Here is the link to detailed calculations ‚Äî <a href="https://calculator.aws/#/estimate?id=b1a8a473ab98ede32f5ca384c5e9487b967efafa">AWS Pricing Calculator</a>.</p><h3 id=simplicity-in-configuration-the-power-of-header-based-authorization>Simplicity in Configuration: The Power of Header-Based Authorization<a hidden class=anchor aria-hidden=true href=#simplicity-in-configuration-the-power-of-header-based-authorization>#</a></h3><p>A header-based authentication method facilitates straightforward client-server communication, often requiring less coding and resources to implement compared to more complex schemes.</p><p>Although HTTP API offers stronger JWT-based authorization and mutual TLS authentication, header-based authorization remains a suitable choice for simpler applications that prioritize ease and quickness. <em>By the way, there is also an option for IAM-based authorization whose core idea is the &ldquo;private API&rdquo; or internal usage of the API (e.g., solely inside the VPC, no internet), but with &ldquo;<a href=https://docs.aws.amazon.com/rolesanywhere/latest/userguide/introduction.html>IAM Anywhere</a>,&rdquo; this can be expanded to practically anywhere.</em> üòÅ</p><p>This architecture suits applications requiring rapid development and deployment without complex authorization mechanisms. It&rsquo;s ideal for small to medium-sized serverless applications or specific use cases in larger systems where quick, cost-effective, and secure access to APIs is a priority.</p><p>üí° Imagine a retail company wanting to manage its inventory efficiently. By leveraging AWS API Gateway and Lambda, they can develop a system where each item&rsquo;s RFID tags are scanned and processed through an API endpoint. When a product is moved or sold, its status is updated in real-time in the database, facilitated by Lambda functions. This serverless architecture ensures high availability and scalability and significantly reduces operational costs, a crucial factor for the highly competitive retail industry. This example showcases how our serverless setup can be effectively utilized in retail for streamlined inventory tracking and management.</p><h2 id=exploring-aws-lambda-features-and-integration>Exploring AWS Lambda: Features and Integration<a hidden class=anchor aria-hidden=true href=#exploring-aws-lambda-features-and-integration>#</a></h2><p>Diving into AWS Lambda, this section explores its features and indispensable role within the serverless infrastructure. We will unravel the complexities of Lambda functions and examine the practicalities of deploying and managing these functions within the project.</p><h3 id=aws-lambda-runtime-and-deployment-model>AWS Lambda Runtime and Deployment Model<a hidden class=anchor aria-hidden=true href=#aws-lambda-runtime-and-deployment-model>#</a></h3><p>üöÄ Choosing the <strong>AWS Lambda runtime arm64</strong>, combined with the OS-only runtime based on <strong>Amazon Linux 2023</strong>, strategically boosts cost efficiency and performance. This choice aligns with the best practices for serverless computing in AWS, offering an optimal solution for those seeking to leverage AWS services for scalable cloud solutions.</p><p>Particularly effective for Go-based functions, this runtime configuration is lean yet powerful. For applications in other languages, delving into <a href=https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html>language-specific runtimes based on AL 2023</a> can also leverage the latest efficiencies of AWS-managed operating systems.</p><div class=attention>I also welcome you to read this benchmarking analysis to get more insights about the ARM-based environment for AWS Lambda ‚Äî <a href=https://aws.amazon.com/blogs/apn/comparing-aws-lambda-arm-vs-x86-performance-cost-and-analysis-2/>Comparing AWS Lambda Arm vs. x86 Performance, Cost, and Analysis</a>.</div><p>The .<strong>zip deployment</strong> model is chosen for its simplicity, avoiding additional management of the image registry (ECR) and Docker images. Also, AWS automatically patches .zip functions for the latest runtime security and bug fixes.</p><h3 id=efficient-terraform-coding-for-aws-lambda>Efficient Terraform Coding for AWS Lambda<a hidden class=anchor aria-hidden=true href=#efficient-terraform-coding-for-aws-lambda>#</a></h3><p>In our architecture, AWS Lambda functions serve dual purposes ‚Äî as an authentication gatekeeper and a robust back-end for business logic. Despite varying code across functions, their configurations share much of similarities.</p><p>By adhering to the DRY (Don&rsquo;t Repeat Yourself) principle, I have crafted a Terraform module to streamline the management of Lambda functions and their dependencies. This approach ensures maintainable and scalable infrastructure. The module&rsquo;s structure is as follows:</p><ul><li><code>aws_lambda_function</code> ‚Äî to describe the core configuration of the function</li><li><code>aws_iam_role</code> + <code>aws_iam_role_policy</code> + <code>aws_iam_policy_document</code> ‚Äî to manage the access from Lambda to other resources (e.g., SSM Parameter Store)</li><li><code>aws_cloudwatch_log_group</code> ‚Äî to keep the execution logs</li><li><code>aws_ssm_parameter</code> ‚Äî to store sensitive information (e.g., secrets) and other configurations that we should keep separate from the source code.</li></ul><p>This Terraform module implements a project-specific use case for Lambda functions. However, if you&rsquo;re seeking for a generic all-in-one module for AWS Lambda, I recommend checking out this one ‚Äî <a href=https://registry.terraform.io/modules/terraform-aws-modules/lambda/aws/latest>Terraform AWS Lambda Module</a> by Anton Babenko.</p><div class=attention><p>To efficiently develop Terraform code for Lambda functions, use the following techniques:</p><ul><li>Use local values, expressions, and variables to implement consistent naming across different resources logically grouped by a module or project;</li><li>Use function environment variables to connect the code with SSM Parameter Store parameters or Secrets Manager secrets to protect sensitive data like tokens or credentials;</li><li>Use <code>for_each</code> meta-argument and <code>for</code> expression to reduce the amount of code and automate the configuration for resources of the same type (e.g., <code>ssm_parameter</code>) or code blocks within a resource.</li></ul></div><p>Below is a practical example illustrating these Terraform strategies in action:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-terraform data-lang=terraform><span style=display:flex><span>locals {  
</span></span><span style=display:flex><span>  full_function_name = <span style=color:#a5d6ff>&#34;</span><span style=color:#a5d6ff>${</span>var.project_name<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>-</span><span style=color:#a5d6ff>${</span>var.function_name<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>&#34;</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_lambda_function&#34;</span> <span style=color:#a5d6ff>&#34;this&#34;</span> {  
</span></span><span style=display:flex><span>  function_name = local.full_function_name  
</span></span><span style=display:flex><span>  role          = aws_iam_role.this.arn  
</span></span><span style=display:flex><span>  architectures = [<span style=color:#a5d6ff>&#34;arm64&#34;</span>]  
</span></span><span style=display:flex><span>  filename      = var.deployment_file  
</span></span><span style=display:flex><span>  package_type  = <span style=color:#a5d6ff>&#34;Zip&#34;</span>  
</span></span><span style=display:flex><span>  runtime       = <span style=color:#a5d6ff>&#34;provided.al2023&#34;</span>  
</span></span><span style=display:flex><span>  handler       = <span style=color:#a5d6ff>&#34;bootstrap.handler&#34;</span>  
</span></span><span style=display:flex><span>  timeout       = var.function_timeout  
</span></span><span style=display:flex><span>  environment {  
</span></span><span style=display:flex><span>    variables = { <span style=color:#ff7b72>for</span> item <span style=color:#ff7b72>in</span> var.function_ssm_parameter_names <span style=color:#ff7b72;font-weight:700>:</span> upper(replace(item, <span style=color:#a5d6ff>&#34;-&#34;</span>, <span style=color:#a5d6ff>&#34;_&#34;</span>)) =&gt; aws_ssm_parameter.function_ssm_parameters[item].name }  
</span></span><span style=display:flex><span>  }  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_ssm_parameter&#34;</span> <span style=color:#a5d6ff>&#34;function_ssm_parameters&#34;</span> {  
</span></span><span style=display:flex><span>  for_each = var.function_ssm_parameter_names  
</span></span><span style=display:flex><span>  name     = <span style=color:#a5d6ff>&#34;/projects/</span><span style=color:#a5d6ff>${</span>var.project_name<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>/lambda/</span><span style=color:#a5d6ff>${</span>var.function_name<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>/</span><span style=color:#a5d6ff>${</span>each.value<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>&#34;</span>  
</span></span><span style=display:flex><span>  type     = <span style=color:#a5d6ff>&#34;SecureString&#34;</span>  
</span></span><span style=display:flex><span>  key_id   = data.aws_kms_alias.ssm.arn  
</span></span><span style=display:flex><span>  value    = <span style=color:#a5d6ff>&#34;1&#34;</span>  
</span></span><span style=display:flex><span>  lifecycle {  
</span></span><span style=display:flex><span>    ignore_changes = [  
</span></span><span style=display:flex><span>      value,  
</span></span><span style=display:flex><span>    ]  
</span></span><span style=display:flex><span>  }  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_cloudwatch_log_group&#34;</span> <span style=color:#a5d6ff>&#34;this&#34;</span> {  
</span></span><span style=display:flex><span>  name              = <span style=color:#a5d6ff>&#34;/aws/lambda/</span><span style=color:#a5d6ff>${</span>local.full_function_name<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>&#34;</span>  
</span></span><span style=display:flex><span>  log_group_class   = <span style=color:#a5d6ff>&#34;STANDARD&#34;</span>  
</span></span><span style=display:flex><span>  retention_in_days = <span style=color:#a5d6ff>7</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>The complete terraform module code is available in the <a href=https://github.com/vasylenko/inkyframe/blob/main/infra/modules/lambda/main.tf>project repository</a>.</em></p><p>In this Terraform code, I deliberately hardcoded specific arguments for an optimal Lambda runtime configuration, ensuring efficiency and performance.</p><p>Then variables and local values, set only once, implement a naming convention for all resource arguments, making it easy to understand the infrastructure and change the naming and attributes later.</p><div class=attention>Lambda&rsquo;s environment variables and corresponding SSM parameters coexist effectively with the help of <code>for_each</code> and <code>for</code>. I used the <code>for_each</code> meta-argument to dynamically create SSM Parameter resources and the <code>for</code> expression to configure environment variables in AWS Lambda. This also means that if the <code>function_ssm_parameter_names</code> variable value is not provided, then Terraform does not create either SSM parameter resources or the environment code block inside the Lambda resource because the default value of that variable is an empty set.</div><p>By the way, I have another blog post that explains several techniques to enhance your Terraform proficiency ‚Äî <a href=/2022/01/16/some-techniques-to-enhance-your-terraform-proficiency>check it out</a>!</p><h3 id=invoking-lambda-permissions-and-resource-based-policies>Invoking Lambda: Permissions and Resource-Based Policies<a hidden class=anchor aria-hidden=true href=#invoking-lambda-permissions-and-resource-based-policies>#</a></h3><p>Configured with just a few input variables, the Terraform module efficiently outputs the <code>aws_lambda_function</code> resource. This streamlined output is then adeptly used to facilitate subsequent configurations within the HTTP API.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-terraform data-lang=terraform><span style=display:flex><span><span style=color:#ff7b72>module</span> <span style=color:#a5d6ff>&#34;lambda_api_gw_authorizer&#34;</span> {  
</span></span><span style=display:flex><span>  source          = <span style=color:#a5d6ff>&#34;./modules/lambda&#34;</span>  
</span></span><span style=display:flex><span>  deployment_file = <span style=color:#a5d6ff>&#34;../backend/lambda-apigw-authorizer/deployment.zip&#34;</span>  
</span></span><span style=display:flex><span>  function_name   = <span style=color:#a5d6ff>&#34;api-gateway-authorizer&#34;</span>  
</span></span><span style=display:flex><span>  project_name    = local.project_name  
</span></span><span style=display:flex><span>  function_ssm_parameters = [  
</span></span><span style=display:flex><span>    <span style=color:#a5d6ff>&#34;authorization-token&#34;</span>  
</span></span><span style=display:flex><span>  ]  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#ff7b72>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>module</span> <span style=color:#a5d6ff>&#34;lambda_calendar_backend&#34;</span> {  
</span></span><span style=display:flex><span>  source          = <span style=color:#a5d6ff>&#34;./modules/lambda&#34;</span>  
</span></span><span style=display:flex><span>  deployment_file = <span style=color:#a5d6ff>&#34;../backend/lambda-calendar-backend/deployment.zip&#34;</span>  
</span></span><span style=display:flex><span>  function_name   = <span style=color:#a5d6ff>&#34;calendar-backend&#34;</span>  
</span></span><span style=display:flex><span>  project_name    = local.project_name  
</span></span><span style=display:flex><span>  function_ssm_parameters = [  
</span></span><span style=display:flex><span>    <span style=color:#a5d6ff>&#34;google-api-oauth-token&#34;</span>,  
</span></span><span style=display:flex><span>    <span style=color:#a5d6ff>&#34;google-api-credentials&#34;</span>  
</span></span><span style=display:flex><span>  ]  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As an example of module output usage, here is the configuration of <code>aws_lambda_permissions</code> resource that I use outside the AWS Lambda module to allow the HTTP API service to invoke the function used as Authorizer:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-terraform data-lang=terraform><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_lambda_permission&#34;</span> <span style=color:#a5d6ff>&#34;allow_api_gw_invoke_authorizer&#34;</span> {  
</span></span><span style=display:flex><span>  statement_id  = <span style=color:#a5d6ff>&#34;allowInvokeFromAPIGatewayAuthorizer&#34;</span>  
</span></span><span style=display:flex><span>  action        = <span style=color:#a5d6ff>&#34;lambda:InvokeFunction&#34;</span>  
</span></span><span style=display:flex><span>  function_name = module.lambda_api_gw_authorizer.lambda.function_name  
</span></span><span style=display:flex><span>  principal     = <span style=color:#a5d6ff>&#34;apigateway.amazonaws.com&#34;</span>  
</span></span><span style=display:flex><span>  source_arn    = <span style=color:#a5d6ff>&#34;</span><span style=color:#a5d6ff>${</span>aws_apigatewayv2_api.this.execution_arn<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>/authorizers/</span><span style=color:#a5d6ff>${</span>aws_apigatewayv2_authorizer.header_based_authorizer.id<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>&#34;</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=attention>The Lambda resource-based policy combines the trust and permission policies, and provides a simple yet efficient way to grant other AWS services or principals the ability to invoke Lambda functions. It is important to note that for an API to invoke a function, Lambda requires its <strong>execution</strong> ARN, not the resource ARN.</div><p>As a side note, check out this <a href=https://docs.aws.amazon.com/lambda/latest/operatorguide/intro.html>AWS Lambda Operator Guide</a>, which offers specialized advice on developing, securing, and monitoring applications based on AWS Lambda.</p><p>Let&rsquo;s switch to the HTTP API part to see how it looks and learn how it integrates Lambda functions.</p><h2 id=deep-dive-into-http-api-gateway>Deep Dive into HTTP API Gateway<a hidden class=anchor aria-hidden=true href=#deep-dive-into-http-api-gateway>#</a></h2><p>Now, we focus on the HTTP API Gateway, delving into its essential concepts, seamless integration with AWS Lambda, and using Terraform efficiently for streamlined configuration.</p><p>But before we do that, and since we have partially covered the Terraform code already, I&rsquo;d like to illustrate the logical connection between three main components of the project&rsquo;s Terraform codebase: AWS Lambda, HTTP API, and API Routes.</p><figure><img loading=lazy src=/2024/01/09/mastering-aws-api-gateway-v2-http-and-aws-lambda-with-terraform/terraform-aws-lambda-http-api-integration_hu13630988060189788556.webp alt="AWS Lambda and HTTP API Terraform integration diagram" width=800 height=552.50><figcaption><p>AWS Lambda and HTTP API Terraform integration diagram</p></figcaption></figure><p>I will explain the API Route module in detail a bit later, but for now, for the broader context, here is what happens inside Terraform:
AWS HTTP API code logically represents the &ldquo;global&rdquo; (within a project) set of resources and uses the function created by the Lambda Terraform module for the Authorizer configuration. Meanwhile, the API Route Terraform module configures specific routes for the HTTP API (hence, requires some info from it) with integration to back-ends implemented by Lambdas (hence, requires some info from them, too).</p><p>Back to HTTP API overview. The following <strong>components of the HTTP API</strong> constitute its backbone:</p><ul><li><strong>Route</strong> ‚Äî a combination of the HTTP method (e.g., GET or POST) with the API route (e.g., /meters). For example: &ldquo;POST /meters&rdquo;. Routes can optionally use <strong>Authorizers</strong> ‚Äî a mechanism to control access to the HTTP API.</li><li><strong>Integration</strong> ‚Äî the technical and logical connection between the Route and one of the supported back-end resources. For example, with AWS Lambda integration, API Gateway sends the entire request as input to a back-end Lambda function and then transforms the Lambda function output to a front-end HTTP response.</li><li><strong>Stage and Deployment</strong> ‚Äî A stage serves as a designated reference to a deployment, essentially capturing a snapshot of the API at a certain point. It&rsquo;s employed to control and optimize a specific deployment version. For instance, stage configurations can be adjusted to tailor request throttling, set up logging, or establish stage variables to be used by API (if needed).</li></ul><h3 id=implementing-aws-api-gateway-v2-http-api-with-terraform>Implementing AWS API Gateway V2 HTTP API with Terraform<a hidden class=anchor aria-hidden=true href=#implementing-aws-api-gateway-v2-http-api-with-terraform>#</a></h3><p>Below, I detail the Terraform resources essential for implementing the HTTP API, ensuring a transparent and effective setup:</p><ul><li><code>aws_apigatewayv2_api</code> ‚Äî the HTTP API itself;</li><li><code>aws_apigatewayv2_route</code> ‚Äî the Route for the API that must specify the integration target (e.g., Lambda) and, optionally, the Authorizer;</li><li><code>aws_apigatewayv2_authorizer</code> ‚Äî the Authorizer to use for Routes;</li><li><code>aws_apigatewayv2_integration</code> ‚Äî the resource that specifies the back-end where the API sends the requests (e.g., AWS Lambda);</li><li><code>aws_lambda_permission</code> ‚Äî the resource-based policy for AWS Lambda to allow the invocations from the API;</li><li><code>aws_apigatewayv2_stage</code> ‚Äî the name of the Stage that references the Deployment.</li></ul><h3 id=applying-terraform-for-http-api-gateway-and-lambda-authorizer>Applying Terraform for HTTP API Gateway and Lambda Authorizer<a hidden class=anchor aria-hidden=true href=#applying-terraform-for-http-api-gateway-and-lambda-authorizer>#</a></h3><p>The HTTP API is the simplest in the API Gateway family (so far), so its Terraform resource has relatively few configuration options, most of which can be left at their default values.</p><p>As for the Authorizer, it can have two options for letting API know its decision: <a href=https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html#http-api-lambda-authorizer.payload-format-response>simple response and IAM policy</a>.</p><p>The <strong>simple response</strong> just returns a Boolean value to indicate whether the API should allow the request (True) or forbid it (False).</p><p>The IAM policy option is customizable and allows crafting custom policy statements that allow granular access to explicitly provided resources.</p><p>In this project, I follow the way of simplicity and use the &ldquo;simple response&rdquo;, so the response from Lambda Authorizer to HTTP API looks as follows:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;isAuthorized&#34;</span>: <span style=color:#79c0ff>true</span><span style=color:#f85149>/</span><span style=color:#79c0ff>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s review the HTTP API resource along with the API Authorizer that I used for all routes:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-terraform data-lang=terraform><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_apigatewayv2_api&#34;</span> <span style=color:#a5d6ff>&#34;this&#34;</span> {  
</span></span><span style=display:flex><span>  name          = local.project_name  
</span></span><span style=display:flex><span>  protocol_type = <span style=color:#a5d6ff>&#34;HTTP&#34;</span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#ff7b72>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_apigatewayv2_authorizer&#34;</span> <span style=color:#a5d6ff>&#34;header_based_authorizer&#34;</span> {  
</span></span><span style=display:flex><span>  api_id                            = aws_apigatewayv2_api.this.id  
</span></span><span style=display:flex><span>  authorizer_type                   = <span style=color:#a5d6ff>&#34;REQUEST&#34;</span>  
</span></span><span style=display:flex><span>  name                              = <span style=color:#a5d6ff>&#34;header-based-authorizer&#34;</span>  
</span></span><span style=display:flex><span>  authorizer_payload_format_version = <span style=color:#a5d6ff>&#34;2.0&#34;</span>  
</span></span><span style=display:flex><span>  authorizer_uri                    = module.lambda_api_gw_authorizer.lambda.invoke_arn  
</span></span><span style=display:flex><span>  enable_simple_responses           = <span style=color:#79c0ff>true</span>  
</span></span><span style=display:flex><span>  identity_sources                  = [<span style=color:#a5d6ff>&#34;$request.header.authorization&#34;</span>] 
</span></span><span style=display:flex><span>  authorizer_result_ttl_in_seconds  = <span style=color:#a5d6ff>3600</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_lambda_permission&#34;</span> <span style=color:#a5d6ff>&#34;allow_api_gw_invoke_authorizer&#34;</span> {  
</span></span><span style=display:flex><span>  statement_id  = <span style=color:#a5d6ff>&#34;allowInvokeFromAPIGatewayAuthorizer&#34;</span>  
</span></span><span style=display:flex><span>  action        = <span style=color:#a5d6ff>&#34;lambda:InvokeFunction&#34;</span>  
</span></span><span style=display:flex><span>  function_name = module.lambda_api_gw_authorizer.lambda.function_name  
</span></span><span style=display:flex><span>  principal     = <span style=color:#a5d6ff>&#34;apigateway.amazonaws.com&#34;</span>  
</span></span><span style=display:flex><span>  source_arn    = <span style=color:#a5d6ff>&#34;</span><span style=color:#a5d6ff>${</span>aws_apigatewayv2_api.this.execution_arn<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>/authorizers/</span><span style=color:#a5d6ff>${</span>aws_apigatewayv2_authorizer.header_based_authorizer.id<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>&#34;</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>The complete code is available in the <a href=https://github.com/vasylenko/inkyframe/blob/main/infra/apigateway.tf>project repository</a></em>.</p><p>Consider the following key points when Terraforming this part.</p><p><code>identity_sources</code> argument of the <code>aws_apigatewayv2_authorizer</code> resource: This is where I defined what exactly the Authorizer should validate. I used the header named <code>authorization</code> so the Authorizer Lambda function would check its value to decide whether to authorize the request.<br>üí° <em>Check out other options available to use as the identity source ‚Äî <a href=https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html#http-api-lambda-authorizer.identity-sources>Identity sources</a></em>.</p><p><code>authorizer_uri</code> argument of the <code>aws_apigatewayv2_authorizer</code> resource: It is the <strong>invocation</strong> ARN of the Lambda function used as Authorizer (not the Lambda&rsquo;s resource ARN).</p><p><code>authorizer_result_ttl_in_seconds</code> argument of the <code>aws_apigatewayv2_authorizer</code> resource: This allows to skip the Authorizer invocation for the given time if a client provided the same identity source values (e.g., authorization header).</p><div class=attention>AWS API Gateway HTTP can employ the identity sources as the cache key to preserve the authorization results for a while. Should a client provide identical parameters in identity sources within the preset TTL duration, API Gateway will retrieve the result from the cached authorizer instead of calling upon it again. This helps save a lot on AWS Lambda Authorizer invocations and works great with simple scenarios. However, it might be cumbersome if you need severral custom authorization responses per function or if you use custom IAM policies instead of the &ldquo;simple response&rdquo; option.</div><p><code>source_arn</code> argument of <code>aws_lambda_permission</code>: Similar to the <code>authorizer_uri</code> argument, this one expects the <strong>execution</strong> ARN of the HTTP API followed by the Authorizer identifier.</p><p>Now, let&rsquo;s see how Routes are codified with Terraform.</p><h3 id=applying-terraform-for-http-api-routes>Applying Terraform for HTTP API Routes<a hidden class=anchor aria-hidden=true href=#applying-terraform-for-http-api-routes>#</a></h3><p>üí° Because an API typically has multiple routes, creating another Terraform module that implements the configurable HTTP API Gateway route is beneficial. Hence, the <code>aws_apigatewayv2_route</code>, <code>aws_apigatewayv2_integration</code>, and <code>aws_lambda_permission</code> resources would constitute such a module.</p><p>This Terraform module implements a specific use case for HTTP API Gateway. However, if you&rsquo;re seeking for a generic all-in-one module for API Gateway, I recommend checking out this one ‚Äî <a href=https://registry.terraform.io/modules/terraform-aws-modules/apigateway-v2/aws/latest>Terraform AWS API Gateway Module</a> by Anton Babenko.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-terraform data-lang=terraform><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_apigatewayv2_route&#34;</span> <span style=color:#a5d6ff>&#34;this&#34;</span> {  
</span></span><span style=display:flex><span>  api_id             = var.api_id  
</span></span><span style=display:flex><span>  route_key          = var.route_key  
</span></span><span style=display:flex><span>  authorization_type = <span style=color:#a5d6ff>&#34;CUSTOM&#34;</span>  
</span></span><span style=display:flex><span>  authorizer_id      = var.authorizer_id  
</span></span><span style=display:flex><span>  target             = <span style=color:#a5d6ff>&#34;integrations/</span><span style=color:#a5d6ff>${</span>aws_apigatewayv2_integration.this.id<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>&#34;</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_apigatewayv2_integration&#34;</span> <span style=color:#a5d6ff>&#34;this&#34;</span> {  
</span></span><span style=display:flex><span>  api_id                 = var.api_id  
</span></span><span style=display:flex><span>  integration_type       = <span style=color:#a5d6ff>&#34;AWS_PROXY&#34;</span>  
</span></span><span style=display:flex><span>  connection_type        = <span style=color:#a5d6ff>&#34;INTERNET&#34;</span>  
</span></span><span style=display:flex><span>  integration_uri        = var.lambda_invocation_arn  
</span></span><span style=display:flex><span>  payload_format_version = <span style=color:#a5d6ff>&#34;2.0&#34;</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_lambda_permission&#34;</span> <span style=color:#a5d6ff>&#34;this&#34;</span> {  
</span></span><span style=display:flex><span>  statement_id  = <span style=color:#a5d6ff>&#34;allowInvokeFromAPIGatewayRoute&#34;</span>  
</span></span><span style=display:flex><span>  action        = <span style=color:#a5d6ff>&#34;lambda:InvokeFunction&#34;</span>  
</span></span><span style=display:flex><span>  function_name = var.lambda_function_name  
</span></span><span style=display:flex><span>  principal     = <span style=color:#a5d6ff>&#34;apigateway.amazonaws.com&#34;</span>  
</span></span><span style=display:flex><span>  source_arn    = <span style=color:#a5d6ff>&#34;</span><span style=color:#a5d6ff>${</span>var.api_gw_execution_arn<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>/*/*/*/*&#34;</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First, I want to highlight several key aspects for understanding the resources&rsquo; arguments within that module.</p><p>The <code>target</code> argument of the <code>aws_apigatewayv2_route</code> resource implies that the integration ID should be prefixed with the &ldquo;<code>integrations/</code>&rdquo; keyword.</p><p>While the <code>connection_type</code> argument of the <code>aws_apigatewayv2_integration</code> resource specifies &ldquo;INTERNET&rdquo;, it does not mean that the Lambda function must have the publicly available URL. This value must be used unless you work with a VPC endpoint for API Gateway for internal usage.</p><p>For the <code>source_arn</code> argument in the <code>aws_lambda_permission</code> resource, similar to earlier, it requires the <strong>execution</strong> ARN of the API. However, this time, it is the integration of the HTTP API Route with Lambda. And the ARN format of this one is different and a bit tricky:</p><p><code>arn:partition:execute-api:region:account-id:api-id/stage/http-method/resource-path</code></p><p>The <code>arn:partition:execute-api:region:account-id:api-id</code> part constitutes the execution ARN of the HTTP API itself, so for the sake of simplicity, I decided to go with wildcards after it.<br><em>For your convenience, here is the <a href=https://docs.aws.amazon.com/apigateway/latest/developerguide/arn-format-reference.html>detailed specification</a> of API Gateway ARNs.</em></p><p>The HTTP API Route module expects several input variables:</p><ul><li><code>authorizer_id</code> ‚Äî the identifier of the Authorizer to use on this route;</li><li><code>route_key</code> ‚Äî the route key for the route, e.g., <code>GET /foo/bar</code>;</li><li><code>api_id</code> ‚Äî the identifier of HTTP API created earlier;</li><li><code>lambda_invocation_arn</code> ‚Äî the Invocation ARN of the Lambda function;</li><li><code>lambda_function_name</code> ‚Äî the name of the Lambda function to integrate with the route;</li><li><code>api_gw_execution_arn</code> ‚Äî the Execution ARN of the HTTP API that invokes a Lambda function.</li></ul><p>Let&rsquo;s take a closer look on API Gateway V2 HTTP API route.</p><p>A route consists of an HTTP method and a resource path with an optional variable. Based on the pre-defined convention, it uses a simplified routing configuration and methods request model (comparable to other APIs).</p><div class=attention><p>While I was working with the HTTP API, I found this simplified approach to be great because it allows easy access to the request context from AWS Lambda functions, for example:</p><ul><li>A path variable in a route, e.g., <code>GET /calendars/{calendar-name}</code>, would be available for the integrated AWS Lambda by its name inside the pathParameter JSON field, e.g., <code>pathParamters.calendar-name</code>, of the event object sent by API to Lambda. In other words, you do not need to explicitly set the mapping between the path variable and its representation to the back-end.</li><li>A request query string is parsed into separate parameter-value pairs and available in the <code>queryStringParameters</code> field of the event object sent by API to Lambda. Again, without the explicit mapping configuration.</li></ul></div><p>Here, you can read more about the Route specification of HTTP API and how to transform requests and responses from the API side if you need to adjust something:</p><ul><li><a href=https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-routes.html>Working with routes for HTTP APIs</a></li><li><a href=https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html>Transforming API requests and responses</a></li></ul><p>Now back to Terraform. Below is the code snippet that illustrates the call of the API Route Terraform module:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-terraform data-lang=terraform><span style=display:flex><span><span style=color:#ff7b72>module</span> <span style=color:#a5d6ff>&#34;route_calendars&#34;</span> {  
</span></span><span style=display:flex><span>  source                = <span style=color:#a5d6ff>&#34;./modules/api-gateway-route&#34;</span>  
</span></span><span style=display:flex><span>  api_id                = aws_apigatewayv2_api.this.id  
</span></span><span style=display:flex><span>  route_key             = <span style=color:#a5d6ff>&#34;GET /calendars/{calendar-name}&#34;</span>  
</span></span><span style=display:flex><span>  api_gw_execution_arn  = aws_apigatewayv2_api.this.execution_arn  
</span></span><span style=display:flex><span>  lambda_invocation_arn = module.lambda_calendar_backend.lambda.invoke_arn  
</span></span><span style=display:flex><span>  lambda_function_name  = module.lambda_calendar_backend.lambda.function_name  
</span></span><span style=display:flex><span>  authorizer_id         = aws_apigatewayv2_authorizer.header_based_authorizer.id  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This module logically relies on both the HTTP API and Lambda resources to configure their integration by implementing the Route.</p><h2 id=enhancing-security-and-monitoring-of-aws-api-gateway-v2-http-api>Enhancing Security and Monitoring of AWS API Gateway V2 HTTP API<a hidden class=anchor aria-hidden=true href=#enhancing-security-and-monitoring-of-aws-api-gateway-v2-http-api>#</a></h2><p>Several additional options are available to monitor and protect the HTTP API: logs, metrics, and throttling.</p><h3 id=overview-of-http-api-monitoring-and-protection-options>Overview of HTTP API monitoring and protection options<a hidden class=anchor aria-hidden=true href=#overview-of-http-api-monitoring-and-protection-options>#</a></h3><p>Logging, metrics, and throttling are configured on the Stage level but allow configuration granularity for the Routes.</p><p>For logs, you can configure the CloudWatch log group, the log format (JSON, CLF, XML, CSV), and content filters. The <a href=https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-logging-variables.html>logging variables</a> allow you to customize the information that appears in logs. I will provide an example of such a configuration later in the article.</p><p>By default, API Gateway sends only API and stage-level metrics to CloudWatch in one-minute periods. However, you can enable <a href=https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-metrics.html>detailed metrics</a> and additionally collect the per-route metrics.</p><p>To safeguard your HTTP API from excessive requests, you can employ throttling settings, which allow you to set limits per individual route as well as for all routes collectively.</p><h3 id=configuring-monitoring-and-protection-for-http-api-with-terraform>Configuring monitoring and protection for HTTP API with Terraform<a hidden class=anchor aria-hidden=true href=#configuring-monitoring-and-protection-for-http-api-with-terraform>#</a></h3><p>Now, let&rsquo;s see how Terraform helps configure the protection and monitoring for HTTP API.</p><p>As mentioned earlier, API Gateway applies these configurations at the Stage level, which is why the aws_apigatewayv2_stage resource encapsulates them all.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-terraform data-lang=terraform><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_apigatewayv2_stage&#34;</span> <span style=color:#a5d6ff>&#34;default&#34;</span> {  
</span></span><span style=display:flex><span>  api_id      = aws_apigatewayv2_api.this.id  
</span></span><span style=display:flex><span>  name        = <span style=color:#a5d6ff>&#34;$default&#34;</span>  
</span></span><span style=display:flex><span>  auto_deploy = <span style=color:#79c0ff>true</span>  
</span></span><span style=display:flex><span>  description = <span style=color:#a5d6ff>&#34;Default stage (i.e., Production mode)&#34;</span>  
</span></span><span style=display:flex><span>  default_route_settings {  
</span></span><span style=display:flex><span>    throttling_burst_limit = <span style=color:#a5d6ff>1</span>  
</span></span><span style=display:flex><span>    throttling_rate_limit  = <span style=color:#a5d6ff>1</span>  
</span></span><span style=display:flex><span>  }  
</span></span><span style=display:flex><span>  access_log_settings {  
</span></span><span style=display:flex><span>    destination_arn = aws_cloudwatch_log_group.api_gateway_logs_inkyframe.arn  
</span></span><span style=display:flex><span>    format = jsonencode({  
</span></span><span style=display:flex><span>      authorizerError           = <span style=color:#a5d6ff>&#34;$context.authorizer.error&#34;</span>,  
</span></span><span style=display:flex><span>      identitySourceIP          = <span style=color:#a5d6ff>&#34;$context.identity.sourceIp&#34;</span>,  
</span></span><span style=display:flex><span>      integrationError          = <span style=color:#a5d6ff>&#34;$context.integration.error&#34;</span>,  
</span></span><span style=display:flex><span>      integrationErrorMessage   = <span style=color:#a5d6ff>&#34;$context.integration.errorMessage&#34;</span>  
</span></span><span style=display:flex><span>      integrationLatency        = <span style=color:#a5d6ff>&#34;$context.integration.latency&#34;</span>,  
</span></span><span style=display:flex><span>      integrationRequestId      = <span style=color:#a5d6ff>&#34;$context.integration.requestId&#34;</span>,  
</span></span><span style=display:flex><span>      integrationStatus         = <span style=color:#a5d6ff>&#34;$context.integration.integrationStatus&#34;</span>,  
</span></span><span style=display:flex><span>      integrationStatusCode     = <span style=color:#a5d6ff>&#34;$context.integration.status&#34;</span>,  
</span></span><span style=display:flex><span>      requestErrorMessage       = <span style=color:#a5d6ff>&#34;$context.error.message&#34;</span>,  
</span></span><span style=display:flex><span>      requestErrorMessageString = <span style=color:#a5d6ff>&#34;$context.error.messageString&#34;</span>,  
</span></span><span style=display:flex><span>      requestId                 = <span style=color:#a5d6ff>&#34;$context.requestId&#34;</span>,  
</span></span><span style=display:flex><span>      routeKey                  = <span style=color:#a5d6ff>&#34;$context.routeKey&#34;</span>,  
</span></span><span style=display:flex><span>    })   
</span></span><span style=display:flex><span>  }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here, I applied the default <a href=https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-throttling.html>throttling settings</a>: for my project, 1 request per second was enough at that point.</p><p>ü§î There is a nuance, though, that makes Terraforming API Gateway a little inconvenient ‚Äî the IAM role that allows API to write logs must be defined on a region level. Therefore, if you maintain several Terraform projects for the same AWS account, you might need to have the following configuration stand separately to avoid conflicts or misunderstandings:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-terraform data-lang=terraform><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_api_gateway_account&#34;</span> <span style=color:#a5d6ff>&#34;this&#34;</span> {  
</span></span><span style=display:flex><span>  cloudwatch_role_arn = aws_iam_role.api_gateway_cloudwatch_logs.arn  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_iam_role&#34;</span> <span style=color:#a5d6ff>&#34;api_gateway_cloudwatch_logs&#34;</span> {  
</span></span><span style=display:flex><span>  name = <span style=color:#a5d6ff>&#34;api-gateway-cloudwatch-logs&#34;</span>  
</span></span><span style=display:flex><span>  assume_role_policy = jsonencode({  
</span></span><span style=display:flex><span>    Version = <span style=color:#a5d6ff>&#34;2012-10-17&#34;</span>  
</span></span><span style=display:flex><span>    Statement = [  
</span></span><span style=display:flex><span>      {  
</span></span><span style=display:flex><span>        Effect = <span style=color:#a5d6ff>&#34;Allow&#34;</span>  
</span></span><span style=display:flex><span>        Principal = {  
</span></span><span style=display:flex><span>          Service = <span style=color:#a5d6ff>&#34;apigateway.amazonaws.com&#34;</span>  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>        Action = <span style=color:#a5d6ff>&#34;sts:AssumeRole&#34;</span>  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>    ]  
</span></span><span style=display:flex><span>  })  
</span></span><span style=display:flex><span>  managed_policy_arns = [<span style=color:#a5d6ff>&#34;arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs&#34;</span>]  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_cloudwatch_log_group&#34;</span> <span style=color:#a5d6ff>&#34;api_gateway_logs_inkyframe&#34;</span> {  
</span></span><span style=display:flex><span>  name              = <span style=color:#a5d6ff>&#34;/aws/apigateway/inkyframe&#34;</span>  
</span></span><span style=display:flex><span>  log_group_class   = <span style=color:#a5d6ff>&#34;STANDARD&#34;</span>  
</span></span><span style=display:flex><span>  retention_in_days = <span style=color:#a5d6ff>7</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And one more thing about HTTP API deployments and stages. I use the special <code>$default</code> keyword to have a single stage (hence, the default one), and I also used automatic deployments: with any change made to API configuration, AWS will automatically generate a new Deployment and bound it with the Stage. If you prefer controlling deployments manually, there is a special resource exists that implements this ‚Äî <code>aws_apigatewayv2_deployment</code></p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-terraform data-lang=terraform><span style=display:flex><span><span style=color:#ff7b72>resource</span> <span style=color:#a5d6ff>&#34;aws_apigatewayv2_deployment&#34;</span> <span style=color:#a5d6ff>&#34;example&#34;</span> {
</span></span><span style=display:flex><span>  api_id      = aws_apigatewayv2_api.example.id
</span></span><span style=display:flex><span>  description = <span style=color:#a5d6ff>&#34;Example deployment&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  triggers = {
</span></span><span style=display:flex><span>    redeployment = sha1(join(<span style=color:#a5d6ff>&#34;,&#34;</span>, tolist([
</span></span><span style=display:flex><span>      jsonencode(aws_apigatewayv2_integration.example),
</span></span><span style=display:flex><span>      jsonencode(aws_apigatewayv2_route.example),
</span></span><span style=display:flex><span>    ])))
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  lifecycle {
</span></span><span style=display:flex><span>    create_before_destroy = <span style=color:#79c0ff>true</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In that case, the <code>aws_apigatewayv2_stage</code> resource requires the <code>deployment_id</code> argument to link itself with a particular Deployment and, therefore, represent the state of the API configuration.</p><p>Also, API Gateway requires at least one configured API Route before the deployment is initiated/created. However, these resources do not explicitly depend on each other via attribute references. To avoid the race condition in Terraform, you need to reference the Route resource in the <code>aws_apigatewayv2_deployment</code> resource via the <code>triggers</code> argument (as shown above) or via the <code>depends_on</code> meta-argument. Otherwise, Terraform will try to apply changes to both resources simultaneously.</p><h2 id=afterword-simplifying-serverless-architectures>Afterword: Simplifying Serverless Architectures<a hidden class=anchor aria-hidden=true href=#afterword-simplifying-serverless-architectures>#</a></h2><p>In wrapping up our exploration of AWS HTTP API Gateway, AWS Lambda, and Terraform, we&rsquo;ve delved into how these powerful tools work in tandem to streamline and enhance serverless architectures. This article aimed to combine my experience with new knowledge and demystify the complexities of used services, showcasing their capabilities in creating efficient, cost-effective solutions for modern cloud-based applications.</p><p>We focused on practical implementation and the tangible benefits of combining these technologies. By leveraging Terraform, we&rsquo;ve seen how infrastructure management can be simplified, allowing for clearer, more maintainable code. The combination of AWS Lambda and HTTP API Gateway has demonstrated the efficiency of serverless computing, offering scalability and performance without the burden of extensive configuration and management.</p><p>This exploration underlines the importance of choosing the right tools and strategies in cloud computing. It reminds developers and architects that creating robust and efficient serverless systems is within reach with a thoughtful approach and the right set of tools. As the cloud landscape continues to evolve, staying informed and adaptable is key to harnessing the full potential of these technologies. üíö</p></div><footer class=post-footer><div class=substack-embedded-container><h3>Subscribe to blog updates!</h3><iframe title=Substack class=substack-embedded-iframe src=https://devdosvid.substack.com/embed height=250 loading=lazy></iframe></div><script src=https://giscus.app/client.js data-repo=vasylenko/devdosvid.blog data-repo-id="MDEwOlJlcG9zaXRvcnkyNDUyNTMxODE=" data-category=General data-category-id=DIC_kwDODp5EPc4CA59c data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=en data-theme=light crossorigin=anonymous async></script><ul class=post-tags></ul><div class=license><p>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nd/4.0/>Creative Commons Attribution-NoDerivatives 4.0 International License</a></p></div><nav class=paginav><a class=prev href=https://devdosvid.blog/2024/04/16/a-deep-dive-into-terraform-static-code-analysis-tools-features-and-comparisons/><span class=title>¬´ Prev</span><br><span>A Deep Dive Into Terraform Static Code Analysis Tools: Features and Comparisons</span>
</a><a class=next href=https://devdosvid.blog/2023/04/16/hello-terraform-data-goodbye-null-resource/><span class=title>Next ¬ª</span><br><span>Hello Terraform Data; Goodbye Null Resource</span></a></nav></footer></article></main><footer class=footer><div style=width:10em;margin:auto><p style=background-color:#0082ca;color:#fff>From Ukrainian</p><p style=background-color:#ffb548;color:#fff>with love ‚ù§Ô∏è</p></div><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>