<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golden Image Pipelines With HCP Packer | devDosvid blog</title>
<meta name=keywords content="packer,terraform,cloud,ami,pipeline,infrastructure as code,ec2 ami,hcp cloud"><meta name=description content="How to create an end-to-end golden image workflow with the HCP Packer image registry"><meta name=author content="Serhii Vasylenko"><link rel=canonical href=https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/><link crossorigin=anonymous href=/assets/css/stylesheet.51adfef0209146fea88d574556a024fb0fe75550725c247200ff67f0bd77de4a.css integrity="sha256-Ua3+8CCRRv6ojVdFVqAk+w/nVVByXCRyAP9n8L133ko=" rel="preload stylesheet" as=style><link rel=icon href=https://devdosvid.blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://devdosvid.blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://devdosvid.blog/favicon-32x32.png><link rel=apple-touch-icon href=https://devdosvid.blog/apple-touch-icon.png><link rel=mask-icon href=https://devdosvid.blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><style>@font-face{font-family:albert sans;font-style:normal;font-display:swap;font-weight:300;src:url(/assets/fonts/AlbertSans-Light.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:italic;font-display:swap;font-weight:300;src:url(/assets/fonts/AlbertSans-LightItalic.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:normal;font-display:swap;font-weight:400;src:url(/assets/fonts/AlbertSans-Regular.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:italic;font-display:swap;font-weight:400;src:url(/assets/fonts/AlbertSans-Italic.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:normal;font-display:swap;font-weight:500;src:url(/assets/fonts/AlbertSans-Medium.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:italic;font-display:swap;font-weight:500;src:url(/assets/fonts/AlbertSans-MediumItalic.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:normal;font-display:swap;font-weight:600;src:url(/assets/fonts/AlbertSans-SemiBold.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:italic;font-display:swap;font-weight:600;src:url(/assets/fonts/AlbertSans-SemiBoldItalic.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style><meta name=twitter:creator content="@vasylenko"><meta name=twitter:site content="@vasylenko"><script defer type=text/javascript>window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{},n=document.createElement("script"),n.type="text/javascript",n.async=!0,n.src="https://cdn.heapanalytics.com/js/heap-"+e+".js",o=document.getElementsByTagName("script")[0],o.parentNode.insertBefore(n,o);for(var n,o,a=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},i=["addEventProperties","addUserProperties","clearEventProperties","identify","resetIdentity","removeEventProperty","setEventProperties","track","unsetEventProperty"],s=0;s<i.length;s++)heap[i[s]]=a(i[s])},heap.load("2300872157")</script><meta property="og:title" content="Golden Image Pipelines With HCP Packer"><meta property="og:description" content="How to create an end-to-end golden image workflow with the HCP Packer image registry"><meta property="og:type" content="article"><meta property="og:url" content="https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/"><meta property="og:image" content="https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/cover-image.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-26T15:13:12+02:00"><meta property="article:modified_time" content="2024-06-04T11:43:20+02:00"><meta property="og:site_name" content="devDosvid blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/cover-image.png"><meta name=twitter:title content="Golden Image Pipelines With HCP Packer"><meta name=twitter:description content="How to create an end-to-end golden image workflow with the HCP Packer image registry"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://devdosvid.blog/posts/"},{"@type":"ListItem","position":2,"name":"Golden Image Pipelines With HCP Packer","item":"https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golden Image Pipelines With HCP Packer","name":"Golden Image Pipelines With HCP Packer","description":"How to create an end-to-end golden image workflow with the HCP Packer image registry","keywords":["packer","terraform","cloud","ami","pipeline","infrastructure as code","ec2 ami","hcp cloud"],"articleBody":"Many of us know and use Packer to build golden images for cloud providers. But did you know that Packer is not just a CLI tool?\nThere is an HCP (stands for HashiCorp Cloud Platform) Packer that acts as the image registry that stores the image metadata, allows you to organize images in distribution channels, and perform other management actions.\nIn this blog, I would like to showcase some features of the HCP Packer and explain how you can use it to set up an image factory for the organization (or for your own fun üôÉ) to maintain the Golden Images.\nI will be using AWS AMI as the OS image appliance for examples in this blog, but Packer supports many other formats and clouds through its plugins.\nHCP Packer Registry HCP Packer is the image metadata registry that stores the information (not an image file) about OS images you create using the Packer CLI tool.\nIt solves the challenge of the Golden Image pipeline maintenance by acting as a hub that organizes and streamlines the processes of OS image creation, usage, and continuity.\nOS Image lifecycle with HCP Packer\nHCP Packer introduces several new concepts that compose the registry: Image Buckets, Iterations, and Channels. Further in this blog, I will explain them, but let‚Äôs start with security first.\nSecurity First ‚Äî Creating Service Principals Before launching the builds, you need to create a Service Principal to allow your local Packer CLI to communicate with the HCP.\nI recommend creating at least two principals: the one with the ‚Äúcontributor‚Äù role ‚Äî used by Packer CLI to store the image metadata in HCP; and another one with the ‚Äúviewer‚Äù role ‚Äî used by Terraform (as it requires only read-level access for Packer HCP).\nService Principals for HCP\nOnce you have created a principal, you can generate a key for authentication. The key consists of an ID and a secret.\nBoth the Packer CLI and the Packer Terraform provider support environment variables for the principal client ID and client secret for authentication:\nHCP_CLIENT_ID and HCP_CLIENT_SECRET\nImage Buckets to Store Image Metadata The central entity in HCP Packer is the Image Buckets.\nImage Bucket is a repository where the metadata from a Packer template is stored once image(s) creation is completed.\nImage Bucket can contain a single image or several images if you define several sources for the build block in the Packet template.\nFor example, a bucket can span several custom AMIs based on Ubuntu AMI provided by Amazon and built and distributed within several regions.\nYou cannot create buckets manually from the web interface (at least as of June 2022), but I will show you how they are defined as code inside a Packer template file just a bit later.\nHCP Packer Image Buckets\nIterations of Image Creation Every execution of the build action made by Packer CLI (if used in conjunction with HCP) is recorded specially and called Iteration.\nEach Iteration has a unique fingerprint ‚Äî an SHA value of the head reference in the Git repository that contains your Packer template.\nTip: you can override that with the HCP_PACKER_BUILD_FINGERPRINT env variable if you want to set the Iteration ID manually. HCP Packer Iterations\nEvery Iteration consists of at least one Build ‚Äî another special record that contains image metadata produced by Packer CLI.\nThe Builds inside Iteration are represented by the number of sources specified in your Packer template‚Äôs build section.\nHCP Packer Iteration Builds\nPacker Template Configuration for HCP Let‚Äôs now review a code example to understand how all this combines.\nHere is a build block from Packer template file.\nHCP Packer registry usage in a Packer template\nLook at the hcp_packer_registry block: it defines the Bucket where Packer will store image information and custom labels for the Bucket and the image.\nThe bucket_name defines my Image Bucket: Packer will either use the existing Bucket with that name or create a new one if it does not exist.\nThe bucket_labels map defines custom labels you specify for an Image Bucket. In my example, I set the Bucket owner and the OS name.\nThe build_labels map defines custom labels for the Builds within the Iteration inside a bucket.\nAnd because I define two sources here, my Iteration will have two Builds inside it.\nUsing Channels Although all Iterations have unique identifiers, giving a familiar name to some of them would be more convenient.\nChannel is a way to assign a specific Iteration to a friendly name that you can use later:\nin other Packer templates, if you want to use your custom image as the base for other images in Terraform code (we will review this further) to reference the image by the channel name, avoiding the hard code of the image ID. Channels are created through the web interface or using the API. And I hope HashiCorp will add HCP Packer resources to the HCP Terraform provider in the future so channel creation can be described as code.\nHCP Packer Image Channel\nYou can manually promote an Iteration to a channel with a web interface.\nBut before promoting an Iteration to a channel, you might want to perform the following:\ntest and validate the newly created image before its promotion to a channel: create a temporary virtual machine using Terraform and ensure it successfully boots from the image.\nassess that VM with some vulnerability scanning service. For example, if you‚Äôre an AWS customer, then Amazon Inspector might work for you in such a case.\nOnce an image from the Iteration is validated and passed the security assessment, it‚Äôs safe to promote that Iteration to a channel.\nHCP Packer provides a rich API that you can leverage to automate that process.\nWhen a packer build successfully finishes its execution, it returns the Iteration ID (ULID) that you can use later for an API call with a request to promote the new Iteration to a channel.\nPacker build output with Iteration ULID\nThe ‚ÄúUpdate Channel‚Äù PATCH API method is needed to assign the Iteration to a channel.\nFirst, you need to obtain the access token as described in this guide.\nThen, the following cURL request can be used to update the channel with a new Iteration ULID (please expand the code snippet below):\nClick here to see the code snippet HCP_ACCESS_TOKEN=\"your token here\" HCP_ORG_ID=\"your org id here\" HCP_PROJECT_ID=\"your project id here\" HCP_BUCKET_NAME=\"amazon-linux2\" HCP_CHANNEL_NAME=\"stable\" HCP_BASE_URL=\"https://api.cloud.hashicorp.com/packer/2021-04-30\" curl -X PATCH \\ --header \"Authorization: Bearer $HCP_ACCESS_TOKEN\" \\ --data '{ \"incremental_version\":\"3\", \"iteration_id\":\"01H8V7WBDWRBCMZDZ2HG3MKSDL\" }' \\ \"${HCP_BASE_URL}/organizations/${HCP_ORG_ID}/projects/${HCP_PROJECT_ID}/images/${HCP_BUCKET_NAME}/channels/${HCP_CHANNEL_NAME}\" Using HCP Packer with Terraform Having a streamlined golden image creation process is good. Still, it would be even better to have an easy way to always use the latest validated image without hardcoding or some other duck taping.\nWith the help of the HCP Terraform provider, you can reference the image channel in your Terraform code and have a completed end-to-end workflow.\nHere is an example of the Terraform configuration that uses the HCP Packer registry as the source of AMI ID for an AWS instance:\nUsing HCP Packer registry with Terraform\nTwo data sources do all the magic here.\nThe hcp_packer_iteration data source gets the most recent Iteration assigned to the specified Channel (i.e., latest). We need that because the Iteration (not the Channel) holds the image information.\nThen the hcp_packer_image gets the cloud image ID (AWS AMI ID in my example) from that Iteration so you can use it later in your code.\nThe configuration of the hcp provider in this example is empty on purpose: this provider supports HCP_CLIENT_ID and HCP_CLIENT_SECRET env variables to use their values for the authentication and avoid hard coding. Alternatively, you can use the client_id and client_secret options to configure the provider.\nImage revocation It is possible to revoke a specific Iteration, and therefore all Images in it, to alert the users about the Image decommission. For example, your SecOps team can revoke it due to the new CVE announced.\nRevoked Images are treated differently by Packer CLI and Terraform CLI.\nPacker CLI and Revoked Image When you reference the Image in a Packer template to use it as a source for another image, its revocation makes further Packer builds to fail.\nIn other words, Packer won‚Äôt let you build a new Image on top of the revoked Image.\nTerraform CLI and Revoked Image On the contrary, Terraform CLI does not prevent the usage of the revoked Image by default, although its Cloud version does it if used with the ‚ÄúRun tasks‚Äù feature.\nAlthough you can get the Image ID, when the Iteration is revoked, the hcp_packer_image data source returns a non-empty revoke_at attribute with the value set to the revocation timestamp.\nTherefore, you can use the precondition (available in Terraform CLI v1.2.0 and higher) to validate the Image with Terraform CLI and make sure it was not revoked\nHere is the code example that illustrates that:\nWork with revoked HCP Packer image in Terraform\nWhy HCP Packer? So what makes the HCP Packer a good fit and worth a try?\n1Ô∏è‚É£ A centralized place to view and manage the OS images throughout an organization. And as for me, it is good to have a neat web panel to look at things.\n2Ô∏è‚É£ Image Channels that help with logical organization and control.\n3Ô∏è‚É£ Ability to revoke an image to prevent its usage.\n4Ô∏è‚É£ API and Terraform provider as additional tools that enrich the user experience.\nWhen dealing with multiple golden images or with various cloud providers, the HCP Packer can be a good fit for your image pipeline.\nAs a registry, it enables the end-to-end workflow for golden image usage: create, validate, use and decommission the images in a centralized way.\nAnd no more hard-coded IDs, manual variable settings, or other duck tape and glue in your Terraform.\nIf you want to learn more about HCP Packer and have some practice, I suggest starting from the tutorial at HashiCorp Learn portal.\n","wordCount":"1650","inLanguage":"en","image":"https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/cover-image.png","datePublished":"2022-06-26T15:13:12+02:00","dateModified":"2024-06-04T11:43:20+02:00","author":{"@type":"Person","name":"Serhii Vasylenko"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/"},"publisher":{"@type":"Person","name":"devDosvid blog","logo":{"@type":"ImageObject","url":"https://devdosvid.blog/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://devdosvid.blog/ accesskey=h title="üè† Home (Alt + H)">üè† Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://devdosvid.blog/index.xml title="RSS Feed"><span>RSS Feed</span></a></li><li><a href=https://devdosvid.blog/archive title="All posts"><span>All posts</span></a></li><li><a href=https://devdosvid.blog/about/ title="About me"><span>About me</span></a></li><li><a href=https://devdosvid.blog/series title="Post Series"><span>Post Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://devdosvid.blog/>Home</a>&nbsp;¬ª&nbsp;<a href=https://devdosvid.blog/posts/>Posts</a></div><h1 class=post-title>Golden Image Pipelines With HCP Packer</h1><div class=post-description>How to create an end-to-end golden image workflow with the HCP Packer image registry</div><div class=post-meta><span title='2022-06-26 15:13:12 +0200 +0200'>June 26, 2022</span>&nbsp;¬∑&nbsp;Serhii Vasylenko&nbsp;|&nbsp;<a href=mailto:contact@devdosvid.blog rel="noopener noreferrer" target=_blank>Contact me</a></div></header><figure class=entry-cover><img srcset="https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/cover-image_hua178784282e5bdced56932a792bf8e1d_29893_360x0_resize_box_3.png 360w ,https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/cover-image_hua178784282e5bdced56932a792bf8e1d_29893_480x0_resize_box_3.png 480w ,https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/cover-image_hua178784282e5bdced56932a792bf8e1d_29893_720x0_resize_box_3.png 720w ,https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/cover-image_hua178784282e5bdced56932a792bf8e1d_29893_1080x0_resize_box_3.png 1080w ,https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/cover-image.png 1200w" sizes="(min-width: 768px) 720px, 100vw" src=https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/cover-image.png alt width=1200 height=630></figure><div class=post-content><p>Many of us know and use Packer to build golden images for cloud providers. But did you know that Packer is not just a CLI tool?</p><p>There is an HCP (<em>stands for <strong>H</strong>ashiCorp <strong>C</strong>loud <strong>P</strong>latform</em>) Packer that acts as the image registry that stores the image metadata, allows you to organize images in distribution channels, and perform other management actions.</p><p>In this blog, I would like to showcase some features of the HCP Packer and explain how you can use it to set up an image factory for the organization (or for your own fun üôÉ) to maintain the Golden Images.</p><p>I will be using AWS AMI as the OS image appliance for examples in this blog, but Packer supports many other formats and clouds through its <a href=https://www.packer.io/plugins>plugins</a>.</p><h2 id=hcp-packer-registry>HCP Packer Registry<a hidden class=anchor aria-hidden=true href=#hcp-packer-registry>#</a></h2><p>HCP Packer is the image metadata registry that stores the information (not an image file) about OS images you create using the Packer CLI tool.</p><p>It solves the challenge of the Golden Image pipeline maintenance by acting as a hub that organizes and streamlines the processes of OS image creation, usage, and continuity.</p><figure><img loading=lazy src=hcp-packer-how-it-works.png alt="OS Image lifecycle with HCP Packer" width=800 height=400><figcaption><p>OS Image lifecycle with HCP Packer</p></figcaption></figure><p>HCP Packer introduces several new concepts that compose the registry: Image Buckets, Iterations, and Channels. Further in this blog, I will explain them, but let&rsquo;s start with security first.</p><h2 id=security-first--creating-service-principals>Security First ‚Äî Creating Service Principals<a hidden class=anchor aria-hidden=true href=#security-first--creating-service-principals>#</a></h2><p>Before launching the builds, you need to create a Service Principal to allow your local Packer CLI to communicate with the HCP.</p><p>I recommend creating at least two principals: the one with the &ldquo;contributor&rdquo; role ‚Äî used by Packer CLI to store the image metadata in HCP; and another one with the &ldquo;viewer&rdquo; role ‚Äî used by Terraform (as it requires only read-level access for Packer HCP).</p><figure><img loading=lazy src=hcp-packer-service-principals.png alt="Service Principals for HCP" width=800 height=237.88><figcaption><p>Service Principals for HCP</p></figcaption></figure><p>Once you have created a principal, you can generate a key for authentication. The key consists of an ID and a secret.</p><div class=attention><p>Both the Packer CLI and the Packer Terraform provider support environment variables for the principal client ID and client secret for authentication:</p><p><code>HCP_CLIENT_ID</code> and <code>HCP_CLIENT_SECRET</code></p></div><h2 id=image-buckets-to-store-image-metadata>Image Buckets to Store Image Metadata<a hidden class=anchor aria-hidden=true href=#image-buckets-to-store-image-metadata>#</a></h2><p>The central entity in HCP Packer is the Image Buckets.</p><p><strong>Image Bucket</strong> is a repository where the metadata from a Packer template is stored once image(s) creation is completed.</p><p>Image Bucket can contain a single image or several images if you define several sources for the <code>build</code> block in the Packet template.</p><p>For example, a bucket can span several custom AMIs based on Ubuntu AMI provided by Amazon and built and distributed within several regions.</p><p>You cannot create buckets manually from the web interface (at least as of June 2022), but I will show you how they are defined as code inside a Packer template file just a bit later.</p><figure><img loading=lazy src=image-buckets.png alt="HCP Packer Image Buckets" width=800 height=278.87><figcaption><p>HCP Packer Image Buckets</p></figcaption></figure><h2 id=iterations-of-image-creation>Iterations of Image Creation<a hidden class=anchor aria-hidden=true href=#iterations-of-image-creation>#</a></h2><p>Every execution of the <code>build</code> action made by Packer CLI (if used in conjunction with HCP) is recorded specially and called <strong>Iteration</strong>.</p><p>Each Iteration has a unique fingerprint ‚Äî an SHA value of the head reference in the Git repository that contains your Packer template.</p><div class=attention>Tip: you can override that with the <code>HCP_PACKER_BUILD_FINGERPRINT</code> env variable if you want to set the Iteration ID manually.</div><figure><img loading=lazy src=packer-iterations.png alt="HCP Packer Iterations" width=800 height=278.87><figcaption><p>HCP Packer Iterations</p></figcaption></figure><p>Every Iteration consists of at least one Build ‚Äî another special record that contains image metadata produced by Packer CLI.</p><p>The Builds inside Iteration are represented by the number of sources specified in your Packer template&rsquo;s <code>build</code> section.</p><figure><img loading=lazy src=packer-iteration-builds.png alt="HCP Packer Iteration Builds" width=800 height=574.57><figcaption><p>HCP Packer Iteration Builds</p></figcaption></figure><h2 id=packer-template-configuration-for-hcp>Packer Template Configuration for HCP<a hidden class=anchor aria-hidden=true href=#packer-template-configuration-for-hcp>#</a></h2><p>Let&rsquo;s now review a code example to understand how all this combines.</p><p>Here is a <code>build</code> block from Packer template file.</p><figure><img loading=lazy src=packer-template-example.png alt="HCP Packer registry usage in a Packer template" width=800 height=554.00><figcaption><p>HCP Packer registry usage in a Packer template</p></figcaption></figure><p>Look at the <code>hcp_packer_registry</code> block: it defines the Bucket where Packer will store image information and custom labels for the Bucket and the image.</p><p>The <code>bucket_name</code> defines my Image Bucket: Packer will either use the existing Bucket with that name or create a new one if it does not exist.</p><p>The <code>bucket_labels</code> map defines custom labels you specify for an Image Bucket. In my example, I set the Bucket owner and the OS name.</p><p>The <code>build_labels</code> map defines custom labels for the Builds within the Iteration inside a bucket.</p><p>And because I define two <code>sources</code> here, my Iteration will have two Builds inside it.</p><h2 id=using-channels>Using Channels<a hidden class=anchor aria-hidden=true href=#using-channels>#</a></h2><p>Although all Iterations have unique identifiers, giving a familiar name to some of them would be more convenient.</p><p><strong>Channel</strong> is a way to assign a specific Iteration to a friendly name that you can use later:</p><ul><li>in other Packer templates, if you want to use your custom image as the base for other images</li><li>in Terraform code (we will review this further) to reference the image by the channel name, avoiding the hard code of the image ID.</li></ul><p>Channels are created through the web interface or using the API. And I hope HashiCorp will add HCP Packer resources to the HCP Terraform provider in the future so channel creation can be described as code.</p><figure><img loading=lazy src=hcp-packer-image-channel.png alt="HCP Packer Image Channel" width=800 height=338.15><figcaption><p>HCP Packer Image Channel</p></figcaption></figure><p>You can manually promote an Iteration to a channel with a web interface.</p><p>But before promoting an Iteration to a channel, you might want to perform the following:</p><ul><li><p>test and validate the newly created image before its promotion to a channel: create a temporary virtual machine using Terraform and ensure it successfully boots from the image.</p></li><li><p>assess that VM with some vulnerability scanning service. For example, if you&rsquo;re an AWS customer, then <a href=https://docs.aws.amazon.com/inspector/latest/user/what-is-inspector.html>Amazon Inspector</a> might work for you in such a case.</p></li></ul><p>Once an image from the Iteration is validated and passed the security assessment, it&rsquo;s safe to promote that Iteration to a channel.</p><p>HCP Packer provides a rich <a href=https://cloud.hashicorp.com/api-docs/packer>API</a> that you can leverage to automate that process.</p><p>When a <code>packer build</code> successfully finishes its execution, it returns the Iteration ID (ULID) that you can use later for an API call with a request to promote the new Iteration to a channel.</p><figure><img loading=lazy src=packer-build-output.png alt="Packer build output with Iteration ULID" width=800 height=218.00><figcaption><p>Packer build output with Iteration ULID</p></figcaption></figure><p>The &ldquo;Update Channel&rdquo; PATCH API method is needed to assign the Iteration to a channel.</p><p>First, you need to obtain the access token as described in <a href=https://support.hashicorp.com/hc/en-us/articles/6676505991699-HCP-API-Authentication-with-Curl>this guide</a>.</p><p>Then, the following cURL request can be used to update the channel with a new Iteration ULID (please expand the code snippet below):</p><div class=code-snippet><details><summary markdown=span>Click here to see the code snippet</summary><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#79c0ff>HCP_ACCESS_TOKEN</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#34;your token here&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#79c0ff>HCP_ORG_ID</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#34;your org id here&#34;</span>
</span></span><span style=display:flex><span><span style=color:#79c0ff>HCP_PROJECT_ID</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#34;your project id here&#34;</span>
</span></span><span style=display:flex><span><span style=color:#79c0ff>HCP_BUCKET_NAME</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#34;amazon-linux2&#34;</span>
</span></span><span style=display:flex><span><span style=color:#79c0ff>HCP_CHANNEL_NAME</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#34;stable&#34;</span>
</span></span><span style=display:flex><span><span style=color:#79c0ff>HCP_BASE_URL</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#34;https://api.cloud.hashicorp.com/packer/2021-04-30&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>curl -X PATCH <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>--header <span style=color:#a5d6ff>&#34;Authorization: Bearer </span><span style=color:#79c0ff>$HCP_ACCESS_TOKEN</span><span style=color:#a5d6ff>&#34;</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>--data <span style=color:#a5d6ff>&#39;{
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>&#34;incremental_version&#34;:&#34;3&#34;,
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>&#34;iteration_id&#34;:&#34;01H8V7WBDWRBCMZDZ2HG3MKSDL&#34;
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>}&#39;</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span><span style=color:#a5d6ff>&#34;</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>HCP_BASE_URL</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>/organizations/</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>HCP_ORG_ID</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>/projects/</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>HCP_PROJECT_ID</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>/images/</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>HCP_BUCKET_NAME</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>/channels/</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>HCP_CHANNEL_NAME</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>&#34;</span>
</span></span></code></pre></div></details></div><h2 id=using-hcp-packer-with-terraform>Using HCP Packer with Terraform<a hidden class=anchor aria-hidden=true href=#using-hcp-packer-with-terraform>#</a></h2><p>Having a streamlined golden image creation process is good. Still, it would be even better to have an easy way to always use the latest validated image without hardcoding or some other duck taping.</p><p>With the help of the <a href=https://registry.terraform.io/providers/hashicorp/hcp>HCP Terraform provider</a>, you can reference the image channel in your Terraform code and have a completed end-to-end workflow.</p><p>Here is an example of the Terraform configuration that uses the HCP Packer registry as the source of AMI ID for an AWS instance:</p><figure><img loading=lazy src=terraform-hcp-packer.png alt="Using HCP Packer registry with Terraform" width=800 height=529.00><figcaption><p>Using HCP Packer registry with Terraform</p></figcaption></figure><p>Two data sources do all the magic here.</p><p>The <code>hcp_packer_iteration</code> data source gets the most recent Iteration assigned to the specified Channel (i.e., latest). We need that because the Iteration (not the Channel) holds the image information.</p><p>Then the <code>hcp_packer_image</code> gets the cloud image ID (AWS AMI ID in my example) from that Iteration so you can use it later in your code.</p><p>The configuration of the <code>hcp</code> provider in this example is empty on purpose: this provider supports <code>HCP_CLIENT_ID</code> and <code>HCP_CLIENT_SECRET</code> env variables to use their values for the <a href=https://registry.terraform.io/providers/hashicorp/hcp/latest/docs/guides/auth>authentication</a> and avoid hard coding. Alternatively, you can use the <code>client_id</code> and <code>client_secret</code> options to configure the provider.</p><h2 id=image-revocation>Image revocation<a hidden class=anchor aria-hidden=true href=#image-revocation>#</a></h2><p>It is possible to revoke a specific Iteration, and therefore all Images in it, to alert the users about the Image decommission. For example, your SecOps team can revoke it due to the new CVE announced.</p><p>Revoked Images are treated differently by Packer CLI and Terraform CLI.</p><h3 id=packer-cli-and-revoked-image>Packer CLI and Revoked Image<a hidden class=anchor aria-hidden=true href=#packer-cli-and-revoked-image>#</a></h3><p>When you reference the Image in a Packer template to use it as a source for another image, its revocation makes further Packer builds to fail.</p><p>In other words, Packer won&rsquo;t let you build a new Image on top of the revoked Image.</p><h3 id=terraform-cli-and-revoked-image>Terraform CLI and Revoked Image<a hidden class=anchor aria-hidden=true href=#terraform-cli-and-revoked-image>#</a></h3><p>On the contrary, Terraform CLI does not prevent the usage of the revoked Image by default, although its Cloud version does it if used with the &ldquo;Run tasks&rdquo; feature.</p><p>Although you can get the Image ID, when the Iteration is revoked, the <code>hcp_packer_image</code> data source returns a non-empty <code>revoke_at</code> attribute with the value set to the revocation timestamp.</p><p>Therefore, you can use the <code>precondition</code> (available in <a href=https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/#precondition-and-postcondition>Terraform CLI v1.2.0</a> and higher) to validate the Image with Terraform CLI and make sure it was not revoked</p><p>Here is the code example that illustrates that:</p><figure><img loading=lazy src=logic-for-revoked-iteration.png alt="Work with revoked HCP Packer image in Terraform" width=800 height=501.24><figcaption><p>Work with revoked HCP Packer image in Terraform</p></figcaption></figure><h2 id=why-hcp-packer>Why HCP Packer?<a hidden class=anchor aria-hidden=true href=#why-hcp-packer>#</a></h2><p>So what makes the HCP Packer a good fit and worth a try?</p><p>1Ô∏è‚É£ A centralized place to view and manage the OS images throughout an organization. And as for me, it is good to have a neat web panel to look at things.</p><p>2Ô∏è‚É£ Image Channels that help with logical organization and control.</p><p>3Ô∏è‚É£ Ability to revoke an image to prevent its usage.</p><p>4Ô∏è‚É£ API and Terraform provider as additional tools that enrich the user experience.</p><p>When dealing with multiple golden images or with various cloud providers, the <a href=https://cloud.hashicorp.com/products/packer>HCP Packer</a> can be a good fit for your image pipeline.</p><p>As a registry, it enables the end-to-end workflow for golden image usage: create, validate, use and decommission the images in a centralized way.</p><p>And no more hard-coded IDs, manual variable settings, or other duck tape and glue in your Terraform.</p><p>If you want to learn more about HCP Packer and have some practice, I suggest starting from the <a href=https://learn.hashicorp.com/collections/packer/hcp>tutorial at HashiCorp Learn portal</a>.</p></div><footer class=post-footer><div class=substack-embedded-container><h3>Subscribe to blog updates!</h3><iframe title=Substack class=substack-embedded-iframe src=https://devdosvid.substack.com/embed height=250 loading=lazy></iframe></div><script src=https://giscus.app/client.js data-repo=vasylenko/devdosvid.blog data-repo-id="MDEwOlJlcG9zaXRvcnkyNDUyNTMxODE=" data-category=General data-category-id=DIC_kwDODp5EPc4CA59c data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=en data-theme=purge crossorigin=anonymous async></script><ul class=post-tags></ul><div class=license><p>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nd/4.0/>Creative Commons Attribution-NoDerivatives 4.0 International License</a></p></div><nav class=paginav><a class=prev href=https://devdosvid.blog/2022/07/24/five-practical-ways-to-get-the-verified-ec2-ami/><span class=title>¬´ Prev</span><br><span>Five Practical Ways To Get The Verified EC2 AMI</span>
</a><a class=next href=https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/><span class=title>Next ¬ª</span><br><span>New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2</span></a></nav></footer></article></main><footer class=footer><div style=width:10em;margin:auto><p style=background-color:#0082ca;color:#fff>From Ukrainian</p><p style=background-color:#ffb548;color:#fff>with love ‚ù§Ô∏è</p></div><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>