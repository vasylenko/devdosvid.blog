<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2 | devDosvid ‚Äî technical blog about my cloud engineering experience</title><meta name=keywords content="terraform,refactoring,experience"><meta name=description content="New features that expand resources management options"><meta name=author content="Serhii Vasylenko"><link rel=canonical href=https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/><link crossorigin=anonymous href=/assets/css/stylesheet.min.9da7bb9786f7a214c9af6a267b749501326492297eefc2c460f2b4da3e4c4c7b.css integrity="sha256-nae7l4b3ohTJr2ome3SVATJkkil+78LEYPK02j5MTHs=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://devdosvid.blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://devdosvid.blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://devdosvid.blog/favicon-32x32.png><link rel=apple-touch-icon href=https://devdosvid.blog/apple-touch-icon.png><link rel=mask-icon href=https://devdosvid.blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript>window.heap=window.heap||[],heap.load=function(i,o){window.heap.appid=i,window.heap.config=o=o||{},e=document.createElement("script"),e.type="text/javascript",e.async=!0,e.src="https://cdn.heapanalytics.com/js/heap-"+i+".js",n=document.getElementsByTagName("script")[0],n.parentNode.insertBefore(e,n);for(var e,n,a=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},s=["addEventProperties","addUserProperties","clearEventProperties","identify","resetIdentity","removeEventProperty","setEventProperties","track","unsetEventProperty"],t=0;t<s.length;t++)heap[s[t]]=a(s[t])},heap.load("2300872157")</script><meta property="og:title" content="New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2"><meta property="og:description" content="New features that expand resources management options"><meta property="og:type" content="article"><meta property="og:url" content="https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/"><meta property="og:image" content="https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-04T22:27:47+02:00"><meta property="article:modified_time" content="2022-05-05T05:20:14+03:00"><meta property="og:site_name" content="devDosvid ‚Äî technical blog about my cloud engineering experience"><meta property="og:see_also" content="https://devdosvid.blog/2022/01/16/some-techniques-to-enhance-your-terraform-proficiency/"><meta property="og:see_also" content="https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/"><meta property="og:see_also" content="https://devdosvid.blog/2020/08/25/terraform-cli-shortcuts/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image.png"><meta name=twitter:title content="New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2"><meta name=twitter:description content="New features that expand resources management options"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://devdosvid.blog/posts/"},{"@type":"ListItem","position":3,"name":"New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2","item":"https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2","name":"New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2","description":"New features that expand resources management options","keywords":["terraform","refactoring","experience"],"articleBody":"In this blog, I would like to tell you about new cool features that Terraform 1.1 and 1.2 bring. It feels like Terraform has doubled its speed of delivering the new features after they released the 1.0. ü§©\nIt‚Äôs been only a few months since Terraform 1.1 was released with the moved block that empowers the code refactoring.\nNow Terraform 1.2 is almost ready (as I am writing this blog in early May 2022) to bring three new efficient controls to the resource lifecycle.\nThese are three new expressions: precondition, postcondition, and replace_triggered_by.\nTerraform Code Refactoring With the Moved Block Starting from the 1.1 version, Terraform users can use the moved block to describe the changes in resource or module addresses (or resources inside a module) in the form of code. Once that is described, Terraform performs the movement of the resource within the state during the first apply.\nIn other words, what this feature gives you, is the ability to document your terraform state mv actions, so you and other project or module users don‚Äôt need to perform them manually.\nAs your code evolves, a resource or module can have several moved blocks associated with it, and Terraform will thoroughly reproduce the whole history of its movement within a state (i.e., renaming).\nLet‚Äôs review some examples that illustrate how it works.\nMoving a resource In a module, I have a bucket policy that has a generic, meaningless name. It is used in a module that creates a CloudFront distribution with an S3 bucket.\n  An example resource\n  It‚Äôs pretty OK to name a resource like that if you have only a single instance of that kind in your code.\nLater, when I need to add another policy to the module, I don‚Äôt want to name it ‚Äúthat‚Äù. Instead, I want my policies to have meaningful names now.\nFor example, I could rename the old policy with the terraform state mv command, but other users of my module would not know about that.\nThat is where the moved block turns out to be helpful: I can document the name change, and later, everyone else who uses my module will get the same renaming.\n  Resource address update with the Moved block\n  Terraform follows the instructions inside the module block to plan and apply changes. Although the resource address update is not counted as a change in the Plan output, Terraform will perform that update during apply.\n  Terraform plan output\n  Moving a module The same approach can be applied to a module.\nHere, I use two modules to create static hosting for a website with a custom TLS certificate.\n  Two modules with generic names\n  Again, if I need to add another couple of the CDN+Certificate modules, I would like to have meaningful names in my code so clearly distinguish one from another.\nTherefore, I would add two moved blocks ‚Äî one per module call.\nAnd by the way, since I renamed the module (from cert to example_com_cert), I need to update all references to that module‚Äôs outputs in the code too.\n  Two modules renamed\n  However, there is one nuance: when you rename a module and declare that in the moved block, you need to run the terraform init before applying the change because Terraform must initialize the module with the new name first.\n  Terraform error: module not installed\n  There are some more advanced actions you can make with the moved block:\n Implement count and for_each meta-arguments to resources and modules Break one module into multiple Check the following detailed guide from HashiCorp that explains how to do that ‚Äî Refactoring  Introducing the moved blocks into your codebase defacto starts the refactoring process for your module users. But the finale of that refactoring happens when you ultimately remove these blocks.\nTherefore, here is some advice on how to manage that:\n  Keep the moved blocks in your code for long. For example, when removing a moved block from the code, Terraform does not treat the new object name as a renaming anymore. Instead, Terraform will plan to delete the resource or module with the old name instead of renaming it.\n  Keep the complete chains of object renaming (sequence of moves). The whole history of object movement ensures that users with different module versions will get a consistent and predictable behavior of the refactoring.\n   Lifecycle expressions: precondition, postcondition, and replace_triggered_by Terraform 1.2 fundamentally improves the lifecycle meta-argument by adding three new configuration options with rich capabilities.\n  New configuration options for the lifecycle meta-argument\n  Precondition and Postcondition When you need to make sure that specific condition is met before or after you create a resource, you can use postcondition and precondition blocks.\nThe condition here ‚Äî is some data or information about a resource you need to confirm to apply the code.\nHere are a few examples of such conditions:\n Validate some attributes of the Data Source that you cannot check using filters or other available arguments; Confirm the Resource argument that can compound several variables (e.g., list);  Precondition works as an expectation or a guess about some external (but within a module) value that a resource depends on.\nPostcondition works as the assurance that a resource fulfills a specific condition so other resources may rely on that. If postcondition fails for a resource, this prevents changes to all other resources that depend on it.\n Let‚Äôs review this new feature with an example of postcondition usage.\nConsider the following case: our module receives AMI ID as the input variable, and that AMI should be used in the Launch Template then; we also have the requirement for the EC2 instance created from that Launch Template ‚Äî its root EBS size must be equal or bigger than 600 GB.\nWe cannot validate the EBS size using the variable that accepts the AMI ID. But we can write a postcondition for the Data Source that gets the information about the AMI and reference that Data Source in the Launch Template resource afterward.\n  Data Source Postcondition\n  The condition argument within the block accepts any of Terraform‚Äôs built-in functions or language operators.\nThe special self object is available only for the postcondition block because it assumes that validation can be performed after the object is created and its attributes are known.\nLater, if a module user specifies the AMI with an EBS size lesser than 600 GB, Terraform will fail to create the Launch Template because it depends on the Data Source that did not pass the postcondition check.\n  Resource postcondition error\n  Terraform tries to evaluate the condition expressions as soonest: sometimes Terraform can check the value during the planning phase, but sometimes that can be done only after the resource is created if the value is unknown.\nValidating module output with precondition The precondition block is also available for the module outputs.\nJust like the variable validation block assures that module input meets certain expectations, the precondition is intended to ensure that a module produces the valid output.\nHere is an example: a module that creates an ACM certificate must prevent the usage of a specific domain name in the certificate‚Äôs Common Name or its SANs.\n  Module output precondition\n  In this case, instead of validating several input variables, we can write the validation only once for the output.\nTrigger resource replacement with replace_triggered_by Sometimes it‚Äôs needed to specify the dependency in the way that recreates a resource when another resource or its attribute changes.\nThis is useful when two (or more) resources do not have any explicit dependency.\nConsider the following case: you have two EC2 instances, A and B, and need to recreate the B instance if the private IP of instance A is changed.\n  replace_triggered_by example\n  This is extremely useful when you‚Äôre dealing with logical abstractions over the set of resources.\nReplacement is triggered when:\n any of the resources referenced in replace_triggered_by are updated any value is set to the resource attribute that is referenced in replace_triggered_by   Getting started with Terraform 1.1 and 1.2 If you‚Äôre still using older Terraform versions, these new features might be a good motivation for you to upgrade!\nBefore upgrading, be sure to read the upgrade notes for the specific version at the releases page.\nAlso, an excellent tool can help with fast switching between different Terraform versions while you‚Äôre experimenting ‚Äî tfswitch.\n","wordCount":"1379","inLanguage":"en","image":"https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image.png","datePublished":"2022-05-04T22:27:47+02:00","dateModified":"2022-05-05T05:20:14+03:00","author":{"@type":"Person","name":"Serhii Vasylenko"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/"},"publisher":{"@type":"Person","name":"devDosvid ‚Äî technical blog about my cloud engineering experience","logo":{"@type":"ImageObject","url":"https://devdosvid.blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://devdosvid.blog accesskey=h title="üè† Home (Alt + H)">üè† Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://devdosvid.blog/index.xml title="RSS Feed"><span>RSS Feed</span></a></li><li><a href=https://devdosvid.blog/archive title="All posts"><span>All posts</span></a></li><li><a href=https://devdosvid.blog/about/ title="About me"><span>About me</span></a></li><li><a href=https://devdosvid.blog/cv/ title="My CV"><span>My CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://devdosvid.blog>Home</a>&nbsp;¬ª&nbsp;<a href=https://devdosvid.blog/posts/>Posts</a></div><h1 class=post-title>New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2</h1><div class=post-description>New features that expand resources management options</div><div class=post-meta><span title="2022-05-04 22:27:47 +0200 +0200">May 4, 2022</span>&nbsp;¬∑&nbsp;7 min&nbsp;¬∑&nbsp;1379 words&nbsp;¬∑&nbsp;Serhii Vasylenko&nbsp;|&nbsp;<a href=mailto:contact@devdosvid.blog rel="noopener noreferrer" target=_blank>üì© Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy srcset="https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image_hu20330025958dd0a553d98ff32ea83f49_32314_360x0_resize_box_3.png 360w ,https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image_hu20330025958dd0a553d98ff32ea83f49_32314_480x0_resize_box_3.png 480w ,https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image_hu20330025958dd0a553d98ff32ea83f49_32314_720x0_resize_box_3.png 720w ,https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image_hu20330025958dd0a553d98ff32ea83f49_32314_1080x0_resize_box_3.png 1080w ,https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image.png 1200w" sizes="(min-width: 768px) 720px, 100vw" src=https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image.png alt width=1200 height=630></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#terraform-code-refactoring-with-the-moved-block aria-label="Terraform Code Refactoring With the Moved Block">Terraform Code Refactoring With the Moved Block</a><ul><li><a href=#moving-a-resource aria-label="Moving a resource">Moving a resource</a></li><li><a href=#moving-a-module aria-label="Moving a module">Moving a module</a></li></ul></li><li><a href=#lifecycle-expressions-precondition-postcondition-and-replace_triggered_by aria-label="Lifecycle expressions: precondition, postcondition, and replace_triggered_by">Lifecycle expressions: precondition, postcondition, and replace_triggered_by</a><ul><li><a href=#precondition-and-postcondition aria-label="Precondition and Postcondition">Precondition and Postcondition</a></li><li><a href=#validating-module-output-with-precondition aria-label="Validating module output with precondition">Validating module output with precondition</a></li><li><a href=#trigger-resource-replacement-with-replace_triggered_by aria-label="Trigger resource replacement with replace_triggered_by">Trigger resource replacement with replace_triggered_by</a></li></ul></li><li><a href=#getting-started-with-terraform-11-and-12 aria-label="Getting started with Terraform 1.1 and 1.2">Getting started with Terraform 1.1 and 1.2</a></li></ul></div></details></div><div class=post-content><p>In this blog, I would like to tell you about new cool features that Terraform 1.1 and 1.2 bring. It feels like Terraform has doubled its speed of delivering the new features after they released the 1.0. ü§©</p><p>It&rsquo;s been only a few months since Terraform 1.1 was released with the <code>moved</code> block that empowers the code refactoring.</p><p>Now Terraform 1.2 is almost <a href=*https://github.com/hashicorp/terraform/releases/tag/v1.2.0-rc1*>ready</a> (as I am writing this blog in early May 2022) to bring three new efficient controls to the resource lifecycle.<br>These are three new expressions: <code>precondition</code>, <code>postcondition</code>, and <code>replace_triggered_by</code>.</p><h2 id=terraform-code-refactoring-with-the-moved-block>Terraform Code Refactoring With the Moved Block<a hidden class=anchor aria-hidden=true href=#terraform-code-refactoring-with-the-moved-block>#</a></h2><p>Starting from the 1.1 version, Terraform users can use the <code>moved</code> block to describe the changes in resource or module addresses (or resources inside a module) in the form of code.<br>Once that is described, Terraform performs the movement of the resource within the state during the first apply.</p><p>In other words, what this feature gives you, is the ability to document your <code>terraform state mv</code> actions, so you and other project or module users don&rsquo;t need to perform them manually.</p><p>As your code evolves, a resource or module can have several <code>moved</code> blocks associated with it, and Terraform will thoroughly reproduce the whole history of its movement within a state (i.e., renaming).</p><p>Let&rsquo;s review some examples that illustrate how it works.</p><h3 id=moving-a-resource>Moving a resource<a hidden class=anchor aria-hidden=true href=#moving-a-resource>#</a></h3><p>In a module, I have a bucket policy that has a generic, meaningless name. It is used in a module that creates a CloudFront distribution with an S3 bucket.</p><figure><img loading=lazy src=figure-1.png alt="An example resource"><figcaption><p>An example resource</p></figcaption></figure><p>It&rsquo;s pretty OK to name a resource like that if you have only a single instance of that kind in your code.</p><p>Later, when I need to add another policy to the module, I don&rsquo;t want to name it &ldquo;that&rdquo;. Instead, I want my policies to have meaningful names now.<br>For example, I could rename the old policy with the <code>terraform state mv</code> command, but other users of my module would not know about that.</p><p>That is where the <code>moved</code> block turns out to be helpful: I can document the name change, and later, everyone else who uses my module will get the same renaming.</p><figure><img loading=lazy src=figure-2.png alt="Resource address update with the Moved block"><figcaption><p>Resource address update with the Moved block</p></figcaption></figure><p>Terraform follows the instructions inside the <code>module</code> block to plan and apply changes. Although the resource address update is not counted as a change in the Plan output, Terraform will perform that update during apply.</p><figure><img loading=lazy src=figure-3.png alt="Terraform plan output"><figcaption><p>Terraform plan output</p></figcaption></figure><h3 id=moving-a-module>Moving a module<a hidden class=anchor aria-hidden=true href=#moving-a-module>#</a></h3><p>The same approach can be applied to a module.</p><p>Here, I use two modules to create static hosting for a website with a custom TLS certificate.</p><figure><img loading=lazy src=figure-4.png alt="Two modules with generic names"><figcaption><p>Two modules with generic names</p></figcaption></figure><p>Again, if I need to add another couple of the CDN+Certificate modules, I would like to have meaningful names in my code so clearly distinguish one from another.</p><p>Therefore, I would add two <code>moved</code> blocks ‚Äî one per module call.</p><p>And by the way, since I renamed the module (from <code>cert</code> to <code>example_com_cert</code>), I need to update all references to that module&rsquo;s outputs in the code too.</p><figure><img loading=lazy src=figure-5.png alt="Two modules renamed"><figcaption><p>Two modules renamed</p></figcaption></figure><p>However, there is one nuance: when you rename a module and declare that in the <code>moved</code> block, you need to run the <code>terraform init</code> before applying the change because Terraform must initialize the module with the new name first.</p><figure><img loading=lazy src=figure-6.png alt="Terraform error: module not installed"><figcaption><p>Terraform error: module not installed</p></figcaption></figure><p>There are some more advanced actions you can make with the <code>moved</code> block:</p><ul><li>Implement count and for_each meta-arguments to resources and modules</li><li>Break one module into multiple
Check the following detailed guide from HashiCorp that explains how to do that ‚Äî <a href=https://www.terraform.io/language/modules/develop/refactoring>Refactoring</a></li></ul><p>Introducing the <code>moved</code> blocks into your codebase defacto starts the refactoring process for your module users. But the finale of that refactoring happens when you ultimately remove these blocks.</p><p>Therefore, here is some advice on how to manage that:</p><div class=attention><ul><li><p>Keep the <code>moved</code> blocks in your code for long. For example, when removing a <code>moved</code> block from the code, Terraform does not treat the new object name as a renaming anymore. Instead, Terraform will plan to delete the resource or module with the old name instead of renaming it.</p></li><li><p>Keep the complete chains of object renaming (sequence of moves). The whole history of object movement ensures that users with different module versions will get a consistent and predictable behavior of the refactoring.</p></li></ul></div><h2 id=lifecycle-expressions-precondition-postcondition-and-replace_triggered_by>Lifecycle expressions: precondition, postcondition, and replace_triggered_by<a hidden class=anchor aria-hidden=true href=#lifecycle-expressions-precondition-postcondition-and-replace_triggered_by>#</a></h2><p>Terraform 1.2 fundamentally improves the <code>lifecycle</code> meta-argument by adding three new configuration options with rich capabilities.</p><figure><img loading=lazy src=figure-7.png alt="New configuration options for the lifecycle meta-argument"><figcaption><p>New configuration options for the lifecycle meta-argument</p></figcaption></figure><h3 id=precondition-and-postcondition>Precondition and Postcondition<a hidden class=anchor aria-hidden=true href=#precondition-and-postcondition>#</a></h3><p>When you need to make sure that specific condition is met before or after you create a resource, you can use <code>postcondition</code> and <code>precondition</code> blocks.</p><p>The <em>condition</em> here ‚Äî is some data or information about a resource you need to confirm to apply the code.</p><p>Here are a few examples of such conditions:</p><ul><li>Validate some attributes of the Data Source that you cannot check using filters or other available arguments;</li><li>Confirm the Resource argument that can compound several variables (e.g., list);</li></ul><div class=attention><p><strong>Precondition</strong> works as an expectation or a guess about some external (but within a module) value that a resource depends on.</p><p><strong>Postcondition</strong> works as the assurance that a resource fulfills a specific condition so other resources may rely on that. If postcondition fails for a resource, this prevents changes to all other resources that depend on it.</p></div><p>Let&rsquo;s review this new feature with an example of <code>postcondition</code> usage.</p><p>Consider the following case: our module receives AMI ID as the input variable, and that AMI should be used in the Launch Template then; we also have the requirement for the EC2 instance created from that Launch Template ‚Äî its root EBS size must be equal or bigger than 600 GB.</p><p>We cannot validate the EBS size using the variable that accepts the AMI ID. But we can write a <strong>postcondition</strong> for the Data Source that gets the information about the AMI and reference that Data Source in the Launch Template resource afterward.</p><figure><img loading=lazy src=figure-8.png alt="Data Source Postcondition"><figcaption><p>Data Source Postcondition</p></figcaption></figure><p>The <code>condition</code> argument within the block accepts any of Terraform&rsquo;s built-in functions or language operators.</p><p>The special <code>self</code> object is available only for the <code>postcondition</code> block because it assumes that validation can be performed after the object is created and its attributes are known.</p><p>Later, if a module user specifies the AMI with an EBS size lesser than 600 GB, Terraform will fail to create the Launch Template because it depends on the Data Source that did not pass the postcondition check.</p><figure><img loading=lazy src=figure-9.png alt="Resource postcondition error"><figcaption><p>Resource postcondition error</p></figcaption></figure><p>Terraform tries to evaluate the condition expressions as soonest: sometimes Terraform can check the value during the planning phase, but sometimes that can be done only after the resource is created if the value is unknown.</p><h3 id=validating-module-output-with-precondition>Validating module output with precondition<a hidden class=anchor aria-hidden=true href=#validating-module-output-with-precondition>#</a></h3><p>The <code>precondition</code> block is also available for the module outputs.</p><p>Just like the variable validation block assures that module input meets certain expectations, the <code>precondition</code> is intended to ensure that a module produces the valid output.</p><p>Here is an example: a module that creates an ACM certificate must prevent the usage of a specific domain name in the certificate&rsquo;s Common Name or its SANs.</p><figure><img loading=lazy src=figure-10.png alt="Module output precondition"><figcaption><p>Module output precondition</p></figcaption></figure><p>In this case, instead of validating several input variables, we can write the validation only once for the output.</p><h3 id=trigger-resource-replacement-with-replace_triggered_by>Trigger resource replacement with replace_triggered_by<a hidden class=anchor aria-hidden=true href=#trigger-resource-replacement-with-replace_triggered_by>#</a></h3><p>Sometimes it&rsquo;s needed to specify the dependency in the way that recreates a resource when another resource or its attribute changes.</p><p>This is useful when two (or more) resources do not have any explicit dependency.</p><p>Consider the following case: you have two EC2 instances, A and B, and need to recreate the B instance if the private IP of instance A is changed.</p><figure><img loading=lazy src=figure-11.png alt="replace_triggered_by example"><figcaption><p>replace_triggered_by example</p></figcaption></figure><p>This is extremely useful when you&rsquo;re dealing with logical abstractions over the set of resources.</p><div class=attention><p>Replacement is triggered when:</p><ul><li>any of the resources referenced in <code>replace_triggered_by</code> are updated</li><li>any value is set to the resource attribute that is referenced in <code>replace_triggered_by</code></li></ul></div><h2 id=getting-started-with-terraform-11-and-12>Getting started with Terraform 1.1 and 1.2<a hidden class=anchor aria-hidden=true href=#getting-started-with-terraform-11-and-12>#</a></h2><p>If you&rsquo;re still using older Terraform versions, these new features might be a good motivation for you to upgrade!</p><p>Before upgrading, be sure to read the upgrade notes for the specific version at the <a href=https://github.com/hashicorp/terraform/releases>releases page</a>.</p><p>Also, an excellent tool can help with fast switching between different Terraform versions while you&rsquo;re experimenting ‚Äî <a href=https://tfswitch.warrensbox.com/>tfswitch</a>.</p></div><footer class=post-footer><div class=post-series><p>Check out other posts of the <b>"Terraform Proficiency"</b> series:</p><ul><li style=opacity:.75>May 04, 2022 ‚Äî New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2</li><li>Jan 16, 2022 ‚Äî <a href="https://devdosvid.blog/2022/01/16/some-techniques-to-enhance-your-terraform-proficiency/?utm_blogseries=terraform-proficiency">Some Techniques to Enhance Your Terraform Proficiency</a></li><li>Nov 24, 2021 ‚Äî <a href="https://devdosvid.blog/2021/11/24/guide-to-using-terraform-in-ci/cd/?utm_blogseries=terraform-proficiency">Guide to Using Terraform in CI/CD</a></li><li>Aug 25, 2020 ‚Äî <a href="https://devdosvid.blog/2020/08/25/terraform-cli-shortcuts/?utm_blogseries=terraform-proficiency">Terraform CLI shortcuts</a></li></ul></div><ul class=post-tags></ul><div class=license><p>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nd/4.0/>Creative Commons Attribution-NoDerivatives 4.0 International License</a></p></div><div id=mc_embed_signup><form action="https://blog.us14.list-manage.com/subscribe/post?u=3ed96dff62b34472abaed6122&id=5fd01eb424" method=post id=mc-embedded-subscribe-form name=mc-embedded-subscribe-form class=validate target=_blank novalidate><div id=mc_embed_signup_scroll><h3>Subscribe for the blog updates!</h3><h4>No spam. I promise.</h4><div class=mc-field-group><input type=email placeholder="Enter your email here" name=EMAIL class="required email" id=mce-EMAIL></div><div hidden><input type=hidden name=tags value=7268620></div><div id=mce-responses class="clear foot"><div class=response id=mce-error-response style=display:none></div><div class=response id=mce-success-response style=display:none></div></div><div style=position:absolute;left:-5000px aria-hidden=true><input type=text name=b_3ed96dff62b34472abaed6122_5fd01eb424 tabindex=-1></div><div class=optionalParent><div class="clear foot"><input type=submit value=Subscribe name=subscribe id=mc-embedded-subscribe class=button></div></div></div></form></div><script type=text/javascript src=//s3.amazonaws.com/downloads.mailchimp.com/js/mc-validate.js></script><script type=text/javascript>(function(){window.fnames=new Array,window.ftypes=new Array,fnames[0]="EMAIL",ftypes[0]="email",fnames[1]="FNAME",ftypes[1]="text",fnames[2]="LNAME",ftypes[2]="text",fnames[3]="ADDRESS",ftypes[3]="address",fnames[4]="PHONE",ftypes[4]="phone",fnames[5]="BIRTHDAY",ftypes[5]="birthday"})(jQuery);var $mcj=jQuery.noConflict(!0)</script><nav class=paginav><a class=next href=https://devdosvid.blog/2022/01/31/monterey-shortcuts-for-easy-and-fast-image-processing/><span class=title>Next Page ¬ª</span><br><span>Monterey Shortcuts for Easy and Fast Image Processing</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://devdosvid.blog>devDosvid ‚Äî technical blog about my cloud engineering experience</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>