<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2 | devDosvid blog</title>
<meta name=keywords content="Terraform,Infrastructure as code,DevOps,Refactoring,Cloud infrastructure"><meta name=description content="Terraform code refactoring and resource lifecycle conditions, and triggers ‚Äî now natively available"><meta name=author content="Serhii Vasylenko"><link rel=canonical href=https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/><link crossorigin=anonymous href=/assets/css/stylesheet.51adfef0209146fea88d574556a024fb0fe75550725c247200ff67f0bd77de4a.css integrity="sha256-Ua3+8CCRRv6ojVdFVqAk+w/nVVByXCRyAP9n8L133ko=" rel="preload stylesheet" as=style><link rel=icon href=https://devdosvid.blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://devdosvid.blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://devdosvid.blog/favicon-32x32.png><link rel=apple-touch-icon href=https://devdosvid.blog/apple-touch-icon.png><link rel=mask-icon href=https://devdosvid.blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><style>@font-face{font-family:albert sans;font-style:normal;font-display:swap;font-weight:300;src:url(/assets/fonts/AlbertSans-Light.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:italic;font-display:swap;font-weight:300;src:url(/assets/fonts/AlbertSans-LightItalic.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:normal;font-display:swap;font-weight:400;src:url(/assets/fonts/AlbertSans-Regular.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:italic;font-display:swap;font-weight:400;src:url(/assets/fonts/AlbertSans-Italic.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:normal;font-display:swap;font-weight:500;src:url(/assets/fonts/AlbertSans-Medium.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:italic;font-display:swap;font-weight:500;src:url(/assets/fonts/AlbertSans-MediumItalic.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:normal;font-display:swap;font-weight:600;src:url(/assets/fonts/AlbertSans-SemiBold.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:albert sans;font-style:italic;font-display:swap;font-weight:600;src:url(/assets/fonts/AlbertSans-SemiBoldItalic.woff2)format('woff');unicode-range:U+??,U+131,U+152-153,U+2BB-2BC,U+2C6,U+2DA,U+2DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style><meta name=twitter:creator content="@vasylenko"><meta name=twitter:site content="@vasylenko"><script defer type=text/javascript>window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{},n=document.createElement("script"),n.type="text/javascript",n.async=!0,n.src="https://cdn.heapanalytics.com/js/heap-"+e+".js",o=document.getElementsByTagName("script")[0],o.parentNode.insertBefore(n,o);for(var n,o,a=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},i=["addEventProperties","addUserProperties","clearEventProperties","identify","resetIdentity","removeEventProperty","setEventProperties","track","unsetEventProperty"],s=0;s<i.length;s++)heap[i[s]]=a(i[s])},heap.load("2300872157")</script><meta property="og:title" content="New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2"><meta property="og:description" content="Terraform code refactoring and resource lifecycle conditions, and triggers ‚Äî now natively available"><meta property="og:type" content="article"><meta property="og:url" content="https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/"><meta property="og:image" content="https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-04T22:27:47+02:00"><meta property="article:modified_time" content="2024-04-11T22:29:25+02:00"><meta property="og:site_name" content="devDosvid blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image.png"><meta name=twitter:title content="New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2"><meta name=twitter:description content="Terraform code refactoring and resource lifecycle conditions, and triggers ‚Äî now natively available"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://devdosvid.blog/posts/"},{"@type":"ListItem","position":2,"name":"New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2","item":"https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2","name":"New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2","description":"Terraform code refactoring and resource lifecycle conditions, and triggers ‚Äî now natively available","keywords":["Terraform, Infrastructure as code, DevOps, Refactoring, Cloud infrastructure"],"articleBody":"In this blog, I would like to tell you about new cool features that Terraform 1.1 and 1.2 bring. It feels like Terraform has doubled its speed of delivering the new features after they released the 1.0. ü§©\nIt‚Äôs been only a few months since Terraform 1.1 was released with the moved block that empowers the code refactoring.\nNow Terraform 1.2 is almost ready (as I am writing this blog in early May 2022) to bring three new efficient controls to the resource lifecycle.\nThese are three new expressions: precondition, postcondition, and replace_triggered_by.\nSubscribe to blog updates! Terraform Code Refactoring With the Moved Block Starting from the 1.1 version, Terraform users can use the moved block to describe the changes in resource or module addresses (or resources inside a module) in the form of code. Once that is described, Terraform performs the movement of the resource within the state during the first apply.\nIn other words, what this feature gives you, is the ability to document your terraform state mv actions, so you and other project or module users don‚Äôt need to perform them manually.\nAs your code evolves, a resource or module can have several moved blocks associated with it, and Terraform will thoroughly reproduce the whole history of its movement within a state (i.e., renaming).\nLet‚Äôs review some examples that illustrate how it works.\nMove or rename a resource In a module, I have a bucket policy that has a generic, meaningless name. It is used in a module that creates a CloudFront distribution with an S3 bucket.\nAn example resource\nIt‚Äôs pretty OK to name a resource like that if you have only a single instance of that kind in your code.\nLater, when I need to add another policy to the module, I don‚Äôt want to name it ‚Äúthat‚Äù. Instead, I want my policies to have meaningful names now.\nFor example, I could rename the old policy with the terraform state mv command, but other users of my module would not know about that.\nThat is where the moved block turns out to be helpful!\nThe moved block allows you to document how you rename or move an object in Terraform so that other code users can have the same changes afterward. Resource address update with the Moved block\nTerraform follows the instructions inside the module block to plan and apply changes. Although the resource address update is not counted as a change in the Plan output, Terraform will perform that update during apply.\nTerraform plan output\nMove or rename a module The same approach can be applied to a module ‚Äî you can move or rename it as a code too.\nHere, I use two modules to create static hosting for a website with a custom TLS certificate.\nTwo modules with generic names\nAgain, if I need to add another couple of the CDN+Certificate modules, I would like to have meaningful names in my code so clearly distinguish one from another.\nTherefore, I would add two moved blocks ‚Äî one per module call.\nAnd by the way, since I renamed the module (from cert to example_com_cert), I need to update all references to that module‚Äôs outputs in the code too.\nTwo modules renamed\nHowever, there is one nuance: when you rename a module and declare that in the moved block, you need to run the terraform init before applying the change because Terraform must initialize the module with the new name first.\nTerraform error: module not installed\nThere are some more advanced actions you can make with the moved block:\nImplement count and for_each meta-arguments to resources and modules Break one module into multiple Check the following detailed guide from HashiCorp that explains how to do that ‚Äî Refactoring Introducing the moved blocks into your codebase defacto starts the refactoring process for your module users. But the finale of that refactoring happens when you ultimately remove these blocks.\nTherefore, here is some advice on how to manage that:\nKeep the moved blocks in your code for long. For example, when removing a moved block from the code, Terraform does not treat the new object name as a renaming anymore. Instead, Terraform will plan to delete the resource or module with the old name instead of renaming it.\nKeep the complete chains of object renaming (sequence of moves). The whole history of object movement ensures that users with different module versions will get a consistent and predictable behavior of the refactoring.\nLifecycle expressions: conditions and replacement trigger Terraform 1.2 fundamentally improves the lifecycle meta-argument by adding three new configuration options with rich capabilities.\nNew configuration options for the lifecycle meta-argument\nPrecondition and Postcondition When you need to make sure that specific condition is met before or after you create a resource, you can use postcondition and precondition blocks.\nThe condition here ‚Äî is some data or information about a resource you need to confirm to apply the code.\nHere are a few examples of such conditions:\nValidate some attributes of the Data Source that you cannot check using filters or other available arguments; Confirm the Resource argument that can compound several variables (e.g., list); Precondition works as an expectation or a guess about some external (but within a module) value that a resource depends on.\nPostcondition works as the assurance that a resource fulfills a specific condition so other resources may rely on that. If postcondition fails for a resource, this prevents changes to all other resources that depend on it.\nLet‚Äôs review this new feature with an example of postcondition usage.\nConsider the following case: our module receives AMI ID as the input variable, and that AMI should be used in the Launch Template then; we also have the requirement for the EC2 instance created from that Launch Template ‚Äî its root EBS size must be equal or bigger than 600 GB.\nWe cannot validate the EBS size using the variable that accepts the AMI ID. But we can write a postcondition for the Data Source that gets the information about the AMI and reference that Data Source in the Launch Template resource afterward.\nData Source Postcondition\nThe condition argument within the block accepts any of Terraform‚Äôs built-in functions or language operators.\nThe special self object is available only for the postcondition block because it assumes that validation can be performed after the object is created and its attributes are known.\nLater, if a module user specifies the AMI with an EBS size lesser than 600 GB, Terraform will fail to create the Launch Template because it depends on the Data Source that did not pass the postcondition check.\nResource postcondition error\nTerraform tries to evaluate the condition expressions as soonest: sometimes Terraform can check the value during the planning phase, but sometimes that can be done only after the resource is created if the value is unknown.\nValidate module output with precondition The precondition block is also available for the module outputs.\nJust like the variable validation block assures that module input meets certain expectations, the precondition is intended to ensure that a module produces the valid output.\nHere is an example: a module that creates an ACM certificate must prevent the usage of a specific domain name in the certificate‚Äôs Common Name or its SANs.\nModule output precondition\nIn this case, instead of validating several input variables, we can write the validation only once for the output.\nValidation of the module output helps with standardization and control of the data passed between Terraform modules. Trigger resource replacement with replace_triggered_by Sometimes it‚Äôs needed to specify the dependency in the way that recreates a resource when another resource or its attribute changes.\nThis is useful when two (or more) resources do not have any explicit dependency.\nConsider the following case: you have two EC2 instances, A and B, and need to recreate the B instance if the private IP of instance A is changed.\nreplace_triggered_by example\nThis is extremely useful when you‚Äôre dealing with logical abstractions over the set of resources.\nResource replacement is triggered when:\nany of the resources referenced in replace_triggered_by are updated any value is set to the resource attribute that is referenced in replace_triggered_by Getting started with Terraform 1.1 and 1.2 If you‚Äôre still using older Terraform versions, these new features might be a good motivation for you to upgrade!\nBefore upgrading, be sure to read the upgrade notes for the specific version at the releases page.\nAlso, an excellent tool can help with fast switching between different Terraform versions while you‚Äôre experimenting ‚Äî tfswitch.\n","wordCount":"1424","inLanguage":"en","image":"https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image.png","datePublished":"2022-05-04T22:27:47+02:00","dateModified":"2024-04-11T22:29:25+02:00","author":{"@type":"Person","name":"Serhii Vasylenko"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/"},"publisher":{"@type":"Person","name":"devDosvid blog","logo":{"@type":"ImageObject","url":"https://devdosvid.blog/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://devdosvid.blog/ accesskey=h title="üè† Home (Alt + H)">üè† Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://devdosvid.blog/index.xml title="RSS Feed"><span>RSS Feed</span></a></li><li><a href=https://devdosvid.blog/archive title="All posts"><span>All posts</span></a></li><li><a href=https://devdosvid.blog/about/ title="About me"><span>About me</span></a></li><li><a href=https://devdosvid.blog/series title="Post Series"><span>Post Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://devdosvid.blog/>Home</a>&nbsp;¬ª&nbsp;<a href=https://devdosvid.blog/posts/>Posts</a></div><h1 class=post-title>New Lifecycle Options and Refactoring Capabilities in Terraform 1.1 and 1.2</h1><div class=post-description>Terraform code refactoring and resource lifecycle conditions, and triggers ‚Äî now natively available</div><div class=post-meta><span title='2022-05-04 22:27:47 +0200 +0200'>May 4, 2022</span>&nbsp;¬∑&nbsp;Serhii Vasylenko&nbsp;|&nbsp;<a href=mailto:contact@devdosvid.blog rel="noopener noreferrer" target=_blank>Contact me</a></div></header><figure class=entry-cover><img srcset="https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image_hu776bd87baf8c84ff4bf1d1c0a52dcc22_10662_360x0_resize_box_3.png 360w ,https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image_hu776bd87baf8c84ff4bf1d1c0a52dcc22_10662_480x0_resize_box_3.png 480w ,https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image_hu776bd87baf8c84ff4bf1d1c0a52dcc22_10662_720x0_resize_box_3.png 720w ,https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image_hu776bd87baf8c84ff4bf1d1c0a52dcc22_10662_1080x0_resize_box_3.png 1080w ,https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image.png 1200w" sizes="(min-width: 768px) 720px, 100vw" src=https://devdosvid.blog/2022/05/04/new-lifecycle-options-and-refactoring-capabilities-in-terraform-1-1-and-1-2/cover-image.png alt width=1200 height=630></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=# aria-label="Subscribe to blog updates!">Subscribe to blog updates!</a></li></ul><li><a href=#terraform-code-refactoring-with-the-moved-block aria-label="Terraform Code Refactoring With the Moved Block">Terraform Code Refactoring With the Moved Block</a><ul><li><a href=#move-or-rename-a-resource aria-label="Move or rename a resource">Move or rename a resource</a></li><li><a href=#move-or-rename-a-module aria-label="Move or rename a module">Move or rename a module</a></li></ul></li><li><a href=#lifecycle-expressions-conditions-and-replacement-trigger aria-label="Lifecycle expressions: conditions and replacement trigger">Lifecycle expressions: conditions and replacement trigger</a><ul><li><a href=#precondition-and-postcondition aria-label="Precondition and Postcondition">Precondition and Postcondition</a></li><li><a href=#validate-module-output-with-precondition aria-label="Validate module output with precondition">Validate module output with precondition</a></li><li><a href=#trigger-resource-replacement-with-replace_triggered_by aria-label="Trigger resource replacement with replace_triggered_by">Trigger resource replacement with replace_triggered_by</a></li></ul></li><li><a href=#getting-started-with-terraform-11-and-12 aria-label="Getting started with Terraform 1.1 and 1.2">Getting started with Terraform 1.1 and 1.2</a></li></ul></div></details></div><div class=post-content><p>In this blog, I would like to tell you about new cool features that Terraform 1.1 and 1.2 bring. It feels like Terraform has doubled its speed of delivering the new features after they released the 1.0. ü§©</p><p>It&rsquo;s been only a few months since Terraform 1.1 was released with the <code>moved</code> block that empowers the code refactoring.</p><p>Now Terraform 1.2 is almost <a href=*https://github.com/hashicorp/terraform/releases/tag/v1.2.0-rc1*>ready</a> (as I am writing this blog in early May 2022) to bring three new efficient controls to the resource lifecycle.<br>These are three new expressions: <code>precondition</code>, <code>postcondition</code>, and <code>replace_triggered_by</code>.</p><div class=substack-embedded-container><h3>Subscribe to blog updates!</h3><iframe title=Substack class=substack-embedded-iframe src=https://devdosvid.substack.com/embed height=250 loading=lazy></iframe></div><h2 id=terraform-code-refactoring-with-the-moved-block>Terraform Code Refactoring With the Moved Block<a hidden class=anchor aria-hidden=true href=#terraform-code-refactoring-with-the-moved-block>#</a></h2><p>Starting from the 1.1 version, Terraform users can use the <code>moved</code> block to describe the changes in resource or module addresses (or resources inside a module) in the form of code.<br>Once that is described, Terraform performs the movement of the resource within the state during the first apply.</p><p>In other words, what this feature gives you, is the ability to document your <code>terraform state mv</code> actions, so you and other project or module users don&rsquo;t need to perform them manually.</p><p>As your code evolves, a resource or module can have several <code>moved</code> blocks associated with it, and Terraform will thoroughly reproduce the whole history of its movement within a state (i.e., renaming).</p><p>Let&rsquo;s review some examples that illustrate how it works.</p><h3 id=move-or-rename-a-resource>Move or rename a resource<a hidden class=anchor aria-hidden=true href=#move-or-rename-a-resource>#</a></h3><p>In a module, I have a bucket policy that has a generic, meaningless name. It is used in a module that creates a CloudFront distribution with an S3 bucket.</p><figure><img loading=lazy src=figure-1.png alt="An example resource" width=800 height=150><figcaption><p>An example resource</p></figcaption></figure><p>It&rsquo;s pretty OK to name a resource like that if you have only a single instance of that kind in your code.</p><p>Later, when I need to add another policy to the module, I don&rsquo;t want to name it &ldquo;that&rdquo;. Instead, I want my policies to have meaningful names now.<br>For example, I could rename the old policy with the <code>terraform state mv</code> command, but other users of my module would not know about that.</p><p>That is where the <code>moved</code> block turns out to be helpful!</p><div class=attention>The <code>moved</code> block allows you to document how you rename or move an object in Terraform so that other code users can have the same changes afterward.</div><figure><img loading=lazy src=figure-2.png alt="Resource address update with the Moved block" width=800 height=270><figcaption><p>Resource address update with the Moved block</p></figcaption></figure><p>Terraform follows the instructions inside the <code>module</code> block to plan and apply changes. Although the resource address update is not counted as a change in the Plan output, Terraform will perform that update during apply.</p><figure><img loading=lazy src=figure-3.png alt="Terraform plan output" width=800 height=318><figcaption><p>Terraform plan output</p></figcaption></figure><h3 id=move-or-rename-a-module>Move or rename a module<a hidden class=anchor aria-hidden=true href=#move-or-rename-a-module>#</a></h3><p>The same approach can be applied to a module ‚Äî you can move or rename it as a code too.</p><p>Here, I use two modules to create static hosting for a website with a custom TLS certificate.</p><figure><img loading=lazy src=figure-4.png alt="Two modules with generic names" width=800 height=437><figcaption><p>Two modules with generic names</p></figcaption></figure><p>Again, if I need to add another couple of the CDN+Certificate modules, I would like to have meaningful names in my code so clearly distinguish one from another.</p><p>Therefore, I would add two <code>moved</code> blocks ‚Äî one per module call.</p><p>And by the way, since I renamed the module (from <code>cert</code> to <code>example_com_cert</code>), I need to update all references to that module&rsquo;s outputs in the code too.</p><figure><img loading=lazy src=figure-5.png alt="Two modules renamed" width=800 height=629><figcaption><p>Two modules renamed</p></figcaption></figure><p>However, there is one nuance: when you rename a module and declare that in the <code>moved</code> block, you need to run the <code>terraform init</code> before applying the change because Terraform must initialize the module with the new name first.</p><figure><img loading=lazy src=figure-6.png alt="Terraform error: module not installed" width=800 height=246><figcaption><p>Terraform error: module not installed</p></figcaption></figure><p>There are some more advanced actions you can make with the <code>moved</code> block:</p><ul><li>Implement count and for_each meta-arguments to resources and modules</li><li>Break one module into multiple
Check the following detailed guide from HashiCorp that explains how to do that ‚Äî <a href=https://www.terraform.io/language/modules/develop/refactoring>Refactoring</a></li></ul><p>Introducing the <code>moved</code> blocks into your codebase defacto starts the refactoring process for your module users. But the finale of that refactoring happens when you ultimately remove these blocks.</p><p>Therefore, here is some advice on how to manage that:</p><div class=attention><ul><li><p>Keep the <code>moved</code> blocks in your code for long. For example, when removing a <code>moved</code> block from the code, Terraform does not treat the new object name as a renaming anymore. Instead, Terraform will plan to delete the resource or module with the old name instead of renaming it.</p></li><li><p>Keep the complete chains of object renaming (sequence of moves). The whole history of object movement ensures that users with different module versions will get a consistent and predictable behavior of the refactoring.</p></li></ul></div><h2 id=lifecycle-expressions-conditions-and-replacement-trigger>Lifecycle expressions: conditions and replacement trigger<a hidden class=anchor aria-hidden=true href=#lifecycle-expressions-conditions-and-replacement-trigger>#</a></h2><p>Terraform 1.2 fundamentally improves the <code>lifecycle</code> meta-argument by adding three new configuration options with rich capabilities.</p><figure><img loading=lazy src=figure-7.png alt="New configuration options for the lifecycle meta-argument" width=800 height=365><figcaption><p>New configuration options for the lifecycle meta-argument</p></figcaption></figure><h3 id=precondition-and-postcondition>Precondition and Postcondition<a hidden class=anchor aria-hidden=true href=#precondition-and-postcondition>#</a></h3><p>When you need to make sure that specific condition is met before or after you create a resource, you can use <code>postcondition</code> and <code>precondition</code> blocks.</p><p>The <em>condition</em> here ‚Äî is some data or information about a resource you need to confirm to apply the code.</p><p>Here are a few examples of such conditions:</p><ul><li>Validate some attributes of the Data Source that you cannot check using filters or other available arguments;</li><li>Confirm the Resource argument that can compound several variables (e.g., list);</li></ul><div class=attention><p><strong>Precondition</strong> works as an expectation or a guess about some external (but within a module) value that a resource depends on.</p><p><strong>Postcondition</strong> works as the assurance that a resource fulfills a specific condition so other resources may rely on that. If postcondition fails for a resource, this prevents changes to all other resources that depend on it.</p></div><p>Let&rsquo;s review this new feature with an example of <code>postcondition</code> usage.</p><p>Consider the following case: our module receives AMI ID as the input variable, and that AMI should be used in the Launch Template then; we also have the requirement for the EC2 instance created from that Launch Template ‚Äî its root EBS size must be equal or bigger than 600 GB.</p><p>We cannot validate the EBS size using the variable that accepts the AMI ID. But we can write a <strong>postcondition</strong> for the Data Source that gets the information about the AMI and reference that Data Source in the Launch Template resource afterward.</p><figure><img loading=lazy src=figure-8.png alt="Data Source Postcondition" width=800 height=446><figcaption><p>Data Source Postcondition</p></figcaption></figure><p>The <code>condition</code> argument within the block accepts any of Terraform&rsquo;s built-in functions or language operators.</p><p>The special <code>self</code> object is available only for the <code>postcondition</code> block because it assumes that validation can be performed after the object is created and its attributes are known.</p><p>Later, if a module user specifies the AMI with an EBS size lesser than 600 GB, Terraform will fail to create the Launch Template because it depends on the Data Source that did not pass the postcondition check.</p><figure><img loading=lazy src=figure-9.png alt="Resource postcondition error" width=800 height=240><figcaption><p>Resource postcondition error</p></figcaption></figure><p>Terraform tries to evaluate the condition expressions as soonest: sometimes Terraform can check the value during the planning phase, but sometimes that can be done only after the resource is created if the value is unknown.</p><h3 id=validate-module-output-with-precondition>Validate module output with precondition<a hidden class=anchor aria-hidden=true href=#validate-module-output-with-precondition>#</a></h3><p>The <code>precondition</code> block is also available for the module outputs.</p><p>Just like the variable validation block assures that module input meets certain expectations, the <code>precondition</code> is intended to ensure that a module produces the valid output.</p><p>Here is an example: a module that creates an ACM certificate must prevent the usage of a specific domain name in the certificate&rsquo;s Common Name or its SANs.</p><figure><img loading=lazy src=figure-10.png alt="Module output precondition" width=800 height=342><figcaption><p>Module output precondition</p></figcaption></figure><p>In this case, instead of validating several input variables, we can write the validation only once for the output.</p><div class=attention>Validation of the module output helps with standardization and control of the data passed between Terraform modules.</div><h3 id=trigger-resource-replacement-with-replace_triggered_by>Trigger resource replacement with replace_triggered_by<a hidden class=anchor aria-hidden=true href=#trigger-resource-replacement-with-replace_triggered_by>#</a></h3><p>Sometimes it&rsquo;s needed to specify the dependency in the way that recreates a resource when another resource or its attribute changes.</p><p>This is useful when two (or more) resources do not have any explicit dependency.</p><p>Consider the following case: you have two EC2 instances, A and B, and need to recreate the B instance if the private IP of instance A is changed.</p><figure><img loading=lazy src=figure-11.png alt="replace_triggered_by example" width=800 height=342><figcaption><p>replace_triggered_by example</p></figcaption></figure><p>This is extremely useful when you&rsquo;re dealing with logical abstractions over the set of resources.</p><div class=attention><p>Resource replacement is triggered when:</p><ul><li>any of the resources referenced in <code>replace_triggered_by</code> are updated</li><li>any value is set to the resource attribute that is referenced in <code>replace_triggered_by</code></li></ul></div><h2 id=getting-started-with-terraform-11-and-12>Getting started with Terraform 1.1 and 1.2<a hidden class=anchor aria-hidden=true href=#getting-started-with-terraform-11-and-12>#</a></h2><p>If you&rsquo;re still using older Terraform versions, these new features might be a good motivation for you to upgrade!</p><p>Before upgrading, be sure to read the upgrade notes for the specific version at the <a href=https://github.com/hashicorp/terraform/releases>releases page</a>.</p><p>Also, an excellent tool can help with fast switching between different Terraform versions while you&rsquo;re experimenting ‚Äî <a href=https://tfswitch.warrensbox.com/>tfswitch</a>.</p></div><footer class=post-footer><div class=substack-embedded-container><h3>Subscribe to blog updates!</h3><iframe title=Substack class=substack-embedded-iframe src=https://devdosvid.substack.com/embed height=250 loading=lazy></iframe></div><script src=https://giscus.app/client.js data-repo=vasylenko/devdosvid.blog data-repo-id="MDEwOlJlcG9zaXRvcnkyNDUyNTMxODE=" data-category=General data-category-id=DIC_kwDODp5EPc4CA59c data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=en data-theme=purge crossorigin=anonymous async></script><div class=post-series><p>Check out other posts of the <b>"Terraform Proficiency"</b> series:</p><ul></ul></div><ul class=post-tags></ul><div class=license><p>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nd/4.0/>Creative Commons Attribution-NoDerivatives 4.0 International License</a></p></div><nav class=paginav><a class=prev href=https://devdosvid.blog/2022/06/26/golden-image-pipelines-with-hcp-packer/><span class=title>¬´ Prev</span><br><span>Golden Image Pipelines With HCP Packer</span>
</a><a class=next href=https://devdosvid.blog/2022/01/31/monterey-shortcuts-for-easy-and-fast-image-processing/><span class=title>Next ¬ª</span><br><span>Monterey Shortcuts for Easy and Fast Image Processing</span></a></nav></footer></article></main><footer class=footer><div style=width:10em;margin:auto><p style=background-color:#0082ca;color:#fff>From Ukrainian</p><p style=background-color:#ffb548;color:#fff>with love ‚ù§Ô∏è</p></div><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>